#!/usr/bin/perl

$license = <<EOF
Copyright (c) 1999-2001 Matthew Sachs.  All Rights Reserved.

   This program is free software; you can redistribute it and/or
   modify it under the terms of version 2 of the GNU General Public License
   as published by the Free Software Foundation.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

   The GNU General Public License is included with the aimirc distribution
   under the filename COPYING.

 AOL Instant Messenger, AOL, and America Online are trademarks of America Online, Inc.
EOF
;

use strict;
use vars qw(%specifications $usercount $maxusers $chatseq $oscarprime $home $version $VERSION @args $prefix $usnick $us $them $themport $ourpass $theirpass $servermode $time $user_loglevel @default_conffiles $fork $verbose $sendidle $oscarserver $oscarport %dcc $shortcircuit @conffiles $debug %debuglevel $dccip %ircservers $dcc $reload $upstream $aim_connections $irc_connections $aimircdebug $longnicks @dccqueue $lasttime $checktime $keepalive $themname $nicks $shortnicks %chantimer %chats %dccget %debug $irc_away $license @getbuff $numeric $starttime $away);


# DCC states
# Iff state & 1, it's a SEND.
# Iff state & 2, we care about if the socket is ready for writing.
use constant DCC_STATE_SEND => 1;
use constant DCC_STATE_WRITE => 2;

use constant DCC_STATE_SEND_LISTEN => DCC_STATE_SEND | (1<<2); #5
use constant DCC_STATE_SEND_READY => DCC_STATE_SEND | DCC_STATE_WRITE | (2<<2); #8
use constant DCC_STATE_SEND_NEEDACK => DCC_STATE_SEND | (3<<2); #13
use constant DCC_STATE_GET_CONNECT => DCC_STATE_WRITE | 1<<2; #6
use constant DCC_STATE_GET_READY => 2<<2; #8
use constant DCC_STATE_GET_SENDACK => DCC_STATE_WRITE | (3<<2); #14


$starttime = time;

$| = 1;

sub END { &going_down; }

sub BEGIN {
	require File::Basename;
	push @INC, File::Basename::dirname($0)."/lib";
	push @INC, File::Basename::dirname($0);

	require 5.006;

	eval {
		require HTML::FormatText;
		require HTML::Parse;
		require MIME::Base64;
		require Net::OSCAR;
		require Net::OSCAR::Screenname;
		Net::OSCAR->import(qw(:standard :loglevels normalize));
		import MIME::Base64;
	};

	$@ .= "We require Net::OSCAR 0.08 or newer - you have $Net::OSCAR::VERSION.\n" unless $Net::OSCAR::VERSION >= 0.08;
	if($@) {
		print STDERR "We couldn't load some required modules for the following reason:\n";
		print STDERR "$@\n";
		print STDERR "\n\n";
		print STDERR "And here's what that probably means...\n\n";
		print STDERR "You do not have the necessary modules installed.\n";
		print STDERR "Please run the getmodules script included with the aimirc distribution.\n";
		print STDERR "You may of course install the modules by hand if you prefer.\n";
		die "\n";
	}
}

use IO::Handle;
use IO::Socket;
use POSIX;
use Carp;
use Getopt::Long;
use File::Basename;
use FormatAIMIRC;
use Symbol;

$Carp::Verbose = 1;

eval { require Data::Dumper; };

$SIG{__DIE__}  = sub { croak $_[0] };

$home = (getpwuid($>))[7];
$version = $VERSION = '1.5 $Revision$';

@args = @ARGV;

# setpriority(0, $$, 19);

#Defaults
$prefix = "AIM-";
$usnick = "AIMServ";
$us = "aimserv.your.irc.net";
$them = "127.0.0.1";
$themport = 6667;
$ourpass = "foo";
$theirpass = "bar";
$servermode = "dal2";
$time = 60*5; #Five minutes
$user_loglevel = OSCAR_DBG_WARN;
@default_conffiles = ("/etc/aimirc.conf", "$home/.aimirc");
$fork = 1;
$verbose = 0;
$sendidle = 1;
$oscarserver = 'login.oscar.aol.com';
$oscarport = 5190;
$dcc = 1;
$shortcircuit = 1;
$numeric = num2base64(42);
$debug = 0;
*debuglevel = *debug;	#We can now reference debuglevels as %debuglevel or %debug

loadconf();

unless($reload) {
	if($fork) {
		#We don't need no stinking ampersands!
		my $pid = fork;
		exit if $pid;
		die "Couldn't fork: $!" unless defined($pid);

		POSIX::setsid() or die "Can't start a new session: $!";
	}
	sub kill_handler {
		my($connection);
		&going_down;
		$upstream->close;
		foreach $connection(values %$aim_connections) {
			$connection->{oscar}->signoff if $connection->{oscar};
		}
		exit 1;
	}
}

$SIG{INT} = $SIG{TERM} = \&kill_handler;
$SIG{CHLD} = 'IGNORE';

#Restart on SIGHUP
sub phoenix {
	my($connection, $screenname);
	&going_down;
	$upstream->close;
	foreach $connection(values %$aim_connections) {
		foreach $screenname(values %{$connection->{screennames}}) {
			$screenname->{oscar}->signoff if $screenname->{oscar};
		}
	}
	exec($0, @args);
}
$SIG{HUP} = \&rehash;


#Hello Mort!
sub REAPER {
	1 until (-1 == waitpid(-1, WNOHANG));
	$SIG{CHLD} = \&REAPER;
}
$SIG{CHLD} = \&REAPER;

$lasttime = $checktime = time;
$keepalive = 0;
mainloop();

sub loadconf() {
	my($errors, $foundconfig, $conffile, %temp, $server, $output);
	#First we check to see what config files to use.
	#Then we use the config files.
	#Then we process command-line options.
	#We do it this way so that command-line options can override config files, and
	#  you can still specify config files on the command-line.

	Getopt::Long::Configure("no_ignore_case");
	Getopt::Long::Configure("pass_through");


	$errors = &GetOptions(
		"version|V" => \&dispver,
		"license" => \&license,
		"config|C=s\@" => \@conffiles,
		"help|h" => \&help,
		"output=s" => \$output
	);

	@conffiles = @default_conffiles unless $conffiles[0];

	if(!$errors) {
		print STDERR "Try $0 --help if you need help.\n";
		exit 1;
	}

	if(defined $output) {
		close STDOUT;
		close STDERR;
		open(STDOUT, ">>$output") or die "Couldn't open STDOUT: $!\n";
		open(STDERR, ">>&STDOUT") or die "Couldn't open STDERR: $!\n";
		select STDOUT;
		$| = 1;
		select STDERR;
		$| = 1;
		select STDOUT;
	}

	#Okay, try loading the config files

	$foundconfig = 0;

	foreach $conffile(@conffiles) {
		$conffile =~ s/~/$home/;
		if(-r $conffile) {
			print STDERR "Reading config file $conffile\n" if $verbose;
			do $conffile;
			die $@ if $@;
			$foundconfig = 1;
		} else {
			print STDERR "Couldn't read config file $conffile\n" if $verbose;
		}
	}

	unless($foundconfig) {
		print STDERR "We couldn't find a config file.\n";
		print STDERR "You must edit aimirc.conf and copy it to either /etc/aimirc.conf or\n";
		print STDERR "   $home/.aimirc.  If you have already done this, make sure the aimirc\n";
		print STDERR "   user has permission to read it.\n";
		print STDERR "Or, perhaps you specified a config file with the --config (-C) option.\n";
		print STDERR "If you want to specify everything on the command-line and not use a config\n";
		print STDERR "   file (why?) then just give it a blank config file to make it happy.\n";
		exit 1;
	}

	#Now process additional command-line options

	Getopt::Long::Configure("no_pass_through");

	$errors = &GetOptions(
		"us=s" => \$us,
		"them=s" => \$them,
		"themport=i" => \$themport,
		"ourpass=s" => \$ourpass,
		"theirpass=s" => \$theirpass,
		"servermode=s" => \$servermode,
		"prefix=s" => \$prefix,
		"usnick=s" => \$usnick,
		"time=i" => \$time,
		"fork:i" => \$fork,
		"verbose|v" => \$verbose,
		"debug:i" => \$debug,
		"debuglevel=s\%" => \%debuglevel,
		"user_loglevel:i" => \$user_loglevel,
		"sendidle:i" => \$sendidle,
		"oscarserver=s" => \$oscarserver,
		"oscarport=i" => \$oscarport,
		"dccip=s" => \$dccip,
		"dcc:i" => \$dcc,
		"shortcircuit:i" => \$shortcircuit,
		"numeric=s" => \$numeric,
	);

	if(!$errors) {
		print STDERR "Try $0 --help if you need help.\n";
		exit 1;
	}

	%temp = %ircservers; #Preserve custom ircservers

	%ircservers = (
		dal2 => {
			nick => "NICK _NICK_ 1 _TIME_ _USER_ $us $us 0 :AOL Instant Messenger client via aimirc\r\n",
			server => "SERVER $us 1 :AOL Instant Messenger services\r\n",
			uspass => 1,
			theirpass => 1,
			nicklen => 30,
			pass => "PASS $ourpass :1\r\n",
		},
		dragonfire => {
			nick => "NICK _NICK_ 1 _TIME_ _USER_ $us $us :AOL Instant Messenger client via aimirc\r\n",
			server => "SERVER $us 1 :AOL Instant Messenger services\r\n",
			uspass => 1,
			theirpass => 1,
			nicklen => 10,
			pass => "PASS $ourpass :1\r\n"
		},
		ircu => {
			nick => "NICK _NICK_ 1 _TIME_ _USER_ $us +i :AOL Instant Messenger services\r\n",
			server => "SERVER $us 1 _TIME_ _TIME_ P09 :AIM Services\r\n",
			uspass => 1,
			theirpass => 1,
			nicklen => 9,
			pass => "PASS :$ourpass\r\n"
		},
		rfc => {
			nick => "NICK _NICK_ 1\r\n:_NICK_ USER _USER_ $us $us :AOL Instant Messenger client via aimirc\r\n",
			server => "SERVER $us 1 :AOL Instant Messenger serices\r\n",
			uspass => 1,
			theirpass => 1,
			nicklen => 9,
			pass => "PASS :$ourpass\r\n"
		},
		ts => {
			nick => "NICK _NICK_ 1 _TIME_ +i _USER_ $us $us :AOL Instant Messenger client via aimirc\r\n",
			server => "SERVER $us 1 :AOL Instant Messenger serices\r\nSVINFO 3 1 0 :_TIME_\r\n",
			uspass => 1,
			theirpass => 1,
			nicklen => 9,
			pass => "PASS $ourpass :TS\r\n",
		},
		unreal => {
			nick => "NICK _NICK_ 1 _TIME_ _USER_ $us $us 0 :AOL Instant Messenger client via aimirc\r\n",
			server => "SERVER $us 1 :AOL Instant Messenger services\r\n",
			uspass => 1,
			theirpass => 1,
			nicklen => 30,
			pass => "PASS :$ourpass\r\n",
		},
		p0210 => {
			nick => "NICK _NICK_ 1 +i _USER_ $us $us :AOL Instant Messenger client via aimirc\r\n",
			server => "SERVER $us 1 :AOL Instant Messenger services\r\n",
			uspass => 1,
			nicklen => 9,
			pass => "PASS $ourpass 0210030002 IRC\r\n",
		},
		p10 => {
			nick => "$numeric N _NICK_ 1 _TIME_ _USERNAME_ _HOST_ +i A ${numeric}_NUMERIC_ :AOL Instant Messenger client via aimirc\r\n",
			server => "SERVER $us 1 _TIME_ _TIME_ J10 ${numeric}]]] :AOL Instant Messenger services\r\n$numeric EB\r\n$numeric EA\r\n",
			uspass => 1,
			theirpass => 1,
			nicklen => 9,
			pass => "PASS :$ourpass\r\n",
		},
			
	);

	foreach $server(keys %temp) { #Preserve custom ircservers
		$ircservers{$server} = $temp{$server};
	}

	$usnick = new Net::OSCAR::Screenname $usnick;
}

sub mainloop() {
	my($connection, $screenname, $msg, $multinick, $i, $rv, $buff, $getrv, $rvbuff, $currtime, $nick, $sndata);
	my($rin, $win, $ein);
	$rin = $win = $ein = '';
	my $oscardbg = $user_loglevel;
	$oscardbg = $debuglevel{oscar} if $debug and $debuglevel{oscar} > $user_loglevel;

	$oscarprime = Net::OSCAR->new();
	$oscarprime->loglevel($oscardbg);
	$oscarprime->set_callback_error(\&oscar_error);
	$oscarprime->set_callback_rate_alert(\&oscar_rate_alert);
	$oscarprime->set_callback_admin_error(\&oscar_admin_error);
	$oscarprime->set_callback_admin_ok(\&oscar_admin_ok);
	$oscarprime->set_callback_chat_closed(\&oscar_chat_closed);
	$oscarprime->set_callback_buddy_in(\&oscar_buddy_in);
	$oscarprime->set_callback_chat_buddy_in(\&oscar_chat_buddy_in);
	$oscarprime->set_callback_buddy_out(\&oscar_buddy_out);
	$oscarprime->set_callback_chat_buddy_out(\&oscar_chat_buddy_out);
	$oscarprime->set_callback_im_in(\&oscar_im_in);
	$oscarprime->set_callback_chat_im_in(\&oscar_chat_im_in);
	$oscarprime->set_callback_chat_invite(\&oscar_chat_invite);
	$oscarprime->set_callback_chat_joined(\&oscar_chat_joined);
	$oscarprime->set_callback_evil(\&oscar_evil);
	$oscarprime->set_callback_buddy_info(\&oscar_buddy_info);
	$oscarprime->set_callback_signon_done(\&oscar_signon_done);
	$oscarprime->set_callback_log(\&oscar_log);
	$oscarprime->set_callback_buddylist_error(\&oscar_buddylist_error);
	$oscarprime->set_callback_buddylist_ok(\&oscar_buddylist_ok);

	unless($reload) {
		$chatseq = 0;
		$usercount = 0;
		$maxusers = 0;

		foreach my $hashref ($aim_connections, $irc_connections, $nicks, $irc_away, $away, $longnicks, $shortnicks) {
			$hashref = $oscarprime->buddyhash();
		}

		connect_to_irc();
		$aimircdebug = 0;

		irc_send(irc_newnick($usnick)) or die "Couldn't make aimserv: $!\n";
		irc_send(irc_mode($usnick, $usnick, "-i"));
		irc_send(irc_mode($usnick, $usnick, "+oa"));

		irc_send(irc_join($usnick, "#aimirc-debug"));
		irc_send(irc_mode($us, "#aimirc-debug", "+o $usnick"));
		irc_send(irc_mode($usnick, "#aimirc-debug", "+nsk $ourpass"));
		$aimircdebug = 1;
		$longnicks->{'#aimirc-debug'} = '#aimirc-debug';

		while(1 == 1) {
			exit(255) unless $upstream;
			$rin = $win = $ein = '';
			foreach $nick(keys %$aim_connections) {
				foreach $screenname(keys %{$aim_connections->{$nick}->{screennames}}) {
					if(!$aim_connections->{$nick}->{screennames}->{$screenname}->{oscar}) {
						delete $aim_connections->{$nick}->{screennames}->{$screenname};
						next;
					}
					my($readers, $writers) = $aim_connections->{$nick}->{screennames}->{$screenname}->{oscar}->selector_filenos();
					$rin |= $readers;
					$win |= $writers;
				}
			}

			vec($rin, $upstream->fileno, 1) = 1;
			foreach my $dcc(@dccqueue) {
				#debug_print("(vec'ing) dccqueue has DCC $dcc->{desc} from $dcc->{from} to $dcc->{to} (state=$dcc->{state}, fileno=".fileno($dcc->{socket}).")", "DCC", 3);
				if($dcc->{state} & DCC_STATE_WRITE) {
					vec($win, fileno($dcc->{socket}), 1) = 1;
				} else {
					vec($rin, fileno($dcc->{socket}), 1) = 1;
				}
			}
			#debug_print("rin=".ord($rin).", win=".ord($win), "DCC", 3);

			undef $currtime;
			#eval {
			#	local $SIG{ALRM} = sub { die "timeout\n" };
			#	alarm 5;
				$ein = $rin | $win;
				select($rin, $win, $ein, 5) or goto CLEANUP;
			#};
			#if ($@) {
			#	die unless $@ =~ /timeout/; # Why don't testing for eq "timeout\n" work ???
			#	goto CLEANUP; # Yeah, yeah, I read Dijkstra's paper too...
			#}

			local $SIG{ALRM} = sub { confess "aimirc got stuck?" };
			alarm 10;

			#debug_print("rin=".ord($rin).", win=".ord($win), "DCC", 3);

			debug_print("Processing OSCARs...", "irc", 2);

			foreach $nick(keys %$aim_connections) {
				foreach $screenname(keys %{$aim_connections->{$nick}->{screennames}}) {
					$aim_connections->{$nick}->{screennames}->{$screenname}->{oscar}->process_connections(\$rin, \$win, \$ein);
				}
			}

			debug_print("Processing IRC...", "irc", 2);
			process_irc_message(irc_recv()) if vec($rin, $upstream->fileno, 1);

			$currtime = time;
			for(my $i = scalar(@dccqueue) - 1; $i >= 0; $i--) {
				my $dcc = $dccqueue[$i];
				#debug_print("(proc'ing) dccqueue has DCC $dcc->{desc} from $dcc->{from} to $dcc->{to} (state=$dcc->{state}, fileno=".fileno($dcc->{socket}).")", "DCC", 3);

				if($currtime - $dcc->{time} > 3600) {
					irc_send(irc_privmsg($usnick, $dcc->{for}, "DCC connection timed out.", "", "", $dcc->{screenname}));
					close $dcc->{socket};
					splice(@dccqueue, $i, 1);
				}

				if($dcc->{state} & DCC_STATE_WRITE) {
					next unless vec($win, fileno($dcc->{socket}), 1);
				} else {
					next unless vec($rin, fileno($dcc->{socket}), 1);
				}

				splice(@dccqueue, $i, 1) unless process_dcc($dcc, $currtime);
			}

			CLEANUP:
			$currtime ||= time;
			foreach $nick(keys %$aim_connections) {
				next unless $nick;
				$connection = $aim_connections->{$nick};
				foreach $screenname(keys %{$connection->{screennames}}) {
					next unless $screenname;
					$sndata = $connection->{screennames}->{$screenname};
					next unless $sndata and ref $sndata eq "HASH" and defined $sndata->{signontime};
					next if $sndata->{ison};
					next if ($currtime - $sndata->{signontime}) <= 10;
					irc_send(irc_privmsg($usnick, $nick, "Your attempt to connect to AOL Instant Messenger has failed."));
					do_signoff($nick, $sndata->{oscar}, 1);
				}
			}

			#Do this loop about once every 100 seconds
			if((($currtime % 100) == 0) and ($currtime - $lasttime) >= 100) { #Cleanup nicks
				timestuff($currtime);
				$lasttime = $currtime;
			}

			alarm 0;
		}
	}
}

sub connect_to_irc() {
	my($flags, $in, $pass);

	$upstream = IO::Socket::INET->new(PeerAddr => "$them:$themport", Timeout => 5) or die "Couldn't connect to IRC server $them:$themport ($!)\n";

	set_blocking($upstream, 0);

	do { irc_send($ircservers{$servermode}{pass}) if $ourpass and $ircservers{$servermode}{uspass}; } or die "Couldn't send PASS: $!\n";
	irc_send(irc_subparms($ircservers{$servermode}{server})) or die "Couldn't send PASS: $!\n";

	$in = "...";

	if($theirpass and $ircservers{$servermode}{theirpass}) {
		while($in and ($in !~ /PASS :?(.+)/)) {
			$in = irc_recv();
			chomp $in;
			if($in =~ /^ERROR :(.+)/) {
				print STDERR "IRC connection error: $1\n";
				exit 1;
			} elsif($in =~ /^SERVER (\S+)/) {
				$themname = $1;
			}
		}

		$in =~ s/ :1// if $in;
		$in =~ s/ :TS// if $in;
		$in =~ /^PASS :?(.+)/ if $in;
		$pass = $1;
		$pass =~ s/\s*//g if $pass;	#Remove spaces from crypted password
		if($pass and $theirpass and ($pass ne $theirpass and $pass ne crypt($theirpass, substr($pass, 0, 2)))) { die("Upstream server gave the wrong password!\n"); }
	}
}

# Create a new IRCnick, with mangling and anti-collide
sub irc_newnick($) {
	my($nick, $user, $string, $shortnick) = shift;
	$nick =~ tr/ //d;
	$user = $nick;
	$user =~ s/^$prefix//;

	$nick = new Net::OSCAR::Screenname $nick;
	debug_print("Shall we create $nick?", "nicks", 2);
	return if haskeys($nicks->{noprefix($nick)});
	$shortnick = new Net::OSCAR::Screenname ircify($nick, 1);
	$nicks->{noprefix($nick)} = $oscarprime->buddyhash();
	$nicks->{noprefix($nick)}->{$usnick} = time;
	debug_print("\tCreating $nick (normalized ". normalize($nick) . ", shortnick $shortnick)", "nicks", 1);
	$longnicks->{$shortnick} = $nick;
	$shortnicks->{$nick} = $shortnick;
	$string = irc_subparms($ircservers{$servermode}{nick}, $user, $shortnick);
	$string .= ":$shortnick MODE $shortnick +i\r\n";
	return $string;
}

# Remove $prefix
sub noprefix($) {
	my $nick = shift;
	$nick =~ s/^$prefix//i;
	return $nick;
}

# Does the hashref have any keys?
sub haskeys($) {
	my $hashref = shift;
	return scalar keys %$hashref;
}

# Substitute parameters in %ircservers strings
sub irc_subparms($;$$) {
	my($input, $user, $nick, $time) = @_;
	$time = time;
	$input =~ s/_TIME_/$time/g;
	$input =~ s/_USER_/$user/g;
	$input =~ s/_NICK_/$nick/g;
	return $input;
}

# Format an IRC private message - you must still irc_send it!
sub irc_privmsg($$$;$$$) {
	my($from, $to, $msg, $prefix, $notice, $screenname, $line, $ret, $text, $maxlen, $temp) = @_;
	$prefix ||= "";

	return unless $from and $to and $msg;

	if($screenname and $from eq $usnick and exists($aim_connections->{$to}->{screennames}->{$screenname}) and $aim_connections->{$to}->{screennames}->{$screenname}->{inchan}) {
		$to = nickchan($screenname);
	} elsif($screenname and $aim_connections->{$to} and normalize($screenname) ne normalize($aim_connections->{$to}->{aimnick})) {
		$msg = "{$screenname} " . $msg;
	}

	if($from ne $usnick and not haskeys($nicks->{$from})) {
		irc_send(irc_newnick($from));
	}
	$from = ircify($from);


	$maxlen = 450 - length($from) - length($to);
	foreach $line(split(/[\r\n]+/, $msg)) {
		$text = "$prefix$line";
		while($text) {

			#IRC has a max cmd len of 512.
			#Split up messages which would exceed this length
			#Try to split up on word boundaries.

			if(length($text) > $maxlen) {
				$temp = substr($text, 0, $maxlen, "");
				$text = $1.$text if $temp =~ s/\s+(\S+)$//;
			} else {
				$temp = $text;
				$text = "";
			}
			$ret .= ":$from " . ($notice ? "NOTICE" : "PRIVMSG") . " $to :$temp\r\n";
		}
	}
	return $ret or $msg;
}

# Process an incoming IRC message
sub process_irc_message($) {
	my($screenname, $nick, $sndata, $oscar);

	$_ = shift;

	if(s/^:(\S+)(!\S+@\S+)?\s+//) {
		$nick = new Net::OSCAR::Screenname $1;
	} else {
		$nick = new Net::OSCAR::Screenname $themname;
	}
	if($aim_connections->{$nick}) {
		foreach my $tmpscreenname(keys %{$aim_connections->{$nick}->{screennames}}) {
			$sndata = $aim_connections->{$nick}->{screennames}->{$tmpscreenname};
			$sndata->{idletime} = time;
			if($sndata->{is_idle}) {
				$sndata->{is_idle} = 0;
				$sndata->{oscar}->set_idle(0);
			}
		}
		$oscar = $aim_connections->{$nick}->{oscar};
		$screenname = $aim_connections->{$nick}->{aimnick};
		$sndata = $aim_connections->{$nick}->{aimnick};
	}

	if(/^ERROR +:(.+)/) {
		print STDERR "IRC server error: $1\n";
		exit 1;
	} elsif(/^KILL +(\S+)/i) {
		delete $nicks->{noprefix $1};
	} elsif(/^VERSION/i) {
		irc_send(irc_error($nick, 351, "aimirc-$VERSION. $us :aimirc"));
	} elsif(!/#aimirc-debug/i and (/^JOIN +.?#aimirc-(\S+)/i or /^SJOIN +\d+ +#aimirc-(\S+?) +\S+ +:(\S+)/i)) {
		my $screenname = new Net::OSCAR::Screenname $1;
		$nick = $2 if $2;
		$nick =~ tr/\@+//d;
		$nick = new Net::OSCAR::Screenname $nick;
		$oscar = $aim_connections->{$nick}->{screennames}->{$screenname}->{oscar} if $aim_connections->{$nick} and $aim_connections->{$nick}->{screennames}->{$screenname};
		my $dude;

		#print STDERR "Got $nick joining $screenname ($_)\n";
		if(not defined $irc_connections->{$screenname} or $irc_connections->{$screenname} ne $nick) {
			#print STDERR "Doing bounce_join\n";
			bounce_join($nick, nickchan($screenname));
		} else {
			my $chan = nickchan($screenname);
			delete $chantimer{$chan};
			$aim_connections->{$nick}->{screennames}->{$screenname}->{inchan} = 1;
			irc_send(irc_join($usnick, $chan));
			irc_send(irc_mode($us, $chan, "+o $usnick"));
			irc_send(irc_mode($usnick, $chan, "-o $nick"));
			irc_send(irc_mode($usnick, $chan, "+ints"));
			foreach $dude(keys %$nicks) {
				next unless $nicks->{$dude}->{$screenname};
				irc_send(irc_join(ircify($prefix.$dude), $chan));
				irc_send(irc_mode($usnick, $chan, "+v $prefix$dude")) if $oscar->buddy($dude);
			}
			irc_send(irc_privmsg($usnick, $chan, "You can talk to people by saying somedude: hi (or ${prefix}somedude: hi).  This will automatically make IMs sent to you appear in this channel.  Having incoming IMs appear in this channel can also be set via the imchan command."));
		}
	} elsif(/^JOIN +.?#aimchat-(\d+)/i or /^SJOIN +\d+ +#aimchat-(\d+) +\S+ +:(\S+)/i) {
		my $chat = $1;
		$nick = $2 if $2;
		$nick =~ tr/\@+//d; #Only needed for Hybrid?
		$nick = new Net::OSCAR::Screenname $nick;
		$screenname = $aim_connections->{$nick}->{aimnick} if $aim_connections->{$nick};
		my @screennames = keys %{$aim_connections->{$nick}->{screennames}} if $aim_connections->{$nick};

		$screenname ||= "";
		if(not $chats{$chat} or !$screenname or not grep { normalize($_) eq normalize($chats{$chat}->{screenname}) } @screennames) {
			bounce_join($nick, chatchan($chat));
		} else {
			delete $chantimer{chatchan($chat)};
			$oscar = $aim_connections->{$nick}->{screennames}->{$chats{$chat}->{screenname}}->{oscar};
			$chats{chat}->{joined} = 1;
			if($chats{$chat}->{invited}) {
				$oscar->chat_accept($chats{$chat}->{url});
			} else {
				irc_send($chats{$chat}->{queue});
				delete $chats{$chat}->{queue};
			}
			irc_send(irc_mode($usnick, chatchan($chat), "+o $nick"));
		}
	} elsif(/^INVITE +(\S+) +:?#aimchat-(\d+)/i) {
		my $recipient = noprefix($1);
		my $chat = $2;
		my $topic = $chats{$chat}->{name};

		$topic =~ s/^{.+?} //;
		$chats{$chat}->{obj}->invite($recipient, "Please come to $topic.") if $chats{$chat}->{obj};
	} elsif(/^MODE +#aimchat-(\d+) +:?(.+)/i) {
		my $chat = $1;
		my $modes = $2;
		my ($mode, $parms, @matches, @modes, @params, @tparams, $params, $modestring, $modechar, $modeparm, $modetype, $status);

		irc_send(irc_error($nick, 504, "You cannot change modes in AIM chat channels.")) if $aim_connections->{$nick};

		$modes =~ tr/+-/-+/;
		$modes =~ s/\s*\d+[\r\n]*$// unless $aim_connections->{$nick};
		#debug_print("Modes: $modes", "errors", 3);
		@matches = $modes =~ m/([-+][a-zA-Z]+)\s*/g or debug_print("Mode parse failed.", "errors", 3);
		foreach $modestring(@matches) {
			#debug_print("Mode parse suceeded: $modestring", "errors", 3);
			$modetype = substr($modestring, 0, 1, "");
			#debug_print("modetype is $modetype", "errors", 3);
			MODE: while($modechar = substr($modestring, 0, 1, "")) {
				#debug_print("Got modechar $modechar", "errors", 3);
				if($modechar =~ /[vbokl]/) { #Mode takes a parm
					$modes =~ s/(?:\s|\A)([^-+]\S*)(?:\s|\Z)/ / or next MODE;
					$modeparm = $1;
					#debug_print("Mode takes parm, parm is $modeparm", "errors", 3);
				} else {
					$modeparm = "";
				}
				if($modechar eq "o" and $modeparm eq $usnick) {
					if($modetype eq "+") {
						irc_send(irc_mode(($servermode eq "ts") ? $us : $usnick, chatchan($chat), "+o $usnick"));
					}
				} elsif($modechar eq "o" and $aim_connections->{$modeparm} and $modetype eq "-") {
					#Do nothing
				} elsif(($modechar eq "t" or $modechar eq "s" or $modechar eq "n" or $modechar eq "i") and $modetype eq "-") {
					#Do nothing
				} else {
					#debug_print("Adding to \@modes: (char => $modechar, type => $modetype, parm => $modeparm)", "errors", 3);
					push @modes, { char => $modechar, type => $modetype, parm => $modeparm };
				}
			}
		}
		#foreach $mode(@modes) {
		#	debug_print("Got mode: " . $mode->{type} . $mode->{char} . " " . $mode->{parm}, "irc", 3);
		#}

		$modestring = "";
		$parms = "";
		foreach $mode(sort { $a->{type} cmp $b->{type} } @modes) {
			if($mode->{type} eq "-" and not $status & 1) { #We have a -, modestring doesn't
				$modestring .= "-";
				$status |= 1;
			} elsif($mode->{type} eq "+" and not $status & 2) { #We have a +, modestring doesn't
				$modestring .= "+";
				$status |= 2;
			}
			$modestring .= $mode->{char};
			$parms .= " $mode->{parm}" if $mode->{parm};
		}

		$modestring .= $parms;

		#debug_print("Mode parse final: $modestring", "errors", 3);

		irc_send(irc_mode($usnick, chatchan($chat), $modestring)) if $modestring;
	} elsif(/^TOPIC +#aimchat-(\d+)/i) {
		irc_send(irc_error($nick, 505, "Cannot change topic in AIM chat channels."));
		irc_send(irc_topic($usnick, chatchan($1), $chats{$1}->{name}));
	} elsif(/^KICK +#aimchat-(\d+) +(\S+)/i) {
		irc_send(irc_error($nick, 503, "Cannot kick users from AIM chat channels."));
		irc_send(irc_join($2, chatchan($1)));
		if($2 eq $usnick) {
			irc_send(irc_mode(($servermode eq "ts") ? $us : $usnick, chatchan($1), "+o $usnick"));
		}
	} elsif(/^PART +#aimchat-(\d+)/i) {
		my $chat = $1;
		if(exists $aim_connections->{$nick}->{screennames}->{$chats{$1}->{screenname}}) {
			debug_print("$nick left aimchat $1 (".$chats{$1}->{name}.").", "chat", 1);
			if($aim_connections->{$nick} and $chats{$1}->{name}) {
				$chats{$chat}->{obj}->part() if $chats{$chat}->{obj};
				irc_send(irc_part($usnick, chatchan($1)));
				foreach my $who(keys %{$chats{$1}->{members}}) {
					delete $chats{$1}->{members}->{$who};
					delete $nicks->{$who}->{"chat-$1"};
					irc_send(irc_part(ircify($prefix.$who), chatchan($1)));
				}
				delete $chats{$1};
			}
		}
	} elsif(!/#aimirc-debug/i and /^PART +#aimirc-(\S+)/i) {
		my $screenname = $1;
		my $dude;

		if(exists $aim_connections->{$nick}->{screennames}->{$screenname} and $aim_connections->{$nick}->{screennames}->{$screenname}->{inchan}) {
			$aim_connections->{$nick}->{screennames}->{$screenname}->{inchan} = 0;
			foreach $dude(keys %$nicks) {
				next unless $nicks->{$dude}->{$screenname};
				irc_send(irc_part(ircify($prefix.$dude), nickchan($screenname)));
			}
			irc_send(irc_part($usnick, nickchan($screenname)));
		}
	} elsif(!/#aimirc-debug/i and (/^(PRIVMSG|NOTICE) +$usnick(\@\S+)? +:?(.+)/i or /^(PRIVMSG|NOTICE) +#aimirc-(\S+) +:?(.+)/i)) {
		my($cmd, $param, $extra);

		$screenname = $sndata = "";
		$screenname = $2 if exists $aim_connections->{$nick}->{screennames}->{$2};
		$screenname ||= $aim_connections->{$nick}->{aimnick} if exists $aim_connections->{$nick};
		$screenname = new Net::OSCAR::Screenname $screenname if $screenname;

		my $msg = process_ctcp($nick, $usnick, $3, $screenname);
		return unless $msg;

		$cmd = undef; $extra = undef; $param = undef;
		$msg =~ /(\S+) ?(\S*)( ?.*)/ or $cmd = $msg;
		$cmd = $1 unless $cmd; $param = $2 if $2 or $2 eq "0"; $extra = substr($3, 1) || "" if $3;
		$cmd ||= $msg; #For cmds w/o param
		#warn "Cmd: $cmd\nParam: $param: Extra: $extra\n\n";
		$nick = lc($nick);
		$param ||= "";

		debug_print("Received IRC command $cmd from '$screenname'", "irc", 2) if $screenname;

		if($aim_connections->{$nick}) {
			my $connection = $aim_connections->{$nick} if exists $aim_connections->{$nick} and ref $aim_connections->{$nick};
			$sndata = $connection->{screennames}->{$screenname} if $connection;
			$oscar = $sndata->{oscar} if $sndata;

			# Let the user talk to buddies in #aimirc-screenname
			# This triggers inchan==2 mode
			if($cmd =~ /(?:$prefix)?(.+?)\x02?:\x02?/ and $sndata->{inchan}) {
				my $recipient = $1;
				$sndata->{inchan} = 2 unless $sndata->{inchan} == 3;
				$msg =~ s/.*?:\x02? //;
				send_im($oscar, $recipient, $msg);
				return;
			}
		}

		unless($screenname or ($cmd eq "stats") or ($cmd eq "signon") or ($cmd eq "help")) {
			irc_send(irc_privmsg($usnick, $nick, "You must use the signon command to sign on to AOL Instant Messenger before using this service."));
		} elsif($cmd eq "stats") {
			if($param eq "users" and $msg =~ /users $ourpass/) {
				irc_send(irc_privmsg($usnick, $nick, "$usercount users (max $maxusers): " . join(", " , keys %$irc_connections)));
			} elsif($param eq "users") {
				irc_send(irc_privmsg($usnick, $nick, "$usercount users (max $maxusers)"));
			} elsif($param eq "uptime") {
				my($days, $hours, $minutes, $seconds);
				$seconds = time - $starttime;
				$minutes = int($seconds / 60);
				$seconds -= $minutes*60;
				$hours = int($minutes / 60);
				$minutes -= $hours*60;
				$days = int($hours / 24);
				$hours -= $days*24;
				irc_send(irc_privmsg($usnick, $nick, sprintf("Up $days day(s), %02d:%02d:%02d", $hours, $minutes, $seconds)));
			}
		} elsif($cmd eq "signon") {
			unless($param and $extra) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: signon [--loglevel loglevel] screenname password"));
			} else {
				if($aim_connections->{$nick}->{scrennames}->{$param}) {
					irc_send(irc_privmsg($usnick, $nick, "You are already signed onto AOL instant messenger under that screenname."));
				} else {
					irc_send(irc_privmsg($usnick, $nick, "Signing on to AOL Instant Messenger..."));

					local @ARGV = split(/\s+/, "$param $extra");
					my $loglevel = $user_loglevel;
					my $errors = &GetOptions(
						"loglevel|l|d=i" => \$loglevel
					);

					if(!$errors) {
						irc_send(irc_privmsg($usnick, $nick, "Invalid signon command - '/msg $usnick signon' for usage."));
					} else {
						my $params = {loglevel => $loglevel};
						my $cmdline = "$param $extra";
						$cmdline =~ s/-+(loglevel|l|d)\s+\d+\s+//;
						my($screenname, $password) = split(/\s+/, $cmdline, 2);
						do_signon($screenname, $password, $nick, $params);
					}
				}
			}
		} elsif ($cmd eq "buddylist") {
			my(%groups, $buddy, $group, $xbuddy, $evil, $line, $buddat);
			my $buddies = 0;

			foreach $group($oscar->groups) {
				irc_send(irc_privmsg($usnick, $nick, "$group:", "", "", $screenname));
				foreach $buddy($oscar->buddies($group)) {
					$buddat = $oscar->buddy($buddy, $group);
					$evil = $buddat->{evil};
					$line = "\t$buddy";
					$line .= " {$buddat->{comment}}" if $buddat->{comment};
					$line .= " (POUNCE)" if exists $buddat->{data}->{0x0200};
					$line .= " [online]" if $buddat->{online};
					$line .= " [away]" if $buddat->{online} and $buddat->{away};
					$line .= " [warning level $evil%]" if $evil;
					irc_send(irc_privmsg($usnick, $nick, $line, "", "", $screenname));
					$buddies++;
				}
			}
			irc_send(irc_privmsg($usnick, $nick, "Your buddylist is empty.", "", "", $screenname)) unless $buddies;
		} elsif ($cmd eq "onbuddies") {
			my(%groups, $buddy, $group, $xbuddy, $line, $evil, $buddat);
			my $onbuddies = 0;

			foreach $group($oscar->groups) {
				my $showedgroup = 0;
				foreach $buddy($oscar->buddies($group)) {
					irc_send(irc_privmsg($usnick, $nick, "$group:", "", "", $screenname)) unless $showedgroup++;
					$buddat = $oscar->buddy($buddy, $group);
					$evil = $buddat->{evil};
					$line = "\t$buddy";
					next unless $buddat->{online};
					$line .= " {$buddat->{comment}}" if $buddat->{comment};
					$line .= " (POUNCE)" if exists $buddat->{data}->{0x0200};
					$line .= " [away]" if $buddat->{online} and $buddat->{away};
					$line .= " [warning level $evil%]" if $evil;
					irc_send(irc_privmsg($usnick, $nick, $line, "", "", $screenname));
					$onbuddies++;
				}
			}

			irc_send(irc_privmsg($usnick, $nick, "None of your buddies are online.", "", "", $screenname)) unless $onbuddies;
		} elsif ($cmd eq "permitlist") {
			my @permitlist = $oscar->get_permitlist();
			if(@permitlist) {
				irc_send(irc_privmsg($usnick, $nick, join(" ", sort @permitlist), "", "", $screenname));
			} else {
				irc_send(irc_privmsg($usnick, $nick, "Your permit list is empty.", "", "", $screenname));
			}
		} elsif ($cmd eq "denylist") {
			my @denylist = $oscar->get_denylist();
			if(@denylist) {
				irc_send(irc_privmsg($usnick, $nick, join(" ", sort @denylist), "", "", $screenname));
			} else {
				irc_send(irc_privmsg($usnick, $nick, "Your deny list is empty.", "", "", $screenname));
			}
		} elsif ($cmd eq "signoff") {
			do_signoff($nick, $oscar);
		} elsif ($cmd eq "buddyinfo") {
			unless($param) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: buddyinfo screenname", "", "", $screenname));
			} else {
				my $buddyconf = $oscar->buddy($param);
				if($buddyconf->{online}) {
					local $^W = 0;
					my $msg = "Buddy Info for $buddyconf->{screenname}\r\n";
					$msg .= "Group: \t".$oscar->findbuddy($param)."\r\n";
					$msg .= "Signon Time: \t" . localtime($buddyconf->{onsince}) . "\r\n";
					$msg .= "Idle Time: \t".(sprintf "%.1f", $buddyconf->{idle}/60)." minutes\r\n";
					$msg .= "Comment: \t$buddyconf->{comment}\r\n" if $buddyconf->{comment};

					$msg .= "User Class: \t";
					$msg .= " TRIAL" if $buddyconf->{trial};
					$msg .= " AOL" if $buddyconf->{aol};
					$msg .= " AIM" if $buddyconf->{free};
					$msg .= " ADMIN" if $buddyconf->{admin};
					$msg .= " AWAY" if $buddyconf->{away};
					$msg .= "\r\n";

					$msg .= "Warning Level: \t$buddyconf->{evil}%\r\n";
					irc_send(irc_privmsg($usnick, $nick, $msg, "", "", $screenname));
				} else {
					irc_send(irc_privmsg($usnick, $nick,  "That person is either not on your buddy list or not signed on.", "", "", $screenname));
				}
			}
		} elsif ($cmd eq "rename_group") {
			unless($param and $extra) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: rename_group oldgroup newgroup", "", "", $screenname));
			} else {
				$oscar->rename_group($param, $extra);
				$oscar->commit_buddylist;
			}
		} elsif ($cmd eq "add_buddy") {
			unless($param) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: add_buddy screenname [group]", "", "", $screenname));
			} else {
				my $group = $extra || "Buddies";
				my %rembuds = ();
				my @buddies = split(/,\s*/, $param);
				$oscar->add_buddy($group, @buddies);
				$oscar->commit_buddylist;
			}
		} elsif ($cmd eq "remove_buddy") {
			unless($param) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: remove_buddy screenname", "", "", $screenname));
			} else {
				my @buddies = split(/,\s*/, $param);
				map { irc_send(irc_part("$prefix" . normalize $_, "#aimirc-$screenname", "Removed from buddylist.")) if delete $nicks->{normalize $_}->{$screenname} and $sndata->{inchan} } @buddies;
				my %rembuds = ();
				foreach my $buddy(@buddies) {
					my $currgroup = $oscar->findbuddy($buddy);
					push @{$rembuds{$currgroup}}, $buddy;
				}
				foreach my $remgroup(keys %rembuds) {
					$oscar->remove_buddy($remgroup, @{$rembuds{$remgroup}});
				}
				$oscar->commit_buddylist;
			}
		} elsif ($cmd eq "evil" or $cmd eq "warn") {
			unless($param) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: $cmd screenname [anon]", "", "", $screenname));
			} else {
				$param = lc($param);
				if($extra ne "anon") {
					$extra = 0;
				} else {
					$extra = 1;
				}
				$oscar->evil($param, $extra);
			}
		} elsif ($cmd eq "add_permit") {
			unless($param) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: add_permit screenname", "", "", $screenname));
			} else {
				my @buddies = split(/,\s*/, $param);
				$oscar->add_permit(@buddies);
				$oscar->commit_buddylist;
			}
		} elsif ($cmd eq "add_deny") {
			unless($param) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: add_deny screenname", "", "", $screenname));
			} else {
				my @buddies = split(/,\s*/, $param);
				$oscar->add_deny(@buddies);
				$oscar->commit_buddylist;
			}
		} elsif ($cmd eq "remove_deny") {
			unless($param) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: remove_deny screenname", "", "", $screenname));
			} else {
				my @buddies = split(/,\s*/, $param);
				$oscar->remove_deny(@buddies);
				$oscar->commit_buddylist;
			}
		} elsif ($cmd eq "remove_permit") {
			unless($param) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: remove_permit screenname", "", "", $screenname));
			} else {
				my @buddies = split(/,\s*/, $param);
				$oscar->remove_permit(@buddies);
				$oscar->commit_buddylist;
			}
		} elsif ($cmd eq "join") {
			unless($param) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: join chat_name", "", "", $screenname));
			} else {
				$param = "$param $extra" if $extra;
				$oscar->chat_join($param);
			}
		} elsif ($cmd eq "join_exchange") {
			unless($param and $extra) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: join_exchange exchange chat_name", "", "", $screenname));
			} else {
				$oscar->chat_join($extra, $param);
			}
		} elsif ($cmd eq "get_permit_mode") {
			irc_send(irc_privmsg($usnick, $nick, "Your permit mode is " . $oscar->visibility . ".", "", "", $screenname));
		} elsif ($cmd eq "set_permit_mode") {
			unless($param) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: set_permit_mode newmode", "", "", $screenname));
			} else {
				if($param != 1 and $param != 2 and $param != 3 and $param != 4 and $param != 5) {
					irc_send(irc_privmsg($usnick, $nick, "That is not a valid permit mode.  See list_permit_modes for valid permit modes.", "", "", $screenname));
				} else {
					$oscar->set_visibility($param);
					$oscar->commit_buddylist;
				}
			}
		} elsif ($cmd eq "list_permit_modes") {
			irc_send(irc_privmsg($usnick, $nick, "1=Permit All, 2=Deny All, 3=Permit if and only if on permitlist, 4=Deny if and only if on denylist, 5=Permit if and only if on buddylist", "", "", $screenname));
		} elsif ($cmd eq "info" or $cmd eq "get_info" or $cmd eq "get_profile") {
			unless($param) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: info screenname", "", "", $screenname));
			} else {
				$oscar->get_info($param);
			}
		} elsif ($cmd eq "set_info" or $cmd eq "set_profile") {
			my $text;
			unless($param) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: $cmd info", "", "", $screenname));
			} else {
				$extra ? ($text = "$param $extra") : ($text = $param);
				$oscar->set_info($text);
				$oscar->commit_buddylist;
			}
		} elsif ($cmd eq "get_dir") {
			#unless($param) {
			#	irc_send(irc_privmsg($usnick, $nick, "Usage: get_dir screenname", "", "", $screenname));
			#} else {
			#	get_directory($sndata->{socket}, $param);
			#}
			irc_send(irc_privmsg($usnick, $nick, "Not implemented.", "", "", $screenname));
		} elsif ($cmd eq "set_dir") {
			irc_send(irc_privmsg($usnick, $nick, "Not implemented.", "", "", $screenname));
			#$param = "$param $extra" if $extra;
			#if($param and $param ne "set_dir") {
			#	@temp = split(/:/, $param);
			#		%temp = (
			#		first_name => shift @temp,
			#		middle_name => shift @temp,
			#		last_name => shift @temp,
			#		maiden_name => shift @temp,
			#		city => shift @temp,
			#		state => shift @temp,
			#		country => shift @temp,
			#		allow_web_searches => shift @temp
			#	);
			#	set_directory($sndata->{socket}, %temp);
			#} else {
			#	irc_send(irc_privmsg($usnick, $nick, "first name:middle name:last name:maiden name:city:state:country:websearch.  Don't put any colons in any of these.  If you put anything in the websearch field, people can find your directory info using web searches.", "", "", $screenname));
			#}
		} elsif ($cmd eq "dir_search") {
			irc_send(irc_privmsg($usnick, $nick, "Not implemented.", "", "", $screenname));
			#$param = "$param $extra" if $extra;
			#if($param and $param ne "dir_search") {
			#	@temp = split(/:/, $param);
			#	%temp = (
			#		first_name => shift @temp,
			#		middle_name => shift @temp,
			#		last_name => shift @temp,
			#		maiden_name => shift @temp,
			#		city => shift @temp,
			#		state => shift @temp,
			#		country => shift @temp,
			#		allow_web_searches => shift @temp
			#	);
			#	directory_search($sndata->{socket}, %temp);
			#} else {
			#	irc_send(irc_privmsg($usnick, $nick, "first name:middle name:last name:maiden name:city:state:country:websearch.  Don't put any colons in any of these.  If you put anything in the websearch field, people can find your directory info using web searches.", "", "", $screenname));
			#}
		} elsif ($cmd eq "add") {
			unless($param) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: add screenname", "", "", $screenname));
			} else {
				$param = noprefix($param);
				unless($nicks->{$param}) {
					irc_send(irc_newnick($prefix . $param));
				}
				manglewarn($nick, $prefix.$param);
				$nicks->{$param}->{$screenname} = time;	
				irc_send(irc_privmsg($usnick, $nick, "$param has been created on IRC.", "", "", $screenname));
				irc_send(irc_join($prefix.$param, nickchan($screenname))) if $sndata->{inchan};
			}
		} elsif ($cmd eq "sendidle") {
			unless($param == 0 or $param == 1) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: sendidle (0|1)", "", "", $screenname));
			} else {
				$sndata->{report_idle} = $param;
				irc_send(irc_privmsg($usnick, $nick, "Idle reporting changed.", "", "", $screenname));
			}
		} elsif ($cmd eq "format_nickname" or $cmd eq "format_screenname") {
			unless($param) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: $cmd screenname", "", "", $screenname));
			} else {
				$param .= " $extra" if $extra;
				$oscar->format_screenname($param);
			}
		} elsif ($cmd eq "change_password") {
			unless($param and $extra) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: change_password old_password new_password", "", "", $screenname));
			} else {
				$oscar->change_password($param, $extra);
			}
		} elsif ($cmd eq "change_email") {
			unless($param) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: change_email new_email"));
			} else {
				$oscar->change_email($param);
			}
		} elsif ($cmd eq "confirm_account") {
			$oscar->confirm_account();
		} elsif ($cmd eq "loadbuddies") {
			$dccget{$nick} = $screenname;
			irc_send(irc_ctcp($usnick, $nick, "loadbuddies"));
			irc_send(irc_privmsg($usnick, $nick, "Please DCC SEND $usnick your buddylist.", "", "", $screenname));
		} elsif ($cmd eq "savebuddies") {
			my $fmtoscar = 1;
			my($config, $message, $group, $buddy, %groups, $filename);

			unless($dccip) {
				irc_send(irc_privmsg($usnick, $nick, "savebuddies is not available on this server - the administrator has not specified a DCC IP in the aimirc configuration file.", "", "", $screenname));
			} else {
				$fmtoscar = 0 if $param and lc($param) eq "toc";

				if($fmtoscar) {
					$config =
"Config {
 version 1
}
User {
 screenName $screenname\n";
					if($oscar->profile) {
						$config .= " profile {\n  mimeType \"text/aolrtf; charset=\\\"us-ascii\\\"\"\n";
						$config .= "  dataLength ".length($oscar->profile)."\n";
						my $mimeprofile = encode_base64($oscar->profile, "");
						while($mimeprofile) {
							$config .= "  dataBlob ".substr($mimeprofile, 0, 64, "")."\n";
						}
						$config .= " }\n";
					}
					$config .= "}\nBuddy {\n list {\n";

					foreach $group (sort $oscar->groups) {
						$config .= "  $group {\n";
						foreach $buddy(sort $oscar->buddies($group)) {
							$config .= "   \"$buddy\"";
							if(my $comment = $oscar->buddy($buddy, $group)->{comment}) {
								$config .= " {\n    BuddyNote {\n     NoteString $comment\n    }\n   }";
							}
							$config .= "\n";
						}
						$config .= "  }\n";
					}
					$config .= " }\n}\nPrivacy {\n";
					$config .= " allowList " . join(" ", $oscar->get_permitlist) . "\n";
					$config .= " blockList " . join(" ", $oscar->get_denylist) . "\n";
					$config .= " pref ";
					if($oscar->visibility == 1) {
						$config .= "AllowAll";
					} elsif($oscar->visibility == 2) {
						$config .= "DenyAll";
					} elsif($oscar->visibility == 3) {
						$config .= "AllowSome";
					} elsif($oscar->visibility == 4) {
						$config .= "DenySome";
					} elsif($oscar->visibility == 5) {
						$config .= "AllowBuddies";
					}
					$config .= "\n}\n";
					$filename = "$screenname.blt";
				} else {
					$config = "m ".0+$oscar->visibility()."\n";
					foreach $group(sort $oscar->groups) {
						$config .= "g $group\n";
						foreach $buddy(sort $oscar->buddies($group)) {
							$config .= "b $buddy\n";
						}
					}
					foreach $buddy(sort $oscar->get_permitlist) {
						$config .= "p $buddy\n";
					}
					foreach $buddy(sort $oscar->get_denylist) {
						$config .= "d $buddy\n";
					}
					$filename = "$screenname.txt";
				}

				$message = irc_dcc($usnick, $nick, $config, "savebuddies", $filename, $screenname);
				if($message) {
					irc_send($message);
					irc_send(irc_ctcp($usnick, $nick, "savebuddies"));
					irc_send(irc_privmsg($usnick, $nick, "Please accept the DCC SEND from $usnick.  The file being sent is your buddylist.", "", "", $screenname));
				}
			}
		} elsif ($cmd eq "add_pounce") {
			unless($param and $extra) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: add_pounce buddy text", "", "", $screenname));
			} else {
				my $group = $oscar->findbuddy($param);
				if(!defined($group)) {
					irc_send(irc_privmsg($usnick, $nick, "You may only add pounces for people on your buddylist.", "", "", $screenname));
				} else {
					$oscar->get_app_data($group, $param)->{0x0200} = $extra;
					$oscar->commit_buddylist;
				}
			}
		} elsif ($cmd eq "remove_pounce") {
			unless(defined $param) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: remove_pounce buddy", "", "", $screenname));
				return;
			} else {
				my $group = $oscar->findbuddy($param);
				if(!defined($group)) {
					irc_send(irc_privmsg($usnick, $nick, "You may only remove pounces for people on your buddylist.", "", "", $screenname));
				} else {
					delete $oscar->get_app_data($group, $param)->{0x0200};
					$oscar->commit_buddylist;
				}
			}
		} elsif ($cmd eq "show_pounce") {
			unless(defined $param) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: remove_pounce buddy", "", "", $screenname));
				return;
			} else {
				my $group = $oscar->findbuddy($param);
				if(!defined($param)) {
					irc_send(irc_privmsg($usnick, $nick, "You may only show pounces for people on your buddylist.", "", "", $screenname));
				} else {
					my $pounce = $oscar->get_app_data($group, $param)->{0x0200};
					if($pounce) {
						irc_send(irc_privmsg($usnick, $nick, $pounce, "", "", $screenname));
					} else {
						irc_send(irc_privmsg($usnick, $nick, "You do not have a pounce for that person.", "", "", $screenname));
					}
				}
			}
		} elsif ($cmd eq "help") {
			my $foo = ":$usnick PRIVMSG $nick";
			$foo = ":$usnick PRIVMSG #aimirc-$screenname" if $sndata->{inchan};
			if($param eq "basics") {
				irc_send("$foo :help - Show this screen.\r\n", 1);
				irc_send("$foo :signon [--loglevel loglevel] screenname pass - Sign on to AOL Instant Messenger (AIM).  You must do this before any of the other commands.\r\n", 1);
				irc_send("$foo :  loglevel should be a number between ".OSCAR_DBG_NONE." and ".OSCAR_DBG_PACKETS.".  Higher numbers give you more information.\r\n", 1);
				irc_send("$foo :signoff - Sign off of AIM.\r\n", 1);
				irc_send("$foo :add screenname - Create an IRC nickname for screenname.  Use this to talk to someone who's not on your buddylist.\r\n", 1);
				irc_send("$foo :get_permit_mode - See your current permit mode.\r\n", 1);
				irc_send("$foo :set_permit_mode newmode - Set your permit mode.\r\n", 1);
				irc_send("$foo :list_permit_modes - List the valid permit modes and their definitions.\r\n", 1);
			} elsif($param eq "buddies") {
				irc_send("$foo :NOTE: For the commands that take screenname[,screenname2,...screennameN] as a parameter, you must have only commas between the screennames.\r\n", 1);
				irc_send("$foo :You may NOT have spaces between the screennames!\r\n", 1);
				irc_send("$foo : \r\n", 1);
				irc_send("$foo :add_permit screenname[,screenname2,...,screennameN] - Add screenname (possibly multiple screenname) to your permit list, removing from deny list.\r\n", 1);
				irc_send("$foo :add_deny screenname[,screenname2,...,screennameN] - Add nick (possibly multiple screenname) to your deny list, removing from permit list.\r\n", 1);
				irc_send("$foo :buddyinfo screenname - Get signon time, idle time, evil level, and user class for a buddy.\r\n", 1);
				irc_send("$foo :rename_group oldgroup newgroup - Rename a group\r\n", 1);
				irc_send("$foo :add_buddy screenname[,screenname2,...,screennameN] [group] - Add screenname (possibly multiple screennames) to your buddy list.  If you give a group, the screenname will be added to that buddy group.\r\n", 1);
				irc_send("$foo :remove_buddy screenname[,screenname2,...,screennameN] - Remove screenname (possibly multiple screennames) from your buddy list.\r\n", 1);
				irc_send("$foo :warn screenname [anon] - Warn screenname, optionally anonymously.\r\n", 1);
				irc_send("$foo :remove_permit screenname[,screenname2,...,screennameN] - Remove screenname (possibly multiple screennames) from permit list.\r\n", 1);
				irc_send("$foo :remove_deny screenname[,screenname2,...,screennameN] - Remove screenname (possibly multiple screennames) from deny list.\r\n", 1);
				irc_send("$foo :onbuddies - List buddies who are currently signed on (and who don't have you on block.)\r\n", 1);
				irc_send("$foo :buddylist - List everyone on your buddylist.\r\n", 1);
				irc_send("$foo :permitlist - See who is on your permit list.\r\n", 1);
				irc_send("$foo :denylist - See who is on your deny list.\r\n", 1);
				irc_send("$foo :savebuddies [TOC] - DCC SENDs you a copy of your buddylist.  By default it will be in \"OSCAR format\" - use the TOC parameter for \"TOC format\".\r\n", 1) if $dccip;
				irc_send("$foo :loadbuddies - DCC GETs a copy of your buddylist and uses that as your new buddylist.  You must do this before sending the file.\r\n", 1);
				irc_send("$foo :reorder_groups group1, group2, ... - Changes the order of the groups in your buddylist.\r\n", 1);
				irc_send("$foo :reorder_groups group buddy1, buddy2, ... - Changes the order of the buddies in a group on your buddylist.\r\n", 1);
				irc_send("$foo :set_buddy_comment buddy comment - Associate a brief comment with a buddy.  This can be something like the buddy's real name.\r\n", 1);
				irc_send("$foo : \r\n", 1);
				irc_send("$foo :Note on savebuddies\\loadbuddies: savebuddies will send you a CTCP savebuddies (loadbuddies sends CTCP loadbuddies.\r\n", 1);
				irc_send("$foo :This allows IRC client scripts to be written to automate the sending and receiving of the file.\r\n", 1);
				irc_send("$foo :There are two buddylist formats which savebuddies and loadbuddies understand.\r\n", 1);
				irc_send("$foo :The preferred format, TOC format, is used internally by TOC and most TOC clients will export in this format.\r\n", 1);
				irc_send("$foo :OSCAR format is the format that the Windows AOL Instant Messenger client exports its buddylist in.\r\n", 1);
			} elsif($param eq "chat") {
				irc_send("$foo :join chat_name - Create/join a chatroom called chat_name.\r\n", 1);
				irc_send("$foo :join_exchange exchange chat_name - Create/join a chatroom in a different exchange (see below.)\r\n", 1);
				#I don't think AOL has implemented this. --MS
				#irc_send("$foo :chat_evil chat_id nick [anon] (or chat_warn chat_id nick [anon]) - Warn nick inside chat_id, optionally anonymously.\r\n", 1);
				irc_send("$foo : \r\n", 1);
				irc_send("$foo :Note on join_exchange: The default exchange is 4.  However, many AIM chats (including most/all listed in AOL's 'Hot Chats' use exchange 5.\r\n", 1);
				irc_send("$foo : \r\n", 1);
				irc_send("$foo :To invite someone into a chat, use the IRC INVITE command on their AIM- screenname.\r\n", 1);
				irc_send("$foo :Example: /invite AIM-SomeDude #aimchat-1234\r\n", 1);
				irc_send("$foo :Your IRC client might have an easier way to do that - many allow you to omit the channel name when inviting into the channel you are currently in.\r\n", 1);
			} elsif($param eq "misc") {
				irc_send("$foo :loglevel newlevel - Sets the logging level for your connection.  newlevel should be a number between ".OSCAR_DBG_NONE." and ".OSCAR_DBG_PACKETS.".  Higher numbers give you more information.\r\n", 1);
				irc_send("$foo :get_profile screenname - Get profile for screenname.\r\n", 1);
				irc_send("$foo :set_profile new profile - Set your profile.  You can use some HTML formating.\r\n", 1);
				irc_send("$foo :get_dir screenname - Get directory info for screenname.\r\n", 1);
				irc_send("$foo :set_dir [info] - Without info, gives you the syntax that info must be in.  With info, sets your directory info.\r\n", 1);
				irc_send("$foo :dir_search [info] - Without info, gets the syntax that info must be in (the same as that of set_dir).  With info, searches the AOL Instant Messenger directory.\r\n", 1);
				irc_send("$foo :sendidle (0|1) - Send the TOC server your idle information?\r\n", 1);
				irc_send("$foo :format_screenname screenname - Change the formatting (capitalization, spaces) of your screenname\r\n", 1);
				irc_send("$foo :change_email new_email - Change the email address assigned to your AIM account\r\n", 1);
				irc_send("$foo :confirm_account - Use this if your account has trial status\r\n", 1);
				irc_send("$foo :imchan (on|off) - If set to on, incoming IMs for your screenname will appear in #aimirc-YourScreenName\r\n", 1);
			} elsif($param eq "debug") {
				if($debug) {
					irc_send("$foo :restart - Restart aimirc.  This will close the IRC connection and all AIM connections and launch a new aimirc process.\r\n", 1);
					irc_send("$foo :newnick nick - Create a new nickname on irc.\r\n", 1);
					irc_send("$foo :setlevel debug_channel level - Set debugging channel debug_channel to level (higher is more verbose, 1 to disable).  The special channel \"all\" will set the level of all channels at once.\r\n", 1);
					irc_send("$foo :showlevels - List all debugging channels and their levels.\r\n", 1);
					irc_send("$foo :rehash - Reload /etc/aimirc.conf and $home/.aimirc .\r\n", 1);
					irc_send("$foo :reload - Evaluates $0.  This should let you make almost any change to Toc.pm or aimirc without having to do a full restart.\r\n", 1);
					irc_send("$foo :raw who text - Send a raw IRC or AIM command (AIM commands are SFLAP-encoded but not quoted.) If who is irc, it will be sent as an IRC command.  If who is the IRC nickname or AIM nickname of someone connected to this aimirc server, text will be sent over that AIM connection.\r\n", 1);
					irc_send("$foo :inject text - Act as though we got text from the IRC server.\r\n", 1);
					irc_send("$foo :eval text - Evaluate text as Perl code.  All exceptions will be trapped and displayed.\r\n", 1);
					irc_send("$foo :show text - Evaluate text as Perl code and display its output in the channel.  All exceptions will be trapped and displayed.\r\n", 1);
				} else {
					irc_send("$foo :Debugging support is not enabled.  Edit /etc/aimirc.conf or $home/.aimirc and send SIGHUP to PID $$.\r\n", 1);
				}
			} elsif($param eq "multinick") {
				irc_send("$foo :To sign on multiple AIM screennames under your current IRC connection, just use multiple signon commands.\r\n", 1);
				irc_send("$foo :The first screenname you sign on will be the \"default screenname\".\r\n", 1);
				irc_send("$foo :The default screenname is the screenname which outgoing IMs are sent to and which $usnick commands; such as add_buddy, remove_buddy, and signoff; effect.\r\n", 1);
				irc_send("$foo :Note that messages/whispers to chatrooms will always be sent with the screenname that joined the chatroom.\r\n", 1);
				irc_send("$foo :When you receive an incoming IM on a screenname other than the default one, {screenname} will be prepended to the IM.\t\n", 1);
				irc_send("$foo :multinick commands:\r\n", 1);
				irc_send("$foo :\tlistnames - list screennames that you are signed on as.  Also tells you your default screenname.\r\n", 1);
				irc_send("$foo :\tswitchname screenname - switch to a new default screenname\r\n", 1);
				irc_send("$foo :\tsignoffall - sign off all screennames\r\n", 1);
			#} elsif($param eq "introduction") {
			#	irc_send("$foo :
			} elsif($param eq "pounce") {
				irc_send("$foo :A pounce will automatically send an IM to a buddy when that buddy comes online.\r\n", 1);
				irc_send("$foo :Your pounces will be saved when you sign off but cannot trigger unless you are signed on.\r\n", 1);
				irc_send("$foo :When you sign on, you will be reminded if you have any untriggered pounces.\r\n", 1);
				irc_send("$foo :Each pounce is deleted after it is triggered, so it only will happen once.\r\n", 1);
				irc_send("$foo :You can have one pounce per buddy, and you can only hae pounces for people on your buddylist.\r\n", 1);
				irc_send("$foo :If you delete a buddy, its pounce goes with it.", 1);
				irc_send("$foo :\r\n", 1);
				irc_send("$foo :Pounce commands:\r\n", 1);
				irc_send("$foo :\tadd_pounce buddy text - Pounce on screenname with a message of text.\r\n", 1);
				irc_send("$foo :\tremove_pounce buddy - Remove pounce on buddy.\r\n", 1);
				irc_send("$foo :\tshow_pounce buddy - Shows the text of a pounce.\r\n", 1);
			} else {
				irc_send("$foo :aimirc $version, (c)1999-2001 Matthew Sachs.\r\n", 1);
				irc_send("$foo :aimirc homepage: http://www.zevils.com/programs/aimirc/\r\n", 1);
				irc_send("$foo :This program is licensed under Version 2 the GNU Public License.\r\n", 1);
				irc_send("$foo :A copy of the license is available at http://www.gnu.org/copyleft/gpl.txt\r\n", 1);
				irc_send("$foo :To see the commands available for a specific topic, use the command help topic.  The following topics are available:\r\n", 1);
				irc_send("$foo :\tbasics - basic commands\r\n", 1);
			 	irc_send("$foo :\tbuddies - buddylist manipulation, etc.\r\n", 1);
				irc_send("$foo :\tchat - chatroom commands\r\n", 1);
				irc_send("$foo :\tmisc - miscellaneous commands\r\n", 1);
				irc_send("$foo :\tmultinick - using aimirc with multiple AIM screennames from one IRC connection.\r\n", 1);
				irc_send("$foo :\tpounce - pounce commands and overview\r\n", 1);
				#irc_send("$foo :\tintroduction - introduction to aimirc and AOL Instant Messenger.\r\n", 1);
				irc_send("$foo :NOTE: Remove all spaces from screennames (also referred to as nicknames or nicks) before using in any AIMIRC command or operation.  nick is the AIM nick, not the IRC one created by prepending $prefix.\r\n", 1);
				irc_send("$foo :AIM stands for AOL Instant Messenger, which is a trademark of America Online, Inc.\r\n", 1);
				irc_send("$foo :To send an IM to someone whose screenname is SomeDude, send an IRC message to ${prefix}SomeDude.\r\n", 1);
				irc_send("$foo :That person must be on your buddylist, have sent you an IM recently, or be added to IRC via the add command.\r\n", 1);
				irc_send("$foo : \r\n", 1);
				irc_send("$foo :You need an AOL Instant Messenger account to use aimirc.  Get one at http://aim.aol.com/aimnew/Aim/register.adp\r\n", 1);
			}
		} elsif($cmd eq "switchname") {
			unless($param) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: switchname screenname", "", "", $screenname));
			} else {
				if(switchnick($nick, $param)) {
					irc_send(irc_privmsg($usnick, $nick, "You are not signed on under that screenname!", "", "", $screenname));
				} else {
					irc_send(irc_privmsg($usnick, $nick, "Your default screenname is now $param.", "", "", $param));
				}
			}
		} elsif($cmd eq "signoffall") {
			do_signoff_all($nick);
		} elsif($cmd eq "listnames") {
			irc_send(irc_privmsg($usnick, $nick, "Your default screenname is " . $sndata->{formatted} . ".", "", "", $screenname));
			foreach my $tmpscreenname(keys %{$aim_connections->{$nick}->{screennames}}) {
				irc_send(irc_privmsg($usnick, $nick, $aim_connections->{$nick}->{screennames}->{$screenname}->{oscar}->screenname, "", "", $screenname));
			}
		} elsif($cmd eq "imchan") {
			if($sndata->{inchan}) {
				if($param and $param ne "0" and $param ne "off" and $param ne "false" and $param ne "no" and $param ne "stop") {
					irc_send(irc_privmsg($usnick, $nick, "Incoming IMs for this screenname will now appear in this channel.", "", "", $screenname));
					$sndata->{inchan} = 2;
				} else {
					irc_send(irc_privmsg($usnick, $nick, "Incoming IMs for this screenname will no longer appear in this channel, even if you send someone an IM through this channel.", "", "", $screenname));
					$sndata->{inchan} = 3;
				}
			} else {
				irc_send(irc_privmsg($usnick, $nick, "You must join ".normalize("#aimirc-$screenname")." to use this feature.", "", "", $screenname));
			}
		} elsif($cmd eq "reorder_groups") {
			if(!$param) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: reorder_groups group1, group2, group3, ...", "", "", $screenname));
			} else {
				$oscar->reorder_groups($param, split(/(?:,|\s)\s*/, $extra));
				$oscar->commit_buddylist;
			}
		} elsif($cmd eq "reorder_buddies") {
			if(!$param and !$extra) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: reorder_buddies group buddy1, buddy2, buddy3, ...", "", "", $screenname));
			} else {
				$oscar->reorder_buddies($param, split(/(?:,|\s)\s*/, $extra));
				$oscar->commit_buddylist;
			}
		} elsif($cmd eq "set_buddy_comment") {
			if(!$param and !$extra) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: set_buddy_comment buddy comment", "", "", $screenname));
			} else {
				my $group = $oscar->findbuddy($param);
				if($group) {
					$oscar->set_buddy_comment($group, $param, $extra);
					$oscar->commit_buddylist;
				} else {
					irc_send(irc_privmsg($usnick, $nick, "Couldn't find that buddy.", "", "", $screenname));
				}
			}
		} elsif($cmd eq "loglevel") {
			if(!$param) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: loglevel newlevel", "", "", $screenname));
			} else {
				$oscar->loglevel($param);
				$sndata->{loglevel} = $param;
			}
		} elsif($cmd eq "decline") {
			if(!$param) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: decline chat", "", "", $screenname));
			} else {
				$param =~ /(\d+)/;
				$oscar->chat_decline($chats{$1}->{url});
				delete $chats{$1};
			}
		} else {
			irc_send(irc_privmsg($usnick, $nick, "Unknown command - /msg $usnick help for help.", "", "", $screenname));
		}
	} elsif(/^PRIVMSG +(\S+)(\@\S+)? +:?(.+)/i) { #$nick sent $3 to $1 (where $1 ne $usnick)
		$screenname = $aim_connections->{$nick}->{aimnick};

		my $target = noprefix($longnicks->{$1}); my $msg = $3;
		my $recipient = $1;
		$msg = process_ctcp($nick, $1, $msg, $screenname);
		return unless $msg;

		if($recipient eq "#aimirc-debug" and $debug) {
			$msg =~ s/^(aimserv)\S*\s+//;
			if($msg eq "restart" and $1) {
				phoenix;
			} elsif($msg =~ /^newnick (.+)/ and $1) {
				irc_send(irc_newnick($1));
			} elsif($msg =~ /^setlevel (\S+) (\S+)/) {
				if($1 eq "all") {
					foreach my $level(keys %debug) { $debug{$level} = $2; }
				} else {
					$debug{$1} = $2;
				}
			} elsif($msg =~ /^rehash/) {
				&rehash;
			} elsif($msg =~ /^reload/) {
				&reload;
			} elsif($msg =~ /^showlevels/) {
				foreach my $level(keys %debug) { irc_send(irc_privmsg($usnick, "#aimirc-debug", "$level: $debug{$level}")); }
			} elsif($msg =~ /^inject (.+)/ and $1) {
				process_irc_message($1);
			} elsif($msg =~ /^raw (\S+) (.+)/ and $1 and $2) {
				if($1 eq "irc") {
					irc_send("$2\r\n");
				} else {
					irc_send(irc_privmsg($usnick, "#aimirc-debug", "Sorry, only raw irc is supported."));
				}
			} elsif($msg =~ /^eval (.+)/ and $1) {
				eval $1;
				irc_send(irc_privmsg($usnick, "#aimirc-debug", $@, "EVAL: "));
			} elsif($msg =~ /^show (.+)/ and $1) {
				eval "irc_send(irc_privmsg(\$usnick, \"#aimirc-debug\", $1));";
				irc_send(irc_privmsg($usnick, "#aimirc-debug", $@, "EVAL: "));
			} elsif($msg =~ /#/) {
				# Do nothing
			} else {
				irc_send(irc_privmsg($usnick, "#aimirc-debug", "Invalid debug command - /msg aimserv help debug for help)"));
			}
		} elsif ($recipient =~ /^#aimchat-(\d+)$/) {
			
			if($chats{$1} and $chats{$1}->{obj}) {
				$chats{$1}->{obj}->chat_send($msg); 
			} else {
				bounce_join($nick, chatchan($1));
			}
		} elsif ($recipient !~ /^#/) {
			if($aim_connections->{$nick} and $oscar) {
				send_im($oscar, $target, $msg);
			} else {
				irc_send(irc_privmsg($usnick, $nick, "You must be signed onto AOL Instant Messenger via aimirc to send messages to AIM users.  /msg AIMServ help for details."));
			}
		}
	} elsif(/^AWAY *(.*)/) {
		if($1 =~ /:?(.*)/) {
			$irc_away->{$nick} = $1;
			if($aim_connections->{$nick}) {
				$aim_connections->{$nick}->{away} = $1;
				foreach $screenname(keys %{$aim_connections->{$nick}->{screennames}}) {
					$aim_connections->{$nick}->{screennames}->{$screenname}->{oscar}->set_away($1);
				}
			}
		} else {
			delete $irc_away->{$nick};
			if($aim_connections->{$nick}) {
				delete $aim_connections->{$nick}->{away};
				foreach $screenname(keys %{$aim_connections->{$nick}->{screennames}}) {
					delete $aim_connections->{$nick}->{screennames}->{$screenname}->{away_buddies};
					$aim_connections->{$nick}->{screennames}->{$screenname}->{oscar}->set_away();
				}
			}
		}
	} elsif(/^NICK +(\S+)/) { #Nick change
		my $newnick = "";
		if($aim_connections->{$nick}) {
			$newnick = new Net::OSCAR::Screenname $1;
			foreach $screenname(keys %{$aim_connections->{$nick}->{screennames}}) {
				$irc_connections->{$screenname} = $newnick;
			}
			$aim_connections->{$newnick} = $aim_connections->{$nick};
			$aim_connections->{$newnick}->{nick} = $newnick;
			delete $aim_connections->{$nick};

			my($dcc, $i);
			for($i = 0; $i <= $#dccqueue; $i++) {
				$dcc = $dccqueue[$i];
				$dcc->{for} = $newnick;
				if($dcc->{state} & DCC_STATE_SEND and $dcc->{to} eq $nick) {
					$dccqueue[$i]->{to} = $newnick;
				} elsif($dcc->{from} eq $nick) {
					$dccqueue[$i]->{from} = $newnick;
				}
			}
		}
	} elsif(/^QUIT/) {
		delete $irc_away->{$nick};

		my($dcc, $i);
		for($i = $#dccqueue; $i >= 0; $i--) {
			$dcc = $dccqueue[$i];
			next unless $dcc->{for} eq $nick;
			debug_print("Closing DCC socket for transfer to $nick", "DCC", 1);
			close $dcc->{socket};
			splice(@dccqueue, $i, 1);
		}
		do_signoff_all($nick) if $aim_connections->{$nick};
	} elsif(/^PING/) {
		irc_send(irc_pong());
	}
}

sub callback_vars($) {
	my $oscar = shift;
	my $screenname = $oscar->screenname;
	my $nick = $irc_connections->{$screenname};
	my $sndata = $aim_connections->{$nick}->{screennames}->{$screenname} if exists($aim_connections->{$nick}) and exists($aim_connections->{$nick}->{screennames});
	return($screenname, $nick, $sndata);
}

sub oscar_error($$$$$) {
	my($oscar, undef, $errno, $desc, $fatal) = @_;
	my($screenname, $nick, $sndata) = callback_vars($oscar);

	debug_print("Got oscar_error $errno: $desc ($fatal)", "irc", 2);
	irc_send(irc_privmsg($usnick, $nick, "Error $errno: $desc", "", "", $screenname));
	do_signoff($nick, $oscar, 1) if $fatal;
}

sub oscar_rate_alert($$$$) {
	my($oscar, $level, $clear, $window) = @_;
	my($screenname, $nick, $sndata) = callback_vars($oscar);

	irc_send(irc_privmsg($usnick, $nick, "You're sending too fast!  Slow down!  We've been given a $level warning.", "", "", $screenname));
	$clear = int($clear / 1000);
	irc_send(irc_privmsg($usnick, $nick, "Wait $clear seconds before sending anything.", "", "", $screenname));
}

sub oscar_admin_error($$$$) {
	my($oscar, $reqtype, $error, $url) = @_;
	my($screenname, $nick, $sndata) = callback_vars($oscar);

	irc_send(irc_privmsg($usnick, $nick, "Your $reqtype request has failed: $error.", "", "", $screenname));
	irc_send(irc_privmsg($usnick, $nick, "See $url for more information.", "", "", $screenname)) if $url;
}

sub oscar_admin_ok($$) {
	my($oscar, $reqtype) = @_;
	my($screenname, $nick, $sndata) = callback_vars($oscar);

	irc_send(irc_privmsg($usnick, $nick, "Your $reqtype request has succeeded.", "", "", $screenname));
}

sub oscar_chat_closed($$$) {
	my($oscar, $chat, $error) = @_;
	my($screenname, $nick, $sndata) = callback_vars($oscar);
	my $chatid = $chat->{chat_id};

	irc_send(irc_privmsg($usnick, $nick, "Your connection to chat ".$chat->name." was closed: $error", "", "", $screenname));
	irc_send(irc_kick($usnick, chatchan($chatid), $nick, $error));
	foreach my $who(keys %{$chats{$chatid}->{members}}) {
		irc_send(irc_part(ircify($prefix.$who), chatchan($chatid)));
	}
	delete $chats{$chatid};
}

sub oscar_buddy_in($$$$) {
	my($oscar, $buddy, $group, $buddat) = @_;
	my($screenname, $nick, $sndata) = callback_vars($oscar);

	irc_send(irc_newnick($prefix . $buddy));
	my $inick = ircify($prefix.$buddy);
	unless($nicks->{$buddy}->{$screenname} and $nicks->{$buddy}->{$screenname} == -1) {
		$nicks->{$buddy}->{$screenname} = -1;
		manglewarn($nick, $inick);
		if($sndata->{inchan}) {
			irc_send(irc_join($inick, nickchan($screenname)));
			irc_send(irc_mode($usnick, nickchan($screenname), "+v $inick"));
		} else {
			irc_send(irc_privmsg($usnick, $nick, "$buddy has arrived", "", "", $screenname));
		}

		if(exists $buddat->{data}->{0x0200}) {
			my($pounce) = $buddat->{data}->{0x0200};
			my $tmp = "";
			if($buddat->{aol}) {
				$tmp = "[automated pounce] ";
			}
			$tmp .= $pounce;
			$oscar->send_im($buddy, $tmp, 1);
			delete $buddat->{data}->{0x0200};
			$oscar->commit_buddylist;
			irc_send(irc_privmsg($usnick, $nick, "Pounce to $buddy has been sent.", "", "", $screenname));
		}
	}

	if($buddat->{away}) {
		if(!$sndata->{away}->{$buddy}) {
			irc_send(irc_privmsg($usnick, $nick, "$buddy has gone away.  Use the IRC command /whois $inick to see the away message.", "", "", $screenname));
			$sndata->{away}->{$buddy} = 1;
		}
		$oscar->get_away($buddy) unless $away->{$buddy};
		$away->{$buddy} = 1;
	} else {
		if($sndata->{away}->{$buddy}) {
			delete $sndata->{away}->{$buddy};
			irc_send(irc_privmsg($usnick, $nick, "$buddy is no longer away.", "", "", $screenname));
		}
		irc_send(":$inick AWAY\r\n") if delete $away->{$buddy};
	}
}

sub oscar_chat_buddy_in($$$$) {
	my($oscar, $buddy, $chat, $buddat) = @_;
	my($screenname, $nick, $sndata) = callback_vars($oscar);
	return if $buddy eq $screenname;
	my($chatid) = grep {
		$chats{$_}->{url} eq $chat->url
		   and
		$chats{$_}->{screenname} eq $oscar->screenname
	} keys %chats;

	if(!$chatid) {
		die "Couldn't find chat.  Dump of \%chats: ",
		   Data::Dumper::Dumper(\%chats),
		   "\n.  Dump of \$chat: ",
		   Data::Dumper::Dumper($chat),
		   "\n.  Dump of \$oscar: ",
		   Data::Dumper::Dumper($oscar), "\n";
	}

	irc_send(irc_newnick($prefix.$buddy));
	my $inick = ircify($prefix.$buddy);
	manglewarn($nick, $inick) unless $nicks->{$buddy}->{$screenname};
	irc_send(irc_join($inick, chatchan($chatid)));
	$nicks->{$buddy}->{"chat-$chatid"} = -1;
}

sub oscar_buddy_out($$$) {
	my($oscar, $buddy, $group) = @_;
	my($screenname, $nick, $sndata) = callback_vars($oscar);

	delete $away->{$buddy};
	my $inick = ircify($prefix.$buddy);
	if($sndata->{inchan}) {
		irc_send(irc_part($inick, nickchan($screenname)));
	} else {
		irc_send(irc_privmsg($usnick, $nick, "$buddy has departed"));
	}
	delete $nicks->{$buddy}->{$screenname};
	unless(haskeys($nicks->{$buddy})) {
		irc_send(irc_quit($inick, "Nobody wants me anymore."));
		delete $nicks->{$buddy};
	}
}

sub oscar_chat_buddy_out($$$) {
	my($oscar, $buddy, $chat) = @_;
	my($screenname, $nick, $sndata) = callback_vars($oscar);

	my $inick = ircify($prefix.$buddy);
	my $chatid = $chat->{chat_id};
	irc_send(irc_part($inick, chatchan($chatid)));
	delete $nicks->{$buddy}->{"chat-$chatid"};
	unless(haskeys($nicks->{$buddy})) {
		irc_send(irc_quit($inick, "Nobody wants me anymore."));
		delete $nicks->{$buddy};
	}
}

sub oscar_im_in($$$$) {
	my($oscar, $from, $msg, $away) = @_;
	my($screenname, $nick, $sndata) = callback_vars($oscar);

	my $inick = ircify($prefix.$from);
	my $notice = 0;
	my $ar = "";

	$notice = 1 if $msg =~ /<!-- NOTICE -->/;

	irc_send(irc_newnick($prefix.$from));
	unless($nicks->{$inick}->{$screenname}) {
		manglewarn($nick, $inick);
		$nicks->{$inick}->{$screenname} = time;
		irc_send(irc_join($inick, nickchan($screenname))) if $sndata->{inchan};
	}

	$ar = "[automatic response] " if $away;
	$msg = $ar . join("\n", html2txt($msg, $nick));
	
	my $recipient = $nick;
	$recipient = nickchan($screenname) if $sndata->{inchan} == 2;
	irc_send(irc_privmsg($inick, $recipient, $msg, "", $notice, $screenname));

	if(!$away and $irc_away->{$nick} and (time - $sndata->{away_buddies}->{$from} > $time)) {
		my $tmp = "";
		my $buddat = $oscar->buddy($from);
		$tmp = "[automated reply] " if $buddat and $buddat->{aol};
		$tmp .= $irc_away->{$nick};
		$oscar->send_im($from, $tmp, 1);
		$sndata->{away_buddies}->{$from} = time;
	}
	$nicks->{$from}->{$screenname} = time if $nicks->{$from}->{$screenname} and $nicks->{$from}->{$screenname} != -1;
}

sub oscar_chat_im_in($$$$) {
	my($oscar, $from, $chat, $msg) = @_;
	my($screenname, $nick, $sndata) = callback_vars($oscar);

	my $inick = ircify($prefix.$from);
	my $chatid = $chat->{chat_id};
	if(normalize($from) ne normalize($screenname)) {
		$msg = join("\n", html2txt($msg, $nick));
		unless($chats{$chatid}->{joined}) {
			$chats{$chatid}->{queue} .= irc_privmsg($inick, chatchan($chatid), $msg);
		} else {
			irc_send(irc_privmsg($inick, chatchan($chatid), $msg));
		}
	}
}

sub oscar_chat_invite($$$$$) {
	my($oscar, $from, $msg, $chat, $chaturl) = @_;
	my($screenname, $nick, $sndata) = callback_vars($oscar);

	my $chatid = ++$chatseq;
	$chats{$chatid} = {
		screenname => $screenname,
		url => $chaturl,
		name => $chat,
		invited => 1,
		joined => 0,
		queue => ""
	};
	my $chan = chatchan($chatid);
	irc_send(irc_privmsg($usnick, $nick, "$from has invited us to chatroom $chat for the following reason: " .  html2txt($msg) . "To accept, join $chan.  To decline, send $usnick the command 'decline $chatid'.", "", "", $screenname));
	irc_send(irc_join($usnick, $chan));
	irc_send(irc_mode($us, $chan, "+o $usnick"));
	irc_send(irc_mode($usnick, $chan, "+ints"));
	irc_send(irc_invite($usnick, $chan, $nick));
}

sub oscar_chat_joined($$$) {
	my($oscar, $chatname, $chat) = @_;
	my($screenname, $nick, $sndata) = callback_vars($oscar);

	my($chatid) = grep { $chats{$_}->{url} eq $chat->url and $chats{$_}->{screenname} eq $oscar->screenname} keys %chats;
	$chatid ||= ++$chatseq;

	$chat->{chat_id} = $chatid;
	$chats{$chatid}->{screenname} = $screenname;
	$chats{$chatid}->{url} = $chat->url;
	$chats{$chatid}->{name} = $chat->name;
	$chats{$chatid}->{joined} = 1;
	$chats{$chatid}->{queue} = "";
	$chats{$chatid}->{obj} = $chat;
	$chats{$chatid}->{members} = $oscar->buddyhash();
	$chats{$chatid}->{joined} = 1;

	my $chan = chatchan($chatid);
	if(!$chats{$chatid}->{invited}) {
		irc_send(irc_join($usnick, $chan));
		irc_send(irc_mode($us, $chan, "+o $usnick"));
		irc_send(irc_mode($usnick, $chan, "+sint"));
		irc_send(irc_topic($usnick, $chan, "{$screenname} ".$chat->name));
		irc_send(irc_privmsg($usnick, $nick, "Join IRC channel $chan to join AIM chat ".$chats{$chatid}->{name}.".", "", "", $screenname));
		irc_send(irc_invite($usnick, $chan, $nick));
	}
	$longnicks->{$chan} = $chan;
}

sub oscar_evil($$$) {
	my($oscar, $evil, $from) = @_;
	my($screenname, $nick, $sndata) = callback_vars($oscar);

	$from ||= "Anonymous";
	irc_send(irc_privmsg($usnick, $nick, "$from has warned you.  Your new warn level is $evil%.", "", "", $screenname));
}

sub oscar_buddy_info($$$) {
	my($oscar, $buddy, $buddat) = @_;
	my($screenname, $nick, $sndata) = callback_vars($oscar);

	if($buddat->{awaymsg}) {
		$away->{$buddy} = $buddat->{awaymsg};
		my $awaymsg = html2txt($buddat->{awaymsg});
		$awaymsg =~ tr/\r\n/  /;
		irc_send(":".ircify($prefix.$buddy)." AWAY :$awaymsg\r\n");
	} else {
		local $^W = 0;
		my $msg = "Info for $buddat->{screenname}\r\n";
		$msg .= "Signon Time: \t" . localtime($buddat->{onsince}) . "\r\n";
		$msg .= "Idle Time: \t".(sprintf "%.1f", $buddat->{idle}/60)." minutes\r\n";

		$msg .= "User Class: \t";
		$msg .= " TRIAL" if $buddat->{trial};
		$msg .= " AOL" if $buddat->{aol};
		$msg .= " AIM" if $buddat->{free};
		$msg .= " ADMIN" if $buddat->{admin};
		$msg .= " AWAY" if $buddat->{away};
		$msg .= "\r\n";

		$msg .= "Warning Level: $buddat->{evil}%\r\n";
		if($buddat->{profile}) {
			$msg .= "---------------------\r\n";
			$msg .= "Profile\r\n";
			$msg .= "---------------------\r\n";
			$msg .= join("\r\n", html2txt($buddat->{profile}, $nick));
		}
		irc_send(irc_privmsg($usnick, $nick, $msg, "", "", $screenname));
	}
}

sub oscar_signon_done($) {
	my($oscar) = @_;
	my($screenname, $nick, $sndata) = callback_vars($oscar);

	$usercount++;
	$maxusers = $usercount if $usercount > $maxusers;

	irc_send(irc_privmsg($usnick, $nick, "You are now connected to AOL Instant Messenger as $screenname.", "", "", $screenname));
	irc_send(irc_privmsg($usnick, $nick, "The email address registered to this account is ".$oscar->email.".  Use the change_email command if this is not your current email address.", "", "", $screenname));

	my $chan = nickchan($screenname);
	irc_send(irc_privmsg($usnick, $nick, "You might want to join $chan.", "", "", $screenname));
	irc_send(irc_join($usnick, $chan));
	irc_send(irc_mode($us, $chan, "+o $usnick"));
	irc_send(irc_part($usnick, $chan));

	$sndata->{ison} = 1;
	if($irc_away->{$nick}) {
		$oscar->set_away($irc_away->{$nick});
	}

	my $pouncecount = 0;
	foreach my $group($oscar->groups) {
		foreach my $buddy($oscar->buddies($group)) {
			my $buddat = $oscar->get_app_data($group, $buddy);
			$pouncecount++ if $buddat and exists($buddat->{0x0200});
		}
	}
	irc_send(irc_privmsg($usnick, $nick, "You have $pouncecount pounce" . ($pouncecount > 1 ? "s" : "") . ".", "", "", $screenname)) if $pouncecount > 0;

	if($oscar->profile) {
		irc_send(irc_privmsg($usnick, $nick, "You profile has been set.", "", "", $screenname));
	}
}

sub oscar_buddylist_error($$$) {
	my($oscar, $error, $what) = @_;
	my($screenname, $nick, $sndata) = callback_vars($oscar);

	irc_send(irc_privmsg($usnick, $nick, "Error $error occured while trying to $what on your buddylist.", "", "", $screenname));
}

sub oscar_buddylist_ok($) {
	my($oscar) = @_;
	my($screenname, $nick, $sndata) = callback_vars($oscar);

	irc_send(irc_privmsg($usnick, $nick, "Your buddylist was successfully modified.", "", "", $screenname));
}

sub oscar_log($$$) {
	my($oscar, $level, $msg) = @_;
	my($screenname, $nick, $sndata) = callback_vars($oscar);

	debug_print($msg, "oscar", 1) if $debug and $level <= $debuglevel{oscar};
	irc_send(irc_privmsg($usnick, $nick, $msg, "", "", $screenname)) if $level <= $sndata->{loglevel};
}

sub debug_print($$$) {
	my($text, $type, $level) = @_;
	my($line, @lines);

	return if $text =~ m!401 $usnick #aimirc-debug :No such nick/channel!i;
	return unless $debug;
	return if defined($debug{$type}) and $level > $debug{$type};

	if($aimircdebug and $debug < 2) {
		@lines = split(/[\r\n]+/, $text);

		foreach $line(@lines) {
			irc_send(":$usnick PRIVMSG #aimirc-debug :($type, $level) $line\r\n", 1);
		}
	} else {
		chomp $text;
		print STDERR "$text\n";
	}
}

# Convert HTML into text suitable for IRC
sub html2txt($;$) {
	my ($msg, $nick, $parsetree, @lines, $formatter) = @_;
	my($linkct, $link, $elem, $node) = 0;

	$parsetree = HTML::TreeBuilder->new;
	$parsetree->{_ignore_unknown} = 0;
	$parsetree->parse($msg);
	$parsetree->eof;

	$formatter = new HTML::FormatAIMIRC (leftmargin => 0, rightmargin => 4096);
	$formatter->{_original_html} = $msg; #We use this to determine whether to add a closing tag for "unknown tags"
	$msg = $formatter->format($parsetree);
	$parsetree->delete;
	return $msg;
}

# Send something to IRC
sub irc_send($;$) {
	my ($msg, $flags, $nodbg, $rv) = @_;

	return unless $msg;

	$flags ||= 0;
	$nodbg = 1 if $flags & 1;

	debug_print("To IRC  : $msg", "irc", 2) unless $nodbg;
	undef $rv;
	$! = EAGAIN;
	while(!defined($rv) && $! == EAGAIN) {
		$rv = $upstream->syswrite($msg, length $msg);
		if(defined $rv and $rv != length $msg) {
			substr($msg, 0, $rv) = "";
			undef $rv;
			$! = EAGAIN;
		} elsif(!defined($rv)) {
			die "Couldn't write to IRC: $!";
		}
	}
	return 1;
}

# Dereference a hashref
sub deref($) {
	my $href = shift;
	return %$href if ref $href eq "HASH";
	return ();
}

# Reload the configuration file
sub rehash() {
	irc_send(irc_privmsg($usnick, "#aimirc-debug", "Rehashing..."));
	if(-r "/etc/aimirc.conf") {
		do "/etc/aimirc.conf";
		$@ =~ tr/\r//d;
		irc_send(irc_privmsg($usnick, "#aimirc-debug", $@, "EVAL: "));
		if($@) {
			irc_send(irc_privmsg($usnick, "#aimirc-debug", "Couldn't reload /etc/aimirc.conf - there were errors."));
		} else {
			irc_send(irc_privmsg($usnick, "#aimirc-debug", "Reloaded /etc/aimirc.conf"))
		}
	} else {
		irc_send(irc_privmsg($usnick, "#aimirc-debug", "Not loading /etc/aimirc.conf - couldn't read"));
	}
	if(-r "$home/.aimirc") {
		do "$home/.aimirc" if -r "$home/.aimirc";
		irc_send(irc_privmsg($usnick, "#aimirc-debug", $@, "EVAL: "));
		if($@) {
			irc_send(irc_privmsg($usnick, "#aimirc-debug", "Couldn't reload $home/.aimirc - there were errors."));
		} else {
			irc_send(irc_privmsg($usnick, "#aimirc-debug", "Reloaded $home/.aimirc"))
		}
	} else {
		irc_send(irc_privmsg($usnick, "#aimirc-debug", "Not loading $home/.aimirc - couldn't read"));
	}
	irc_send(irc_privmsg($usnick, "#aimirc-debug", "Rehash complete!"));
}

# Re-eval aimirc
sub reload() {
	irc_send(irc_privmsg($usnick, "#aimirc-debug", "Reloading $0..."));
	$reload = 1;
	local $SIG{__DIE__} = sub { $@ = shift; };
	do $0;
	irc_send(irc_privmsg($usnick, "#aimirc-debug", $@, "EVAL: "));
	if($@) {
		irc_send(irc_privmsg($usnick, "#aimirc-debug", "Couldn't reload $0 - there were errors."));
	} else {
		irc_send(irc_privmsg($usnick, "#aimirc-debug", "Reload complete!"));
	}
}

# Display version information
sub dispver() {
	print "aimirc: IRC <-> AOL Instant Messenger gateway.\n";
	print "AOL Instant Messenger, AOL, and America Online are trademarks of America Online, Inc.\n";
	print "Version: $VERSION\n";
	print "Use $0 --help for command-line options.\n";
	print "Use $0 --license to see the license (GPL v2)\n";
	exit 0;
}

# Dispaly licensing info
sub license() { print $license; exit 0; }

# Display commandline help
sub help() {
	print <<EOF
aimirc - IRC <-> AOL Instant Messenger gateway
AOL Instant Messenger, AOL, and America Online are trademarks of America Online, Inc.
Version $VERSION

Usage: $0 [--version] [--license] [--help] [--config conffile] [--config conffile] ...

You can use either the short or long forms with one or two dashes in
whatever combination you want.  However, you can't combine options as in
$0 -VC.

	--version, -V:			Display version information and exit

	--license:			Display license information and exit

	--help, -h:			Print this message and exit

	--config, -C:			Specify configuration files to use.
					This option overrides the default
					configuration file locations.
					You may specify this option multiple
					times to use multiple configuration
					files.

This is also an option for every directive in the configuration file.
The options have the same names as the directives, but prefix them with
two dashes (--) instead of the Perl variable type identifies (\$\@\%).

See the included README file for more information.
EOF
;
	exit 0;
}

# Sign on to AIM
sub do_signon($$$$) {
	my($screenname, $password, $nick, $params) = @_;

	my $connection = $aim_connections->{$nick};
	$connection->{screennames} = $oscarprime->buddyhash() unless tied(%{$connection->{screennames}});
	my $oscar = $oscarprime->clone();
	$oscar->loglevel($params->{loglevel});
	$oscar->signon($screenname, $password, $oscarserver, $oscarport);

	$screenname = new Net::OSCAR::Screenname $screenname;
	$aim_connections->{$nick}->{nick} = $nick;
	$connection->{screennames}->{$screenname}->{oscar} = $oscar;
	my $sndata = $connection->{screennames}->{$screenname};
	$sndata->{loglevel} = $params->{loglevel};
	$sndata->{report_idle} = $sendidle;
	$sndata->{idletime} = time;
	$sndata->{is_idle} = 0;
	$sndata->{signontime} = time;
	$sndata->{ison} = 0;
	$sndata->{inchan} = 0;
	$connection->{aimnick} ||= $screenname;
	$sndata->{away_buddies} = $oscar->buddyhash();
	$sndata->{away} = $oscar->buddyhash();
	$irc_connections->{$screenname} = $nick;

	switchnick($nick, $screenname) if $connection->{aimnick} eq $screenname;
	irc_send(irc_privmsg($usnick, $nick, "Sent signon attempt for $screenname..."));
	irc_send(irc_newnick($prefix.$screenname));

	$nicks->{$screenname}->{$screenname} = -1;
}

# Signoff a particular screenname
sub do_signoff($$;$) {
	my ($nick, $oscar, $already_off) = @_;

	my $screenname = $oscar->screenname if $oscar;

	for(my $i = $#dccqueue; $i >= 0; $i--) {
		my $dcc = $dccqueue[$i];
		next unless $screenname and $dcc->{screenname} eq $screenname;
		close $dcc->{socket} if $dcc->{socket};
		debug_print("Closed DCC $dcc->{desc} for $screenname due to signoff", "DCC", 3);
		splice(@dccqueue, $i, 1);
	}

	foreach my $chat(keys %chats) {
		my $chan = chatchan($chat);
		next unless normalize($chats{$chat}->{screenname}) eq normalize($screenname) or not $screenname;
		foreach my $who(keys %{$chats{$chat}->{members}}) {
			delete $chats{$chat}->{members}{$who};
			delete $nicks->{$who}->{"chat-$chat"};
			irc_send(irc_part(ircify($prefix.$who), $chan));
		}
		delete $chats{$chat};
		irc_send(irc_kick($usnick, $chan, $nick, "The screenname you were using in this chatroom is no longer signed on to AOL Instant Messenger."));
		irc_send(irc_part($usnick, $chan));
	}

	delete $irc_connections->{$screenname} if $screenname;

	if($screenname and $aim_connections->{$nick}->{screennames}->{$screenname}->{inchan}) {
		irc_send(irc_kick($usnick, nickchan($screenname), $nick, "You have been signed off of AOL Instant Messenger."));
	}

	delete $nicks->{$screenname}->{($usnick, $screenname)} if $screenname;
	foreach my $xnick(keys %$nicks) {
		next if $xnick eq $usnick or not $screenname;
		delete $nicks->{$xnick}->{$screenname}; 
		irc_send(irc_quit(ircify($prefix.$xnick), "Nobody wants me anymore.")) unless haskeys($nicks->{$xnick});
	}

	irc_send(irc_part($usnick, nickchan($screenname))) if $screenname;


	$oscar->signoff() unless $already_off or !$oscar;

	if($aim_connections->{$nick}) {
		$usercount-- if $aim_connections->{$nick}->{screennames}->{$screenname}->{ison};
		irc_send(irc_privmsg($usnick, $nick, "You have been signed off of AOL Instant Messenger as $screenname", "", "", $screenname)) unless $already_off or not $screenname;
		delete $aim_connections->{$nick}->{screennames}->{$screenname} if $screenname;
		if(haskeys $aim_connections->{$nick}->{screennames}) {
			my $xnick = (keys %{$aim_connections->{$nick}->{screennames}})[0];
			switchnick($nick, $xnick);
			irc_send(irc_privmsg($usnick, $nick, "Your new default screenname is $xnick.", "", "", $xnick));
		} else {
			delete $aim_connections->{$nick};
		}
	}
}

# Send mode as if it's coming from the server
sub irc_mode($$$) {
	my($who, $chan, $modes, $modestr) = @_;

	$modestr = "";
	$modestr = ":$who " unless $who eq $us;
	$modestr .= "MODE $chan $modes";
	$modestr .= " " . time if $servermode ne "ts" and $who eq $us;
	$modestr .= "\r\n";
	return $modestr;
}

# Join a channel
sub irc_join($$) {
	my($user, $channel, $ret) = @_;

	$ret = irc_newnick($user);
	$user = ircify($user);

	if($servermode eq "ts") {
		$user = "\@$user" if normalize($user) eq normalize($usnick);
		$ret .= "SJOIN " . time . " $channel + :$user\r\n";
	} else {
		$ret .= ":$user JOIN $channel\r\n";
	}

	return $ret;
}

# Kick someone from a channel
sub irc_kick($$$;$) {
	my($from, $channel, $nick, $reason) = @_;

	$nick =~ s/\@+//;
	return ":$from KICK $channel $nick" . ($reason ? " :$reason" : "") . "\r\n";
}

# Leave a channel
sub irc_part($$;$) {
	my($from, $channel, $reason) = @_;

	return ":$from PART $channel" . ($reason ? " :$reason" : "") . "\r\n";
}

# Send a numeric IRC error
sub irc_error($$$) {
	my($to, $number, $text) = @_;

	return "$number $to :$text\r\n";
}

# Change the topic for a channel
sub irc_topic($$$) {
	my($from, $channel, $topic) = @_;

	return ":$from TOPIC $channel :$topic\r\n";
}

# Reply to a PING
sub irc_pong() {
	return "PONG $us\r\n";
}

# Leave IRC
sub irc_quit($;$) {
	my($from, $reason) = @_;

	return ":$from QUIT" . ($reason ? " :$reason" : "") . "\r\n";
}

# Do all these bloody IRC commands really need documentation?  RTFRFC.
sub irc_invite($$$) {
	my($from, $channel, $who) = @_;

	return ":$from INVITE $who $channel\r\n";
}

# Receive a message from IRC
sub irc_recv(;$) {
	my($noblock, $rv, $buff, $incbuff, $idx, $ret) = ($_[0]);

	undef $rv;
	$! = EAGAIN;

	while(not $getbuff[0] and $! == EAGAIN and !defined($rv)) {
		$buff = ' ' x 512;
		$rv = $upstream->sysread($buff, 512);
		die "Couldn't read from IRC: $!" if !defined($rv) && $! != EAGAIN;
		if($! != EAGAIN) {
			#print STDERR "Reading from IRC...\n";
			if($incbuff) {
				$buff = "$incbuff$buff";
				undef $incbuff;
			}
			unless($buff =~ /\n$/) {
				$idx = rindex($buff, "\n") + 1;
				$incbuff = substr($buff, $idx, length($buff) - $idx + 1, "");
			}
			push @getbuff, split(/[\r\n]+/, $buff);
			#print STDERR "Getbuff is " . join("\n", @getbuff);
			#print STDERR "\n";
		}
		last if $noblock;
	}
	$ret = shift @getbuff;
	debug_print("From IRC: $ret", "irc", 2) if $ret;
	#print STDERR "Returning $ret\n";

	return $ret;
}

# Warn if a screenname is being mangled to work with IRC
sub manglewarn($$) {
	my($who, $what) = @_;

	irc_send(irc_privmsg($usnick, $who,
		"\02WARNING\02: Screenname $what has been mangled to IRC nickname " . $shortnicks->{$what}))

		if lc($shortnicks->{$what}) ne lc($what);
}

# Switch the default screenname for an IRCnick
sub switchnick($$) {
	my($nick, $newname) = @_;
	my $oldnick = $aim_connections->{$nick}->{aimnick};

	return 1 unless $aim_connections->{$nick}->{screennames}->{$newname};

	$aim_connections->{$nick}->{aimnick} = $newname;
	$aim_connections->{$nick}->{oscar} = $aim_connections->{$nick}->{screennames}->{$newname}->{oscar};

	return 0;
}

# Clean up nicknames, send keepalives/idle, etc.
sub timestuff($) {
	my($currtime, $anick, $kill, $bnick, $chantimer, $cname, $connection, $screenname, $multinick, $sndata, $nick) = shift;

	debug_print("Reaping nicks...", "nicks", 3);
	ANICK: foreach $anick(keys %$nicks) {
		next if $anick eq $usnick;
		next if exists $irc_connections->{noprefix($anick)};
		next if $anick =~ /^chat-\d+/;
		$kill = 1;
		debug_print("\tSO WE MEET AGAIN, $anick.", "nicks", 3);
		foreach $bnick(keys %{$nicks->{$anick}}) {
			next if $bnick eq $usnick;
			debug_print("\t\t$bnick was using $anick...", "nicks", 3);
			next ANICK if $kill == 0;
			if($nicks->{$anick}->{$bnick} == -1) {
				$kill = 0;
				debug_print("\t\t\tpermenantly.", "nicks", 3);
			} elsif (($currtime - $nicks->{$anick}->{$bnick}) < 3600) {
				$kill = 0;
				debug_print("\t\t\tsince " . ($currtime - $nicks->{$anick}->{$bnick}) . " seconds ago.", "nicks", 3);
			}
		}
		if($kill == 1) {
			delete $nicks->{$anick};
			irc_send(irc_quit(ircify($prefix.$anick), "Waah, nobody wants me (reaped)"));
			debug_print("\t$anick, HAVE A NICE AFTERLIFE. ($anick reaped)", "nicks", 1);
		} else {
			debug_print("\t$anick, YOU LIVE FOR NOW.", "nicks", 3);
		}
	}

	#Part from the restricted that we joined in response to someone joining without my authoritay
	foreach $chantimer(keys %chantimer) {
		if(($currtime - $chantimer{$chantimer}) >= 60) {
			irc_send(irc_part($usnick, $chantimer));
			delete $chantimer{$chantimer};
		}
	}


	#Only send idle/keepalive packets every other time through the loop
	if($keepalive) {
		foreach $cname(keys %$aim_connections) {
			$connection = $aim_connections->{$cname};
			foreach $screenname(keys %{$connection->{screennames}}) {
				next unless $screenname;
				$sndata = $connection->{screennames}->{$screenname};
				$multinick = "";
				$multinick = " for screenname $screenname" unless $screenname eq $connection->{aimnick} or $sndata->{inchan};
				next unless $sndata->{ison};
				if($sndata->{oscar}) {
					if($sndata->{report_idle} and not $sndata->{is_idle} and ($currtime - $sndata->{idletime}) >= 360) {
						$sndata->{oscar}->set_idle($currtime - $sndata->{idletime});
						$sndata->{is_idle} = 1;
					}
				}
			}
		}
		$keepalive = 0;
	} else {
		$keepalive = 1;
	}
}

# Signoff all screennames for a particular IRCnick
sub do_signoff_all($) {
	my ($nnick, $screenname, $nick) = @_;

	foreach $screenname(keys %{$aim_connections->{$nnick}->{screennames}}) {
		do_signoff($nnick, $aim_connections->{$nnick}->{screennames}->{$screenname}->{oscar});
	}
	irc_send(irc_privmsg($usnick, $nick, "All connections signed off of AOL Instant Messenger."));
	delete $aim_connections->{$nnick};
}

# Notify signed-on users that we're going down
sub going_down() {
	my ($user, @users) = (undef, keys %$aim_connections);

	foreach $user(@users) {
		next if $aim_connections->{$user}->{notified}++;
		irc_send(irc_privmsg($usnick, $user, "aimirc is going down.  You have been signed off of AOL Instant Messenger."));
	}
}

# Encode a message for CTCPing - you must still irc_send(":$sender PRIVMSG $target :$this")
sub irc_ctcp_quote($) {
	my($delim, $null) = (chr(001), chr(000));
	my $message = shift;

	$message =~ s/\\/\\\\/g;
	$message =~ s/$delim/\\a/g;
	$message =~ s/\n/\\\n/g;
	$message =~ s/\r/\\\r/g;
	$message =~ s/$null/\\$null/g;
	$message =~ s/:/\\/g;
	return $message;
}

# Decode an incoming CTCP
sub irc_ctcp_unquote($) {
	my($delim, $null) = (chr(001), chr(000));
	my $message = shift;

	$message =~ s/\\\\/\\/g;
	$message =~ s/\\a/$delim/g;
	$message =~ s/\\\n/\n/g;
	$message =~ s/\\\r/\r/g;
	$message =~ s/\\$null/$null/g;

	return $message;
}

# Process an incoming IRC command for CTCPs
sub process_ctcp($$$$) {
	my($from, $to, $message, $screenname) = @_;
	my ($delim, @ctcp, $ctcp, $cmd, $args) = (chr(001));
	my($filename, $ipaddr, $port, $filesize, $socket, $buff, $flags);

	return $message unless $message =~ /$delim/; 

	@ctcp = map { $_ = irc_ctcp_unquote $_; debug_print("CTCP: $_", "ctcp", 2) if $_; $_; } split(/$delim+/, $message);
	shift @ctcp;
	$message =~ s/$delim.*//g;
	debug_print("After CTCP: $message", "ctcp", 2);

	CTCP: foreach $ctcp(@ctcp) {
		$ctcp =~ /^(\S+) ?(.*)$/;
		$cmd = $1; $args = $2;

		debug_print("Processing CTCP $ctcp: command $cmd", "irc", 2);
		if($cmd eq "PING") {
			if($irc_connections->{noprefix($to)} eq $from) {
				$aim_connections->{$from}->{oscar}->send_im($to, "<!-- NOTICE --><!-- CTCP -->$ctcp");
			} else {
				irc_send(irc_ctcp($to, $from, $ctcp, 1)) if $cmd eq "PING";
			}
		}
		$message .= "\02ACTION\02 $args" if $cmd eq "ACTION"; #If you "/me runs" an AIMer, it'll turn into "<B>ACTION</B> runs".  Anyone got any better ideas?
		if($cmd eq "DCC") {
			$screenname = $dccget{$from} || "";
			($cmd, $args) = split(/ /, $args, 2);
			if($cmd eq "REJECT") {
				my($dcc, $i);
				for($i = $#dccqueue; $i >= 0; $i--) {
					$dcc = $dccqueue[$i];
					next unless $dcc->{for} eq $from;
					debug_print("$from rejected our DCC.", "DCC", 1);
					close $dcc->{socket} if $dcc->{socket};
					splice(@dccqueue, $i, 1);
				}
			} elsif($cmd eq "SEND") {
				$args =~ /(.+)\s+(\d+)\s+(\d+)\s+(\d+)/; #Handles spaces in filename
				($filename, $ipaddr, $port, $filesize) = ($1, $2, $3, $4);
				if(not $dccget{$from}) {
					irc_send(irc_privmsg($to, $from, "I'm not accepting DCCs from you at this time.", "", "", $screenname));
					irc_send(irc_ctcp($to, $from, "DCC REJECT SEND $filename", 1));
					next CTCP;
				}
				if($dccget{$from} and $filesize > 20480) {
					irc_send(irc_privmsg($to, $from, "Sorry, I won't accept buddylists larger than 20k.", "", "", $screenname));
					delete $dccget{$from};
					irc_send(irc_ctcp($to, $from, "DCC REJECT SEND $filename"));
					next CTCP;
				} else {
					socket($socket, PF_INET, SOCK_STREAM, getprotobyname('tcp'));
					set_blocking($socket, 0);

					if(!connect($socket, sockaddr_in($port, inet_aton($ipaddr))) and $! != EINPROGRESS) {
						irc_send(irc_privmsg($to, $from, "Couldn't receive your DCC: $!"));
						next CTCP;
					}
					push @dccqueue, {
						screenname => $screenname,
						from => new Net::OSCAR::Screenname($from),
						to => new Net::OSCAR::Screenname($to),
						for => new Net::OSCAR::Screenname($from),
						socket => $socket,
						time => time,
						size => $filesize,
						what => "",
						desc => $dccget{$from},
						state => DCC_STATE_GET_CONNECT,
						sent => 0,
						received => 0,
					};
					delete $dccget{$from};
					irc_send(irc_privmsg($to, $from, "Okay, I'll get your DCC of $filename.", "", "", $screenname));
				}
			}
		}
	}
	return $message;
}

# Like irc_privmsg
sub irc_ctcp($$$;$) {
	my($from, $to, $message, $reply) = @_;
	my $delim = chr(001);

	return ":$from " . ($reply ? "NOTICE" : "PRIVMSG") . " $to :$delim" . irc_ctcp_quote($message) . "$delim\r\n";
}

#Someone's sending us a file: DCC SEND filename IPaddr port filesize

sub loadbuddies($$) {
	my($oscar, $buff) = @_;
	my($line, $pmode, %buddies, @permit, @deny, %bnotes);
	my $profile = "";

	if($buff !~ /^Buddy {$/m) { #TOC-style
		my $group = "";
		foreach $line(split(/[\r\n]+/, $buff)) {
			$line =~ s/(.) //;
			my $cmd = $1;
			if($cmd eq "m") {
				$pmode = $line;
			} elsif($cmd eq "g") {
				$group = $line;
			} elsif($cmd eq "b") {
				push @{$buddies{$group}}, $line;
			} elsif($cmd eq "p") {
				push @permit, $line;
			} elsif($cmd eq "d") {
				push @deny, $line;
			}
		}
	} else {
		my @sections = ();
		my $subection = "";
		my $buddy = "";
		foreach $line(split(/[\r\n]+/, $buff)) {

			if($line =~ /^\s*(?!")(\S+) {\s*/) {
				push @sections, $1;
			} elsif($line =~ /^\s*}\s*$/) {
				pop @sections;
			} else {
				$line =~ /^\s*(\S+)\s*(.*?)\s*$/;
				my $var = $1; my $val = $2;
				if(lc($sections[0]) eq "buddy" and lc($sections[1]) eq "list") {
					if($val) {
						my $group = $var;
						if($val =~ /^\s*\"(.+?)\"( {)?$/) {
							($buddy = $1) =~ tr/ //d;
							push @{$buddies{$group}}, $buddy;
							push @sections, "buddy";
						}
					}
				} elsif(lc($sections[0] eq "privacy")) {
					if(lc($var) eq "allowlist" and $val) {
						while($val =~ s/\"(.+?)\"//g) {
							($buddy = $1) =~ tr/ //d;
							push @permit, $buddy;
						}
					} elsif(lc($var) eq "denylist" and $val) {
						while($val =~ s/\"(.+?)\"//g) {
							($buddy = $1) =~ tr/ //d;
							push @deny, $buddy;
						}
					} elsif(lc($var) eq "pref") {
						debug_print("Permit mode is $val", "config", 3);
						if(lc($val) eq "allowall") {
							$pmode = 1;
						} elsif(lc($val) eq "denyall") {
							$pmode = 2;
						} elsif(lc($val) eq "allowsome") {
							$pmode = 3;
						} elsif(lc($val) eq "denysome") {
							$pmode = 4;
						} elsif(lc($val) eq "permitbuddies") {
							$pmode = 5;
						} else {
							$pmode = 4;
						}
					}
				} elsif(lc($sections[0]) eq "buddy") {
				} elsif(lc($sections[0]) eq "buddynote") {
					if(lc($var) eq "notestring") {
						$bnotes{$buddy} = $val;
					}
				} elsif(lc($sections[0]) eq "profile" and lc($sections[1]) eq "user") {
					if(lc($var) eq "datablob") {
						$profile .= $val;
					}
				}
			}
		}
	}

	$oscar->set_profile(decode_base64($profile)) if $profile;

	$oscar->set_visibility($pmode);
	foreach my $group(keys %buddies) {
		$oscar->add_buddy($group, @{$buddies{$group}});
		foreach my $buddy(grep { exists($bnotes{$_}) } @{$buddies{$group}}) {
			$oscar->set_buddy_comment($group, $bnotes{$buddy});
		}
	}
	$oscar->add_permit(@permit);
	$oscar->add_deny(@deny);

	foreach my $group($oscar->groups) {
		my @currbuddies = $oscar->buddies($group);
		$buddies{$group} ||= [];
		my @newbuddies = @{$buddies{$group}};
		for(my $i = scalar(@currbuddies) - 1; $i >= 0; $i--) {
			splice(@currbuddies, $i, 1) unless grep {normalize($_) eq normalize($currbuddies[$i])} @newbuddies;
		}
		$oscar->remove_buddy($group, @currbuddies);
	}

	my @currbuddies = $oscar->get_permitlist;
	my @newbuddies = @permit;
	for(my $i = scalar(@currbuddies) - 1; $i >= 0; $i--) {
		splice(@currbuddies, $i, 1) unless grep {normalize($_) eq normalize($currbuddies[$i])} @newbuddies;
	}
	$oscar->remove_permit(@currbuddies);

	@currbuddies = $oscar->get_denylist;
	@newbuddies = @deny;
	for(my $i = scalar(@currbuddies) - 1; $i >= 0; $i--) {
		splice(@currbuddies, $i, 1) unless grep {normalize($_) eq normalize($currbuddies[$i])} @newbuddies;
	}
	$oscar->remove_deny(@currbuddies);

	$oscar->commit_buddylist;

	return 1;
}

# DCC send a file to someone - you must irc_send this!  Returns the empty string on error.
sub irc_dcc($$$$$$) {
	my($from, $to, $what, $why, $filename, $screenname, $msg, $flags, $socket) = @_;

	if(!$dccip) {
		irc_send(irc_privmsg($from, $to, "The administrator of this server has not configured an IP to use for DCC, so DCC SEND has been disabled.", "", "", $screenname));
		return "";
	}

	$socket = gensym;
	socket($socket, PF_INET, SOCK_STREAM, getprotobyname('tcp'));

	set_blocking($socket, 0);

	if(!setsockopt($socket, SOL_SOCKET, SO_REUSEADDR, pack("l", 1))) {
		irc_send(irc_privmsg($from, $to, "Couldn't set sockopt for DCC socket: $!", "", "", $screenname));
		return "";
	}
	if(!bind($socket, sockaddr_in(0, inet_aton($dccip)))) {
		irc_send(irc_privmsg($from, $to, "Couldn't bind DCC socket: $!", "", "", $screenname));
		return "";
	}
	if(!listen($socket, SOMAXCONN)) {
		irc_send(irc_privmsg($from, $to, "Couldn't listen on DCC socket: $!", "", "", $screenname));
		return "";
	}

	my($port) = sockaddr_in(getsockname($socket));

	$flags = 0;

	push @dccqueue, {
		screenname => new Net::OSCAR::Screenname($screenname),
		from => new Net::OSCAR::Screenname($from),
		to => new Net::OSCAR::Screenname($to),
		for => new Net::OSCAR::Screenname($to),
		socket => $socket,
		time => time,
		size => length($what),
		what => $what,
		desc => $why,
		state => DCC_STATE_SEND_LISTEN,
		sent => 0,
		received => 0
	};
	debug_print("DCC SEND (litening on $dccip:$port) buff: $what", "DCC", 3);
	return irc_ctcp($from, $to, "DCC SEND $filename " . unpack("N", inet_aton($dccip)) . " $port " . length($what));
}

#The base64 functions are for the P10 IRC protocol
sub num2base64($) {
	my $number = shift;
	my (@table, $char, $ret, $num, $currdig);

	$ret = "";
	foreach $char("A".."Z") { push @table, $char; }
	foreach $char("a".."z") { push @table, $char; }
	foreach $char("0".."9") { push @table, $char; }
	push @table, "[", "]";
	for($num = 2; $num >= 0; $num--) {
		next unless $number >= 64**$num;
		$currdig = ($number - 64**$num) % 64;
		$ret .= $table[$currdig];
		$number -= $currdig;
	}
	return $ret;
}

sub base642num($) {
	my $number = shift;
	my (%table, $char, $num, $currdig, $ret);

	$num = 0;
	foreach $char("A".."Z") { $table{$char} = $num++; }
	foreach $char("a".."z") { $table{$char} = $num++; }
	foreach $char("0".."9") { $table{$char} = $num++; }
	$table{"["} = $num++;
	$table{"]"} = $num++;

	$num = $ret = 0;
	while($currdig = substr($number, -1, 1, "")) {
		$ret += $table{$currdig}*64**$num++;
	}
	return $ret;
}

# Sanitize a screenname for IRC
sub ircify($) {
	my $screenname = shift;

	#Yes, I am aware that the RFC mandates a max of 9 characters.
	$screenname = substr($screenname, 0, $ircservers{$servermode}{nicklen});

	#Enforce RFC1459 compliance.
	#Note that this does the wrong thing in the pathological case of nicks which don't match /[a-zA-Z]/
	#But there's really no right thing to do in that case I suppose.
	#That's why it deserves the adjective "pathological".
	#
	$screenname =~ s/^[^a-zA-Z]+//; #Nicks must start with [a-ZA-Z]
	$screenname =~ tr/-a-zA-Z0-9[]\\`^{}//dc; #Anything except those characters is invalid

	return $screenname;
}

sub bounce_join($$) {
	my($nick, $chan) = @_;

	irc_send(irc_join($usnick, $chan));
	irc_send(irc_mode($us, $chan, "+o $usnick"));
	irc_send(irc_mode($usnick, $chan, "+isntb *!*@*"));
	irc_send(irc_kick($usnick, $chan, $nick, "This channel is reserved for aimirc usage."));
	$chantimer{$chan} = time;
}


sub process_dcc($$) {
	my $dcc = shift;
	my $time = shift; # Avoid numerous calls to time(2)

	$dcc->{time} = $time;

	my $screenname = $dcc->{screenname};
	my $buff;
	my $rv = undef;

	debug_print("Got activity on DCC $dcc->{desc} from $dcc->{from} to $dcc->{to}...", "DCC", 3);

	if($dcc->{state} == DCC_STATE_SEND_LISTEN) {
		debug_print("...State DCC_STATE_SEND_LISTEN", "DCC", 3);
		my $newsocket = gensym;
		accept $newsocket, $dcc->{socket} or die "Couldn't accept: $!";
		irc_send(irc_privmsg($usnick, $dcc->{for}, "DCC connection established.", "", "", $screenname));
		set_blocking($newsocket, 0);  # This pisses it off.
		close $dcc->{socket};
		$dcc->{socket} = $newsocket;
		$dcc->{state} = DCC_STATE_SEND_READY;
		return 1;
	} elsif($dcc->{state} == DCC_STATE_SEND_READY) {
		debug_print("...State DCC_STATE_SEND_READY", "DCC", 3);
		my $send = $dcc->{send} % 2048;
		$send = 2048 - $send;
		my $buff = substr($dcc->{what}, 0, $send);
		my $rv = syswrite $dcc->{socket}, $buff, $send;
		if(!defined($rv)) {
			if($! == EAGAIN) {
				return 1; # Why did select tell us we were ready, though?
			} else {
				irc_send(irc_privmsg($usnick, $dcc->{for}, "DCC connection dropped: $!", "", "", $screenname));
				close $dcc->{socket};
				return 0;
			}
		} else {
			substr($buff, 0, $rv) = "";
			$dcc->{sent} += $rv;
			$dcc->{state} = DCC_STATE_SEND_NEEDACK if $dcc->{sent} % 2048 == 0 or $dcc->{sent} == $dcc->{size};
		}
	} elsif($dcc->{state} == DCC_STATE_SEND_NEEDACK) {
		debug_print("...State DCC_STATE_SEND_NEEDACK", "DCC", 3);
		my $buff;
		my $rv = sysread $dcc->{socket}, $buff, 4;
		if(!defined($rv)) {
			if($! == EAGAIN) {
				return 1; # Why did select tell us we were ready, though?
			} else {
				irc_send(irc_privmsg($usnick, $dcc->{for}, "DCC connection dropped: $!", "", "", $screenname));
				close $dcc->{socket};
				return 0;
			}
		} else {
			($dcc->{received}) = unpack("N", $buff);
			debug_print("ACK received - client got $dcc->{received} of $dcc->{size} (we put $dcc->{sent})", "DCC", 3);
			$dcc->{state} = DCC_STATE_SEND_READY if $dcc->{sent} == $dcc->{received};

			if($dcc->{received} == $dcc->{size}) {
				debug_print("DCC $dcc->{desc} from $dcc->{from} to $dcc->{to} completed.", "DCC", 1);
				close $dcc->{socket};
				irc_send(irc_privmsg($usnick, $dcc->{for}, "DCC completed.", "", "", $screenname));
				return 0;
			}
		}
	} elsif($dcc->{state} == DCC_STATE_GET_CONNECT) {
		debug_print("...State DCC_STATE_GET_CONNECT", "DCC", 3);
		irc_send(irc_privmsg($usnick, $dcc->{for}, "DCC connection established.", "", "", $screenname));
		$dcc->{state} = DCC_STATE_GET_READY;
		return 1;
	} elsif($dcc->{state} == DCC_STATE_GET_READY) {
		debug_print("...State DCC_STATE_GET_READY", "DCC", 3);
		my $buff;
		my $rv = sysread $dcc->{socket}, $buff, 2048;
		if(!defined($rv)) {
			if($! == EAGAIN) {
				return 1; # Why did select tell us we were ready, though?
			} else {
				irc_send(irc_privmsg($usnick, $dcc->{for}, "DCC connection dropped: $!", "", "", $screenname));
				close $dcc->{socket};
				return 0;
			}
		} else {
			$dcc->{what} .= $buff;
			$dcc->{received} += $rv;
			$dcc->{state} = DCC_STATE_GET_SENDACK if $dcc->{received} % 2048 == 0 or $dcc->{received} == $dcc->{size};
			return 1;
		}
	} elsif($dcc->{state} == DCC_STATE_GET_SENDACK) {
		debug_print("...State DCC_STATE_GET_SENDACK", "DCC", 3);
		my $rv = syswrite $dcc->{socket}, pack("N", $dcc->{received}), 4;
		if(!defined($rv)) {
			if($! == EAGAIN) {
				return 1;
			} else {
				irc_send(irc_privmsg($usnick, $dcc->{for}, "DCC connection dropped: $!", "", "", $screenname));
				close $dcc->{socket};
				return 0;
			}
		} else {
			$dcc->{state} = DCC_STATE_GET_READY if $dcc->{received} % 2048 != 0;

			if($dcc->{received} == $dcc->{size}) {
				debug_print("DCC $dcc->{desc} from $dcc->{from} to $dcc->{to} completed.", "DCC", 1);
				close $dcc->{socket};
				irc_send(irc_privmsg($usnick, $dcc->{for}, "DCC completed.", "", "", $screenname));
				if(loadbuddies($aim_connections->{$dcc->{for}}->{screennames}->{$screenname}->{oscar}, $dcc->{what})) {
					irc_send(irc_privmsg($usnick, $dcc->{for}, "Buddylist loaded.", "", "", $screenname));
				} else {
					irc_send(irc_privmsg($usnick, $dcc->{for}, "Could not load buddylist.", "", "", $screenname));
				}
				return 0;
			}

			return 1;
		}
	} else {
		debug_print("...State unknown ($dcc->{state})", "DCC", 3);
		irc_send(irc_privmsg($usnick, $dcc->{for}, "Unknown state $dcc->{state}!  Please email matthewg\@zevils.com.", "", "", $screenname));
		return 0;
	}
}

sub send_im($$$) {
	my($oscar, $target, $msg) = @_;
	my $screenname = $oscar->screenname;

	irc_send(irc_newnick($prefix.$target));
	$nicks->{$target}->{$screenname} = time unless $nicks->{$target}->{$screenname} == -1;
	debug_print("$screenname -> $target: $msg", "im", 2);
	if($irc_connections->{$target} and $shortcircuit) {
		$aim_connections->{$irc_connections->{$target}}->{screennames}->{$target}->{oscar}->callback_im_in($screenname, $msg);
	} else {
		$oscar->send_im($target, $msg) if $oscar;
	}
	$nicks->{$target}->{$screenname} = time if $nicks->{$target}->{$screenname} != -1;
}

sub mkchan($$) {
	my($prefix, $suffix) = @_;
	return new Net::OSCAR::Screenname "#". ircify("$prefix-$suffix");
}

sub chatchan($) { confess "chatchan \"\"!" unless $_[0]; return mkchan("aimchat", shift); }
sub nickchan($) { return mkchan("aimirc", shift); }

sub set_blocking($$) {
	my($socket, $blocking) = @_;

	my $flags = 0;
	fcntl($socket, F_GETFL, $flags) or die "Couldn't get flags for upstream: $!";
	if($blocking) {
		$flags &= ~O_NONBLOCK;
	} else {
		$flags |= O_NONBLOCK;
	}
	fcntl($socket, F_SETFL, $flags) or die "Couldn't set flags for upstream: $!";
}

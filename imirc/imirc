#!/usr/bin/perl

$license = <<EOF
Copyright (c) 1999-2000 Matthew Sachs.  All Rights Reserved.

   This program is free software; you can redistribute it and/or
   modify it under the terms of version 2 of the GNU General Public License
   as published by the Free Software Foundation.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

   The GNU General Public License is included with the aimirc distribution
   under the filename COPYING.

 AOL Instant Messenger, AOL, and America Online are trademarks of America Online, Inc.
EOF
;

sub going_down();
sub do_signoff_all($;$);
sub timestuff();
sub switchnick($$);
sub irc_newnick($);
sub noprefix($);
sub haskeys($);
sub irc_subparms($;$$);
sub irc_privmsg($$$;$);
sub process_irc_message($);
sub process_aim_message($$$);
sub html2txt($;$);
sub Toc::debug_print($$$);
sub irc_send($;$);
sub deref($);
sub rehash();
sub reload();
sub dispver();
sub license();
sub help();
sub do_signon($$$$);
sub do_signoff($$;$);
sub send_server_mode($);
sub send_join($$);
sub irc_recv(;$);
sub truncwarn($$);
sub irc_ctcp_quote($);
sub irc_ctcp_unquote($);
sub process_ctcp($$$);
sub irc_ctcp($$$;$);
sub loadbuddies($$);
sub irc_dcc($$$$$);
sub safename($);
sub checkpoint();

sub END { going_down; }

sub BEGIN {
	require FindBin;
	use lib $FindBin::Bin;

	eval {
		require HTML::FormatText;
		require HTML::Parse;
	};

	if($@) {
		print STDERR "Couldn't require HTML::FormatText and/or HTML::Parse.  Here's why:\n";
		print STDERR "$@\n";
		print STDERR "\n\n";
		print STDERR "And here's what that probably means...\n\n";
		print STDERR "You do not have the HTML::FormatText and HTML::Parse modules installed.\n";
		print STDERR "There are at least three possible ways to install these modules:\n";
		print STDERR "1) [preferred] Get them as a package from your OS vendor or Linux distributor.\n";
		print STDERR "        In Debian, you can install the libhtml-tree-perl and \n";
		print STDERR "        libhtml-format-perl packages.  I'm not sure about\n";
		print STDERR "        other operating systems or distributions.\n";
		print STDERR "2) Use the CPAN module to install it.  Run perl -MCPAN -e shell and \n";
		print STDERR "        type install HTML::Tree when you get to the CPAN prompt, and\n";
		print STDERR "        then install HTML::FormatText .\n";
		print STDERR "3) Download the source from CPAN and install it.  The source is located\n";
		print STDERR "        at http://www.perl.com/CPAN/modules/by-module/HTML/ in a file\n";
		print STDERR "        called HTML-Tree-VERSION.tar.gz where VERSION is the latest version\n";
		print STDERR "        of HTML-Tree.  You will also need the HTML-Format-VERSION.tar.gz\n";
		print STDERR "        package.\n";
		die "\n";
	}
}

use FindBin;
use lib $FindBin::Bin;

use IO::Handle;
use IO::Socket;
use POSIX;
use Carp;
use Getopt::Long;
use LWP::Simple;
use File::Basename;
use ScandanavianCase qw(lc uc);
use FormatAIMIRC;

$Carp::Verbose = 1;

eval { require Data::Dumper; };

use Toc qw(:all);

$SIG{__DIE__}  = sub { croak $_[0] };

$home = (getpwuid($>))[7];
$version = $VERSION = "0.96";

@args = @ARGV;

# setpriority(0, $$, 19);


#Defaults
$prefix = "AIM-";
$usnick = "AIMServ";
$us = "aimserv.your.irc.net";
$them = "127.0.0.1";
$themport = 6667;
$ourpass = "foo";
$theirpass = "bar";
$servermode = "dal2";
$time = 60*5; #Five minutes
$verbose_signon = 0;
$ssl = 1;
@default_conffiles = ("/etc/aimirc.conf", "$home/.aimirc");
$fork = 1;
$verbose = 0;
$sendidle = 1;
$tocserver = 'toc.oscar.aol.com';
$tocport = 80;
$dcc = 1;
$savebuddies = 2;
$saveprofiles = 2;
$savepounces = 2;
$checkpoint = 60;
$directory = "$home/.aimirc.dat";
*debuglevel = *debug;	#We can now reference debuglevels as %debuglevel or %debug


#First we check to see what config files to use.
#Then we use the config files.
#Then we process command-line options.
#We do it this way so that command-line options can override config files, and
#  you can still specify config files on the command-line.

Getopt::Long::Configure("no_ignore_case");
Getopt::Long::Configure("pass_through");

$errors = &GetOptions(
	"version|V" => \&dispver,
	"license" => \&license,
	"config|C=s\@" => \@conffiles,
	"help|h" => \&help,
);

@conffiles = @default_conffiles unless $conffiles[0];

if(!$errors) {
	print STDERR "Try $0 --help if you need help.\n";
	exit 1;
}

#Okay, try loading the config files

$foundconfig = 0;
foreach $conffile(@conffiles) {
	$conffile =~ s/~/$home/;
	if(-r $conffile) {
		print STDERR "Reading config file $conffile\n" if $verbose;
		do $conffile;
		die $@ if $@;
		$foundconfig = 1;
	} else {
		print STDERR "Couldn't read config file $conffile\n" if $verbose;
	}
}

unless($foundconfig) {
	print STDERR "We couldn't find a config file.\n";
	print STDERR "You must edit aimirc.conf and copy it to either /etc/aimirc.conf or\n";
	print STDERR "   $home/.aimirc.  If you have already done this, make sure the aimirc\n";
	print STDERR "   user has permission to read it.\n";
	print STDERR "Or, perhaps you specified a config file with the --config (-C) option.\n";
	print STDERR "If you want to specify everything on the command-line and not use a config\n";
	print STDERR "   file (why?) then just give it a blank config file to make it happy.\n";
	exit 1;
}

#Now process additional command-line options

Getopt::Long::Configure("no_pass_through");

$errors = &GetOptions(
	"us=s" => \$us,
	"them=s" => \$them,
	"themport=i" => \$themport,
	"ourpass=s" => \$ourpass,
	"theirpass=s" => \$theirpass,
	"servermode=s" => \$servermode,
	"prefix=s" => \$prefix,
	"usnick=s" => \$usnick,
	"time=i" => \$time,
	"ssl:i" => \$ssl,
	"fork:i" => \$fork,
	"verbose|v" => \$verbose,
	"debug:i" => \$debug,
	"debuglevel=s\%" => \%debuglevel,
	"verbose_signon:i" => \$verbose_signon,
	"sendidle:i" => \$sendidle,
	"tocserver=s" => \$tocserver,
	"tocport=i" => \$tocport,
	"dccip=s" => \$dccip,
	"dcc:i" => \$dcc,
	"savebuddies:i" => \$savebuddies,
	"saveprofiles:i" => \$saveprofiles,
	"savepounces:i" => \$savepounces,
	"checkpoint=i" => \$checkpoint,
	"directory=s" => \$directory,
);

if(!$errors) {
	print STDERR "Try $0 --help if you need help.\n";
	exit 1;
}

%temp = %ircservers; #Preserve custom ircservers

%ircservers = (
	dal2 => {
		nick => "NICK _NICK_ 1 _TIME_ _USER_ $us $us 0 :AOL Instant Messenger client via aimirc\r\n",
		server => "SERVER $us 1 :AOL Instant Messenger services\r\n",
		uspass => 1,
		theirpass => 1,
		nicklen => 30,
		pass => "PASS $ourpass :1\r\n",
		EBURST => 1,
	},
	dragonfire => {
		nick => "NICK _NICK_ 1 _TIME_ _USER_ $us $us :AOL Instant Messenger client via aimirc\r\n",
		server => "SERVER $us 1 :AOL Instant Messenger services\r\n",
		uspass => 1,
		theirpass => 1,
		nicklen => 10,
		pass => "PASS $ourpass :1\r\n"
	},
	ircu => {
		nick => "NICK _NICK_ 1 _TIME_ _USER_ $us +i :AOL Instant Messenger services\r\n",
		server => "SERVER $us 1 _TIME_ _TIME_ P09 :AIM Services\r\n",
		uspass => 1,
		theirpass => 1,
		nicklen => 9,
		pass => "PASS :$ourpass\r\n"
	},
	rfc => {
		nick => "NICK _NICK_ 1\r\n:_NICK_ USER _USER_ $us $us :AOL Instant Messenger client via aimirc\r\n",
		server => "SERVER $us 1 :AOL Instant Messenger serices\r\n",
		uspass => 1,
		theirpass => 1,
		nicklen => 9,
		pass => "PASS :$ourpass\r\n"
	},
	ts => {
		nick => "NICK _NICK_ 1 _TIME_ +i _USER_ $us $us :AOL Instant Messenger client via aimirc\r\n",
		server => "SERVER $us 1 :AOL Instant Messenger serices\r\nSVINFO 3 1 0 :_TIME_\r\n",
		uspass => 1,
		theirpass => 1,
		nicklen => 9,
		pass => "PASS $ourpass :TS\r\n",
	},
);

foreach $server(keys %temp) { #Preserve custom ircservers
	$ircservers{$server} = $temp{$server};
}

if($ssl) {
	eval {
		require SSLv3;
	};

	if($@) {
		print STDERR "Couldn't load Perl module SSLv3.\n";
		print STDERR "This is probably due to a problem with IO::Socket::SSL.  Here's what Perl thinks:\n";
		print STDERR "$@\n";
		print STDERR "\n\n";
		print STDERR "And here's what that probably means...\n\n";
		print STDERR "You do not have the IO::Socket::SSL module installed.\n";
		print STDERR "There are at least two possible ways to install these modules:\n";
		print STDERR "1) [preferred] Get them as a package from your OS vendor or Linux distributor.\n";
		print STDERR "2) Use the CPAN module to install it.  Run perl -MCPAN -e shell and \n";
		print STDERR "        type install IO::Socket::SSL when you get to the CPAN prompt.\n";
		print STDERR "3) Download the source from CPAN and install it.  The source is located\n";
		print STDERR "        at http://www.perl.com/CPAN/modules/by-module/IO/ in a file\n";
		print STDERR "        called IO-Socket-SSL-VERSION.tar.gz where VERSION is the latest version\n";
		print STDERR "        of IO::Socket::SSL.\n";
		print STDERR "Note that IO::Socket::SSL has a couple of dependencies.\n";
		print STDERR "It requires the Net::SSLeay perl module and the OpenSSL library.\n";
		print STDERR "\n";
		print STDERR "IO::Socket::SSL is only required if you want to use SSL to communicate with TOC.\n";
		print STDERR "SSL is a type of encryption.\n";
		print STDERR "If you don't want SSL, set $ssl to 0 in your aimirc.conf (or .aimirc)\n";
		print STDERR "Alternatively, you can use the --ssl 0 command-line option.\n";
		die "\n";
	}

	SSLv3->context_init(SSL_verify_mode => 0x00, SSL_server => 0);
}

unless($reload) {
	if($fork) {
		#We don't need no stinking ampersands!
		$pid = fork;
		exit if $pid;
		die "Couldn't fork: $!" unless defined($pid);

		POSIX::setsid() or die "Can't start a new session: $!";
	}
	sub kill_handler {
		going_down;
		$upstream->close;
		foreach $connections(keys %$aim_connections) {
			$connections->{socket}->close;
		}
		exit 1;
	}
}

$SIG{INT} = $SIG{TERM} = \&kill_handler;
$SIG{CHLD} = 'IGNORE';

#Restart on SIGHUP
sub phoenix {
	going_down;
	$upstream->close;
	foreach $key(keys %aim_connections) {
		$aim_connections{$key}{socket}->close if $aim_connections{$key}{socket};
	}
	exec($0, @args);
}
$SIG{HUP} = \&rehash;


#Hello Mort!
sub REAPER {
	1 until (-1 == waitpid(-1, WNOHANG));
	$SIG{CHLD} = \&REAPER;
}
$SIG{CHLD} = \&REAPER;

#Connect

$| = 1;

#Who needs subroutines when you've got copy and paste?
#Incidentally, this is what I mean by that "code cleanup" item in TODO
#But would a trillion tiny functions be any cleaner?
#Oh well - who reads this anyway?

if(-d $directory and -r $directory) {
	local $/ = undef;
	if($savebuddies > 1 and -d "$directory/buddylists" and -r "$directory/buddylists") {
		foreach $buddylist(glob("$directory/buddylists/*")) {
			next if $buddylist =~ /\.\.?$/; #Skip . and ..
			open(BUDDYLIST, "<$buddylist");
			$buddylists{basename $buddylist} = <BUDDYLIST>;
			close BUDDYLIST;
		}
	}
	if($saveprofiles > 1 and -d "$directory/profiles" and -r "$directory/profiles") {
		foreach $profile(glob("$directory/profiles/*")) {
			next if $profile =~ /\.\.?$/; #Skip . and ..
			open(PROFILE, "<$profile");
			$profiles{basename $profile} = <PROFILE>;
			close BUDDYLIST;
		}
	}
	if($savepounces > 1 and -d "$directory/pounces" and -r "$directory/pounces") {
		foreach $pounce(glob("$directory/pounces/*")) {
			next if $pounce =~ /\.\.?$/; #Skip . and ..
			open(POUNCE, "<$pounce");
			$pounces = <POUNCE>;
			close POUNCE;
			foreach $_(split(/\n/, $pounces)) {
				($who, $what) = split;
				push @{$pounces{basename $pounce}}, {who => $who, what => $what};
			}
		}
	}

} else {
	if($savebuddies > 1 or $saveprofiles > 1 or $savepounces > 1) {
		mkdir($directory, 0700) or do {
			print STDERR "Warning - could not create $directory: $!\n";
			print STDERR "Fix it or we can't save buddies, profiles, or pounces to disk.\n";
			print STDERR "(Sleeping for 5 seconds to make sure you read this...)\n";
			sleep 5;
		};
	}
}

unless($reload) {
	$upstream = IO::Socket::INET->new(PeerAddr => "$them:$themport", Timeout => 60) or die "Couldn't connect to IRC server $them:$themport ($!)\n";

	$flags = '';
	fcntl($upstream, F_GETFL, $flags) or die "Couldn't get flags for upstream: $!";
	$flags |= O_NONBLOCK;
	fcntl($upstream, F_SETFL, $flags) or die "Couldn't set flags for upstream: $!";

	do { irc_send($ircservers{$servermode}{pass}) if $ourpass and $ircservers{$servermode}{uspass}; } or die "Couldn't send PASS: $!\n";
	irc_send(irc_subparms($ircservers{$servermode}{server})) or die "Couldn't send PASS: $!\n";

	$in = "...";

	$lasttime = $checktime = time;
	$keepalive = 0;

	if($theirpass and $ircservers{$servermode}{theirpass}) {
		while($in and ($in !~ /PASS :?(.+)/)) {
			$in = irc_recv();
			chomp $in;
			if($in =~ /^ERROR :(.+)/) {
				print STDERR "IRC connection error: $1\n";
				exit 1;
			} elsif($in =~ /^SERVER (\S+)/) {
				$themname = $1;
			}
		}

		$in =~ s/ :1// if $in;
		$in =~ s/ :TS// if $in;
		$in =~ /^PASS :?(.+)/ if $in;
		$pass = $1;
		$pass =~ s/\s*//g if $pass;	#Remove spaces from crypted password
		if($pass and $theirpass and ($pass ne $theirpass and $pass ne crypt($theirpass, substr($pass, 0, 2)))) { die("Upstream server gave the wrong password!\n"); }
	}

	if($ircservers{$servermode}{EBURST}) {
		while($in and ($in !~ /EBURST/)) {
			$in = irc_recv();
			chomp $in;
			if($in =~ /^ERROR :(.+)/) {
				print STDERR "IRC connection error: $1\n";
				exit 1;
			} elsif($in =~ /^SERVER (\S+)/) {
				$themname = $1;
			}
		}
	}

	$aimircdebug = 0;

	irc_send(irc_newnick($usnick)) or die "Couldn't make aimserv: $!\n";
	irc_send(":$usnick MODE $usnick -i\r\n");
	irc_send(":$usnick MODE $usnick +oa\r\n");

	send_join($usnick, "#aimirc-debug");
	send_server_mode("#aimirc-debug +o $usnick");
	irc_send(":$usnick MODE #aimirc-debug +nsk $ourpass\r\n");
	$aimircdebug = 1;
	$longnicks{'#aimirc-debug'} = '#aimirc-debug';

	while(1 == 1) {

		exit(255) unless $upstream;
		@aims = keys %aim_connections;
		foreach $aim(@aims) {
			$connection = $aim_connections{$aim};
			foreach $screenname(keys %{$aim_connections{$aim}{screennames}}) {
				next unless $screenname; #Why is this needed?
				do_signoff($connection->{nick}, undef) unless $connection->{screennames}{$screenname}{socket};
				$msg = sflap_get($connection->{screennames}{$screenname}{socket});
				if($msg == -1) {
					irc_send(irc_privmsg($usnick, $connection->{nick}, "There was an error with your AOL Instant Messenger connection for screenname $screenname: $err"));
					do_signoff($connection->{nick}, $connection->{screennames}{$screenname}{socket});
				} elsif($msg) {
					process_aim_message($connection, $msg, $screenname);
				}
			}
		}

		#Sleep for .01 seconds to give the CPU time to relax
		select(undef, undef, undef, .01);
		$_ = irc_recv(1); #Don't block
		process_irc_message($_) if $_;

		DCC: for($i = 0; $i <= $#dccqueue; $i++) {
			$dcc = $dccqueue[$i];
			if($dcc->{direction} eq "GET") {
				undef $rv;
				$! = EAGAIN;
				while($! == EAGAIN and !defined($rv)) {
					$buff = ' ' x 102;
					$rv = $dcc->{socket}->sysread($buff, 102); #A tenth of a kilobyte - should be okay even for slow connections
					if (!defined($rv) && $! != EAGAIN) {
						irc_send(irc_privmsg($dcc->{to}, $dcc->{from}, "DCC connection dropped: $!"));
						$dcc->{socket}->close;
						splice(@dcc, $i, 1);
						next DCC;
					}
					if(!defined($rv) && ($! == EAGAIN)) {
						next DCC;
					}
					$dcc->{buff} .= $buff;
					$dcc->{got} += $rv;
					Toc::debug_print("DCC got $rv bytes ($dcc->{got} of $dcc->{size})", "DCC", 2);

					$dcc->{socket}->print(pack("N", $dcc->{got})) if(($dcc->{got} % 2048) == 0 or $dcc->{got} == $dcc->{size}); # Every 2048 bytes, write number of bytes received

					if($dcc->{got} == $dcc->{size}) {
						Toc::debug_print("DCC $dcc->{direction} $dcc->{what} from $dcc->{from} to $dcc->{to} completed.", "DCC", 1);
						Toc::debug_print($dcc->{buff}, "DCC", 3);
						$dcc->{socket}->close;
						irc_send(irc_privmsg($dcc->{to}, $dcc->{from}, "DCC completed."));
						if($dcc->{what} eq "loadbuddies") {
							if(loadbuddies($aim_connections{$dcc->{from}}{screennames}{$dcc->{screenname}}{socket}, $dcc->{buff})) {
								irc_send(irc_privmsg($dcc->{to}, $dcc->{from}, "Buddylist loaded."));
							} else {
								irc_send(irc_privmsg($dcc->{to}, $dcc->{from}, "Could not load buddylist - is it in the correct format?"));
							}
						}
						splice(@dccqueue, $i, 1);
					}
				}
			} elsif($dcc->{direction} eq "SEND") {
				if($dcc->{put} == -1) {
					undef $rv;
					$rv = $dcc->{ssocket}->accept;
					if(defined $rv) {
						$dcc->{socket} = $rv;
						$dcc->{put} = 0;
					} elsif($! and $! != EAGAIN) {
						irc_send(irc_privmsg($dcc->{from}, $dcc->{to}, "DCC connection dropped: $!"));
						$dcc->{ssocket}->close;
						splice(@dcc, $i, 1);
						next DCC;
					}
				} else {
					undef $rv;
					$! = EAGAIN;
					while($! == EAGAIN and !defined($rv)) {
						if($dcc->{put} < $dcc->{size}) {
							$buff = substr($dcc->{buff}, 0, 102, "");
							$rv = $dcc->{socket}->syswrite($buff, length $buff); #A tenth of a kilobyte - should be okay even for slow connections
							if (!defined($rv) && $! != EAGAIN) {
								irc_send(irc_privmsg($dcc->{from}, $dcc->{to}, "DCC connection dropped: $!"));
								$dcc->{socket}->close;
								$dcc->{ssocket}->close;
								splice(@dcc, $i, 1);
								next DCC;
							}
							if(!defined($rv) && ($! == EAGAIN)) {
								next DCC;
							}
							$dcc->{put} += $rv;
							Toc::debug_print("DCC put $rv bytes ($dcc->{put} of $dcc->{size})", "DCC", 2);
						}

						if(($dcc->{put} % 2048) == 0 or $dcc->{put} == $dcc->{size}) {
							Toc::debug_print("Waiting for ACK...", "DCC", 3);
							undef $getrv;
							$! = EAGAIN;
							undef $rvbuff;
							while($! == EAGAIN and !defined($getrv)) {
								$buff = ' ' x 4;
								$getrv = $dcc->{socket}->sysread($buff, 4);
								if(!defined($getrv) && $! != EAGAIN) {
									irc_send(irc_privmsg($dcc->{from}, $dcc->{to}, "DCC connection dropped: $!"));
									$dcc->{socket}->close;
									$dcc->{ssocket}->close;
									splice(@dcc, $i, 1);
									next DCC;
								}
								if(!defined($getrv) && ($! == EAGAIN)) {
									next DCC;
								} elsif($getrv < 4) {
									Toc::debug_print("ACK incomplete - got $rvbuff", "DCC", 3);
									$rvbuff .= $buff;
									undef $getrv;
								}
								$dcc->{got} = unpack("N", $rvbuff . $buff);
								Toc::debug_print("ACK received - client got $dcc->{got} of $dcc->{size} (we put $dcc->{put})", "DCC", 3);
							}
						}

						if($dcc->{got} == $dcc->{size}) {
							Toc::debug_print("DCC $dcc->{direction} $dcc->{what} from $dcc->{from} to $dcc->{to} completed.", "DCC", 1);
							$dcc->{socket}->close;
							$dcc->{ssocket}->close;
							irc_send(irc_privmsg($dcc->{from}, $dcc->{to}, "DCC completed."));
							splice(@dccqueue, $i, 1);
						}
					}
				}
			}
		}

		$currtime = time;

		#Do this loop about once every 100 seconds
		if((($currtime % 100) == 0) and ($currtime - $lasttime) >= 100) { #Cleanup nicks
			timestuff;
		}
	}
}

# Create a new IRCnick, with truncation and anti-collide
sub irc_newnick($) {
	my($nick, $user, $string, $shortnick) = shift;
	$nick =~ tr/ //d;
	$user = $nick;
	$user =~ s/^$prefix//;

	Toc::debug_print("Shall we create $nick?", "nicks", 2);
	return if haskeys($nicks{noprefix $nick});
	$shortnick = substr($nick, 0, $ircservers{$servermode}{nicklen});
	$nicks{noprefix($shortnick)}{$usnick} = time;
	Toc::debug_print("\tCreating $nick (normalized " . normalize($nick) . ", shortnick $shortnick)", "nicks", 1);
	$longnicks{normalize($shortnick)} = $nick;
	$shortnicks{noprefix($nick)} = $shortnick;
	$string = irc_subparms($ircservers{$servermode}{nick}, $user, $shortnick);
	$string .= ":$shortnick MODE $shortnick +i\r\n";
	return $string;
}

# Remove $prefix
sub noprefix($) {
	my $nick = shift;
	$nick =~ s/^$prefix//i;
	return normalize $nick;
}

# Does the hashref have any keys?
sub haskeys($) {
	my $hashref = shift;
	return scalar keys %$hashref;
}

# Substitute parameters in %ircservers strings
sub irc_subparms($;$$) {
	my($input, $user, $nick, $time) = @_;
	$time = time;
	$input =~ s/_TIME_/$time/g;
	$input =~ s/_USER_/$user/g;
	$input =~ s/_NICK_/$nick/g;
	return $input;
}

# Format an IRC private message - you must still irc_send it!
sub irc_privmsg($$$;$) {
	my($from, $to, $msg, $prefix, $line, $ret, $text, $temp) = @_;

	return unless $from and $to and $msg;

	$from = substr($from, 0, $ircservers{$servermode}{nicklen});
	if($from ne $usnick and not haskeys($nicks{noprefix($from)})) {
		irc_send(irc_newnick($from));
	}

	foreach $line(split(/[\r\n]+/, $msg)) {
		$text = "$prefix$line";
		while($text) {
			$temp = substr($text, 0, 498 - length $from - length $to, "");
			$ret .= ":$from PRIVMSG $to :$temp\r\n";
		}
	}
	return $ret or $msg;
}

# Process an incoming IRC message
sub process_irc_message($) {
	$_ = shift;

	if(s/^:(\S+)(!\S+@\S+)?\s+//) {
		$nick = $1;
	} else {
		$nick = $themname;
	}
	my $nnick = normalize($nick);

	if($aim_connections{$nnick}) {
		$aimnick = $aim_connections{$nnick}{aimnick};
		#Toc::debug_print("Got IRC event from $nnick.  is_idle: $aim_connections{$nnick}{screennames}{$aimnick}{is_idle}", "sflap", 1);
		$aim_connections{$nnick}{screennames}{$aimnick}{idletime} = time;
		if($aim_connections{$nnick}{screennames}{$aimnick}{is_idle}) {
			$aim_connections{$nnick}{screennames}{$aimnick}{is_idle} = 0;
			if(set_idle($aim_connections{$nnick}{socket}, 0) == -1) {
				irc_send(irc_privmsg($usnick, $nick, "There was an error with your AOL Instant Messenger connection as $aim_connections{$nnick}{aimnick}: $err"));
				do_signoff($nnick, $aim_connections{$nnick}{socket});
			}
		}
	}

	if(/^ERROR +:(.+)/) {
		print STDERR "IRC server error: $1\n";
		exit 1;
	} elsif(/^KILL +(\S+)/i) {
		delete $nicks{noprefix $1};
	} elsif(/^VERSION/i) {
		irc_send("351 $nick aimirc-$VERSION. $us :aimirc\r\n");
	} elsif(/^JOIN +.?#aimchat-(\d+)/i or /^SJOIN +\d+ +#aimchat-(\d+) +\S+ +:(\S+)/i) {
		my $chat = $1;
		$nick = $2 if $2;
		$nick =~ tr/\@+//d; #Only needed for Hybrid?
		$nnick = normalize($nick);

		if((not $chatinvites{$chat} and not $chattopics{$chat}) or ($chatinvites{$chat} and $nnick ne normalize($chatinvites{$chat}))) {
			send_join($usnick, "#aimchat-$chat");
			send_server_mode("#aimchat-$chat +isnto $usnick");
			irc_send(":$usnick KICK #aimchat-$chat $nick :This channel is reserved for aimirc usage.\r\n");
			$chattimer{$chat} = time;
		} elsif($aim_connections{$nnick}) {
			$chatjoined{$chat} = 1;
			if($chatinvites{$chat}) {
				chat_accept($aim_connections{$nnick}{screennames}{$chatnames{$chat}}{socket}, $chat);
			} else {
				irc_send($chatqueue{$chat});
				delete $chatqueue{$chat};
			}
			irc_send(":$usnick MODE #aimchat-$chat +o $nnick\r\n");
		}
	} elsif(/^INVITE +(\S+) +:?#aimchat-(\d+)/i) {
		my $recipient = noprefix($1);
		my $chat = $2;

		chat_invite($aim_connections{$nnick}{socket}, $chat, "Please come to $chattopics{$chat}.", $recipient) if $aim_connections{$nnick};
	} elsif(/^MODE +#aimchat-(\d+) +:?(.+)/i) {
		my $chat = $1;
		my $modes = $2;
		my ($mode, $parms, @matches, @modes, @params, @tparams, $params, $modestring, $modechar, $modeparm, $modetype, $status);

		irc_send("504 $nick :You cannot change modes in AIM chat channels.\r\n") if $aim_connections{$nnick};

		$modes =~ tr/+-/-+/;
		$modes =~ s/\s*\d+[\r\n]*$// unless $aim_connections{$nnick};
		#Toc::debug_print("Modes: $modes", "errors", 3);
		@matches = $modes =~ m/([-+][a-zA-Z]+)\s*/g or Toc::debug_print("Mode parse failed.", "errors", 3);
		foreach $modestring(@matches) {
			#Toc::debug_print("Mode parse suceeded: $modestring", "errors", 3);
			$modetype = substr($modestring, 0, 1, "");
			#Toc::debug_print("modetype is $modetype", "errors", 3);
			MODE: while($modechar = substr($modestring, 0, 1, "")) {
				#Toc::debug_print("Got modechar $modechar", "errors", 3);
				if($modechar =~ /[vbokl]/) { #Mode takes a parm
					$modes =~ s/(?:\s|\A)([^-+]\S*)(?:\s|\Z)/ / or next MODE;
					$modeparm = $1;
					#Toc::debug_print("Mode takes parm, parm is $modeparm", "errors", 3);
				} else {
					$modeparm = "";
				}
				if($modechar eq "o" and normalize($modeparm) eq normalize($usnick)) {
					if($modetype eq "+") {
						if($servermode eq "ts") {
							irc_send("MODE #aimchat-$chat +o $usnick\r\n");
						} else {
							irc_send(":$usnick MODE #aimchat-$chat +o $usnick\r\n");
						}
					}
				} elsif($modechar eq "o" and $aim_connections{normalize($modeparm)} and $modetype eq "-") {
					#Do nothing
				} elsif(($modechar eq "t" or $modechar eq "s" or $modechar eq "n" or $modechar eq "i") and $modetype eq "-") {
					#Do nothing
				} else {
					#Toc::debug_print("Adding to \@modes: (char => $modechar, type => $modetype, parm => $modeparm)", "errors", 3);
					push @modes, { char => $modechar, type => $modetype, parm => $modeparm };
				}
			}
		}
		#foreach $mode(@modes) {
		#	Toc::debug_print("Got mode: " . $mode->{type} . $mode->{char} . " " . $mode->{parm}, "irc", 3);
		#}

		$modestring = "";
		$parms = "";
		foreach $mode(sort { $a->{type} cmp $b->{type} } @modes) {
			if($mode->{type} eq "-" and not $status & 1) { #We have a -, modestring doesn't
				$modestring .= "-";
				$status |= 1;
			} elsif($mode->{type} eq "+" and not $status & 2) { #We have a +, modestring doesn't
				$modestring .= "+";
				$status |= 2;
			}
			$modestring .= $mode->{char};
			$parms .= " $mode->{parm}" if $mode->{parm};
		}

		$modestring .= $parms;

		#Toc::debug_print("Mode parse final: $modestring", "errors", 3);

		irc_send(":$usnick MODE #aimchat-$chat $modestring\r\n") if $modestring;
	} elsif(/^TOPIC +#aimchat-(\d+)/i) {
		irc_send("505 $nick :Cannot change topic in AIM chat channels.\r\n");
		irc_send("TOPIC #aimchat-$chat :$chattopics{$chat}\r\n");
	} elsif(/^KICK +#aimchat-(\d+) +(\S+)/i) {
		irc_send("503 $nick :Cannot kick users from AIM chat channels.\r\n");
		send_join($2, "#aimchat-$1");
		if(normalize($2) eq normalize($usnick)) {
			if($servermode eq "ts") {
				irc_send("MODE #aimchat-$1 +o $usnick\r\n");
			} else {
				irc_send(":$usnick MODE #aimchat-$1 +o $usnick\r\n");
			}
		}
	} elsif(/^PART +#aimchat-(\d+)/i) {
		Toc::debug_print("$nick left aimchat $1 ($chattopics{$1}).", "chat", 1);
		if($aim_connections{$nnick} and $chattopics{$1}) {
			chat_leave($aim_connections{$nnick}{screennames}{$chatnames{$1}}{socket}, $1) if $aim_connections{$nnick};
			irc_send(":$usnick PART #aimchat-$1\r\n");
			foreach $who(keys %{$chats{$1}}) {
				delete $chats{$1}{$who};
				delete $nicks{normalize($who)}{"chat-$1"};
				irc_send(":$prefix$who PART #aimchat-$1\r\n");
			}
			delete $chattopics{$1};
			delete $chatnames{$1};
			delete $chatjoined{$1};
		}
	} elsif(/^PRIVMSG +$usnick(\@\S+)? +:?(.+)/i) {
		$msg = process_ctcp($nnick, $usnick, $2);
		return unless $msg;

		$cmd = undef; $extra = undef; $param = undef;
		$msg =~ /(\S+) ?(\S*)( ?.*)/ or $cmd = $msg;
		$cmd = $1 unless $cmd; $param = $2 if $2 or $2 eq "0"; $extra = substr($3, 1) || "" if $3;
		$cmd ||= $msg; #For cmds w/o param
		#warn "Cmd: $cmd\nParam: $param: Extra: $extra\n\n";
		$nick = lc($nick);
		unless($aim_connections{$nnick} or ($cmd eq "signon") or ($cmd eq "help")) {
			irc_send(irc_privmsg($usnick, $nick, "You must use the signon command to sign on to AOL Instant Messenger before using this service."));
		} elsif($cmd eq "signon") {
			$param = normalize $param;
			unless($param and $extra) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: signon screenname password"));
			} else {
				if($aim_connections{$nnick} and $aim_connections{$nnick}{screennames}{$param}) {
					irc_send(irc_privmsg($usnick, $nick, "You are already signed onto AOL instant messenger under that screenname."));
				} else {
					irc_send(irc_privmsg($usnick, $nick, "Signing on to AOL Instant Messenger..."));
					do_signon($param, $extra, $usnick, $nick);
				}
			}
		} elsif ($cmd eq "buddylist") {
			my(%groups, $buddy, $group);
			my $buddies = 0;

			%temp = deref(get_config($aim_connections{$nnick}{aimnick}));
			foreach $buddy(sort keys %{$temp{Buddies}}) {
				push @{$groups{$temp{Buddies}{$buddy}{group}}}, $buddy;
			}
			foreach $group(sort keys %groups) {
				foreach $buddy(sort @{$groups{$group}}) {
					irc_send(irc_privmsg($usnick, $nick, "$buddy ($group)"));
					$buddies++;
				}
			}
			irc_send(irc_privmsg($usnick, $nick, "Your buddylist is empty.")) unless $buddies;
		} elsif ($cmd eq "onbuddies") {
			my(%groups, $buddy, $group);
			my $onbuddies = 0;

			%temp = deref(get_config($aim_connections{$nnick}{aimnick}));
			foreach $buddy(sort keys %{$temp{Buddies}}) {
				push @{$groups{$temp{Buddies}{$buddy}{group}}}, $buddy if $temp{Buddies}{$buddy}{online};
			}
			foreach $group(sort keys %groups) {
				foreach $buddy(sort @{$groups{$group}}) {
					irc_send(irc_privmsg($usnick, $nick, "$buddy ($group)"));
					$onbuddies++;
				}
			}
			irc_send(irc_privmsg($usnick, $nick, "None of your buddies are online.")) unless $onbuddies;
		} elsif ($cmd eq "permitlist") {
			%temp = deref(get_config($aim_connections{$nnick}{aimnick}));
			irc_send(irc_privmsg($usnick, $nick, join(" ", sort keys(%{$temp{permit}}))));
			irc_send(irc_privmsg($usnick, $nick, "Your permit list is empty.")) unless haskeys $temp{permit};
		} elsif ($cmd eq "denylist") {
			%temp = deref(get_config($aim_connections{$nnick}{aimnick}));
			irc_send(irc_privmsg($usnick, $nick, join(" ", sort keys(%{$temp{deny}}))));
			irc_send(irc_privmsg($usnick, $nick, "Your deny list is empty.")) unless haskeys $temp{deny};
		} elsif ($cmd eq "signoff") {
			do_signoff($nnick, $aim_connections{$nnick}{socket}) if $aim_connections{$nnick};
		} elsif ($cmd eq "buddyinfo") {
			unless($param) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: buddyinfo screenname"));
			} else {
				%temp = deref(get_config($aim_connections{$nnick}{aimnick}));
				$param = lc($param);
				$group = $temp{Buddies}{$param}{group};
				if($temp{Buddies}{$param}) {
					local $^W = 0;
					$msg = ":$usnick PRIVMSG $nick :";
					$msg .= "Group: $group\t" if $group and $group ne "Buddies";
					$msg .= "Signon time: " . localtime($temp{Buddies}{$param}{signon}) . "\tIdle time: $temp{Buddies}{$param}{idle} minutes\tUser class: ";
					$msg .= parseclass($temp{Buddies}{$param}{class}) . "\r\n";
					irc_send($msg);
				} else {
					irc_send(irc_privmsg($usnick, $nick,  "That persion is either not on your buddy list or not signed on."));
				}
			}
		} elsif ($cmd eq "add_buddy") {
			unless($param) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: add_buddy screenname [group]"));
			} else {
				$param = lc($param);
				$group = $extra || "Buddies";
				add_buddy($aim_connections{$nnick}{socket}, [split(/,/, $param)], $group);
				irc_send(irc_privmsg($usnick, $nick, "Buddylist updated."));
			}
		} elsif ($cmd eq "remove_buddy") {
			unless($param) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: remove_buddy screenname"));
			} else {
				$param = lc($param);
				remove_buddy($aim_connections{$nnick}{socket}, [split(/,/, $param)]);
				# irc_send(irc_privmsg($usnick, $nick, "$param has departed"));
				irc_send(irc_privmsg($usnick, $nick, "Buddylist updated."));
			}
		} elsif ($cmd eq "evil" or $cmd eq "warn") {
			unless($param) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: $cmd screenname [anon]"));
			} else {
				$param = lc($param);
				if($extra ne "anon") {
					$extra = 0;
				} else {
					$extra = 1;
				}
				evil($aim_connections{$nnick}{socket}, $param, $extra);
			}
		} elsif ($cmd eq "add_permit") {
			unless($param) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: add_permit screenname"));
			} else {
				$param = lc($param);
				add_permit($aim_connections{$nnick}{socket}, [split(/,/, $param)]);
				irc_send(irc_privmsg($usnick, $nick, "Permit list updated."));
			}
		} elsif ($cmd eq "add_deny") {
			unless($param) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: add_deny screenname"));
			} else {
				$param = lc($param);
				add_deny($aim_connections{$nnick}{socket}, [split(/,/, $param)]);
				irc_send(irc_privmsg($usnick, $nick, "Deny list updated."));
			}
		} elsif ($cmd eq "remove_deny") {
			unless($param) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: remove_deny screenname"));
			} else {
				$param = lc($param);
				remove_deny($aim_connections{$nnick}{socket}, [split(/,/, $param)]);
				irc_send(irc_privmsg($usnick, $nick, "Deny list updated."));
			}
		} elsif ($cmd eq "remove_permit") {
			unless($param) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: remove_permit screenname"));
			} else {
				$param = lc($param);
				remove_permit($aim_connections{$nnick}{socket}, [split(/,/, $param)]);
				irc_send(irc_privmsg($usnick, $nick, "Permit list updated."));
			}
		} elsif ($cmd eq "join") {
			unless($param) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: join chat_name"));
			} else {
				$extra ? chat_join($aim_connections{$nnick}{socket}, "$param $extra") : chat_join($aim_connections{$nnick}{socket}, $param);
			}
		} elsif ($cmd eq "join_exchange") {
			unless($param and $extra) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: join_exchange exchange chat_name"));
			} else {
				chat_join_exchange($aim_connections{$nnick}{socket}, $extra, $param);
			}
		} elsif ($cmd eq "get_permit_mode") {
			irc_send(irc_privmsg($usnick, $nick, "Your permit mode is " . permtype($aim_connections{$nnick}{socket}) . "."));
		} elsif ($cmd eq "set_permit_mode") {
			unless($param) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: set_permit_mode newmode"));
			} else {
				if($param != 1 and $param != 2 and $param != 3 and $param != 4) {
					irc_send(irc_privmsg($usnick, $nick, "That is not a valid permit mode.  See list_permit_modes for valid permit modes."));
				} else {
					$aim_connections{$nnick}{permtype} = $param;
					permtype($aim_connections{$nnick}{socket}, $param);
					irc_send(irc_privmsg($usnick, $nick, "Permit mode set."));
				}
			}
		} elsif ($cmd eq "list_permit_modes") {
			irc_send(irc_privmsg($usnick, $nick, "1=Permit All, 2=Deny All, 3=Permit if and only if on permitlist, 4=Deny if and only if on denylist"));
		} elsif ($cmd eq "whisper") {
			$extra =~ /(\S+) (.*)/;
			unless($param and $1 and $2) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: whisper chat_id screenname text"));
			} else {
				if(UNIVERSAL::isa($aim_connections{$nnick}{screennames}{$chatnames{$param}}{socket}, "IO::Socket")) {
					chat_whisper($aim_connections{$nnick}{screennames}{$chatnames{$param}}{socket}, $param, $1, $2);
				} else {
					irc_send(irc_privmsg($usnick, $nick, "That is not a valid chat ID."));
				}
			}
		} elsif ($cmd eq "chat_evil" or $cmd eq "chat_warn") {
			$extra =~ /(\S+) ?(.*)/;
			unless($param and $extra) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: $cmd chat_id screenname [anon]"));
			} else {
				$foo = undef;
				$foo = "norm" if $2 ne "anon";
				$foo ne "norm" ? $foo = 1 : $foo = 0;
				chat_evil($aim_connections{$nnick}{socket}, $param, $1, $foo);
			}
		} elsif ($cmd eq "info" or $cmd eq "get_info") {
			unless($param) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: info screenname"));
			} else {
				$param = lc($param);
				get_info($aim_connections{$nnick}{socket}, $param);
			}
		} elsif ($cmd eq "set_info" or $cmd eq "set_profile") {
			my $text;
			unless($param) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: $cmd info"));
			} else {
				$extra ? ($text = "$param $extra") : ($text = $param);
				set_info($aim_connections{$nnick}{socket}, $text);
				$profiles{safename($aim_connections{$nnick}{aimnick})} = $text if $saveprofiles > 0;
				irc_send(irc_privmsg($usnick, $nick, "Your profile has been updated."));
			}
		} elsif ($cmd eq "get_dir") {
			unless($param) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: get_dir screenname"));
			} else {
				get_directory($aim_connections{$nnick}{socket}, $param);
			}
		} elsif ($cmd eq "set_dir") {
			$param = "$param $extra" if $extra;
			if($param and $param ne "set_dir") {
				@temp = split(/:/, $param);
					%temp = (
					first_name => shift @temp,
					middle_name => shift @temp,
					last_name => shift @temp,
					maiden_name => shift @temp,
					city => shift @temp,
					state => shift @temp,
					country => shift @temp,
					allow_web_searches => shift @temp
				);
				set_directory($aim_connections{$nnick}{socket}, %temp);
			} else {
				irc_send(irc_privmsg($usnick, $nick, "first name:middle name:last name:maiden name:city:state:country:websearch.  Don't put any colons in any of these.  If you put anything in the websearch field, people can find your directory info using web searches."));
			}
		} elsif ($cmd eq "dir_search") {
			$param = "$param $extra" if $extra;
			if($param and $param ne "dir_search") {
				@temp = split(/:/, $param);
				%temp = (
					first_name => shift @temp,
					middle_name => shift @temp,
					last_name => shift @temp,
					maiden_name => shift @temp,
					city => shift @temp,
					state => shift @temp,
					country => shift @temp,
					allow_web_searches => shift @temp
				);
				directory_search($aim_connections{$nnick}{socket}, %temp);
			} else {
				irc_send(irc_privmsg($usnick, $nick, "first name:middle name:last name:maiden name:city:state:country:websearch.  Don't put any colons in any of these.  If you put anything in the websearch field, people can find your directory info using web searches."));
			}
		} elsif ($cmd eq "add") {
			unless($param) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: add screenname"));
			} else {
				unless($nicks{noprefix $param}) {
					irc_send(irc_newnick($prefix . normalize $param));
				}
				truncwarn($nick, $param);
				$nicks{noprefix $param}{$nnick} = time;	
				irc_send(irc_privmsg($usnick, $nick, "$param has been created on IRC."));
			}
		} elsif ($cmd eq "sendidle") {
			unless($param == 0 or $param == 1) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: sendidle (0|1)"));
			} else {
				$aim_connections{$nnick}{report_idle} = $param;
				irc_send(irc_privmsg($usnick, $nick, "Idle reporting changed."));
			}
		} elsif ($cmd eq "format_nickname" or $cmd eq "format_screenname") {
			unless($param) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: $cmd screenname"));
			} else {
				$param .= " $extra" if $extra;
				format_nickname $aim_connections{$nnick}{socket}, $param;
			}
		} elsif ($cmd eq "change_password") {
			unless($param and $extra) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: change_password old_password new_password"));
			} else {
				change_password $aim_connections{$nnick}{socket}, $param, $extra;
			}
		} elsif ($cmd eq "loadbuddies") {
			$dccget{$nnick} = "loadbuddies";
			irc_send(irc_ctcp($usnick, $nnick, "loadbuddies"));
			irc_send(irc_privmsg($usnick, $nnick, "Please DCC SEND $usnick your buddylist."));
		} elsif ($cmd eq "savebuddies") {
			my $oscar = 0;
			my(%config, $config, $message, $group, $buddy, %groups, $filename);

			unless($dccip) {
				irc_send(irc_privmsg($usnick, $nick, "savebuddies is not available on this server - the administrator has not specified a DCC IP in the aimirc configuration file."));
			} else {
				$oscar = 1 if $param and lc($param) ne "toc";
				%config = deref(get_config($aim_connections{$nnick}{aimnick}));

				if($oscar) {
					$config =
"Config {
 version 1
}
User {
 screenName $aim_connections{$nnick}{aimnick}
}
Buddy {
 list {
";
					#"Borrowed" from conf2str
					#Toc::debug_print("TOC to OSCAR: config is " . Data::Dumper::Dumper(%config), "IRC", 1);
					foreach $buddy(keys %{$config{Buddies}}) {
						$group = $config{Buddies}{$buddy}{group};
						#Toc::debug_print("TOC to OSCAR: putting $buddy in $group", "IRC", 1);
						push @{$groups{$group}}, $buddy;
					}
					foreach $group (sort keys %groups) {
						next if $group eq "permit" or $group eq "deny" or $group eq "permtype" or $group eq "groups";
						$config .= "  $group";
						foreach $buddy(sort @{$groups{$group}}) {
							$config .= " $buddy";
						}
						$config .= "\n";
					}
					$config .= " }\n}\nPrivacy {\n";
					$config .= " allowList " . join(" ", keys %{$config{permit}}) . "\n";
					$config .= " blockList " . join(" ", keys %{$config{deny}}) . "\n";
					$config .= " pref ";
					if($config{permtype} == 1) {
						$config .= "AllowAll";
					} elsif($config{permtype} == 2) {
						$config .= "DenyAll";
					} elsif($config{permtype} == 3) {
						$config .= "AllowSome";
					} else {
						$config .= "DenySome";
					}
					$config .= "\n}\n";
					$filename = $aim_connections{$nnick}{aimnick} . ".blt";
				} else {
					$config = conf2str(%config);
					$filename = $aim_connections{$nnick}{aimnick} . ".txt";
				}

				$message = irc_dcc($usnick, $nnick, $config, "savebuddies", $filename);
				if($message) {
					irc_send($message);
					irc_send(irc_ctcp($usnick, $nick, "savebuddies"));
					irc_send(irc_privmsg($usnick, $nnick, "Please accept the DCC SEND from $usnick.  The file being sent is your buddylist."));
				}


			}
		} elsif ($cmd eq "add_pounce") {
			unless($param and $extra) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: add_pounce screenname text"));
			} else {
				push @{$aim_connections{$nnick}{screennames}{$aim_connections{$nnick}{aimnick}}{pounces}}, {who => $param, what => $extra};
				irc_send(irc_privmsg($usnick, $nick, "Pounce added."));
				push @{$pounces{safename $aim_connections{$nnick}{aimnick}}}, {who => $param, what => $extra} if $savepounces > 0;
			}
		} elsif ($cmd eq "remove_pounce") {
			unless(defined $param) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: remove_pounce number"));
			} else {
				unless(splice(@{$aim_connections{$nnick}{screennames}{$aim_connections{$nnick}{aimnick}}{pounces}}, $param, 1)) {
					splice(@{$pounces{safename $aim_connections{$nnick}{aimnick}}}, $param, 1) if $savepounces > 0;
					irc_send(irc_privmsg($usnick, $nick, "That pounce does not exist - do \"/msg $usnick list_pounces\" for a list of pounces."));
				} else {
					irc_send(irc_privmsg($usnick, $nick, "Pounce deleted."));
				}
			}
		} elsif ($cmd eq "list_pounces") {
			$i = 0;
			foreach $pounce(@{$aim_connections{$nnick}{screennames}{$aim_connections{$nnick}{aimnick}}{pounces}}) {
				irc_send(irc_privmsg($usnick, $nick, "$i: $pounce->{who} == $pounce->{what}"));
				$i++;
			}
			irc_send(irc_privmsg($usnick, $nick, "You have no pounces.")) if $i == 0;
		} elsif ($cmd eq "help") {
			$foo = ":$usnick PRIVMSG $nick";
			if($param eq "basics") {
				irc_send("$foo :help - Show this screen.\r\n", 1);
				irc_send("$foo :signon screenname pass - Sign on to AOL Instant Messenger (AIM).  You must do this before any of the other commands.\r\n", 1);
				irc_send("$foo :signoff - Sign off of AIM\.r\n", 1);
				irc_send("$foo :add screenname - Create an IRC nickname for screenname.  Use this to talk to someone who's not on your buddylist.\r\n", 1);
				irc_send("$foo :get_permit_mode - See your current permit mode.\r\n", 1);
				irc_send("$foo :set_permit_mode newmode - Set your permit mode.\r\n", 1);
				irc_send("$foo :list_permit_modes - List the valid permit modes and their definitions.\r\n", 1);
			} elsif($param eq "buddies") {
				irc_send("$foo :NOTE: For the commands that take screenname[,screenname2,...screennameN] as a parameter, you must have only commas between the screennames.\r\n", 1);
				irc_send("$foo :You may NOT have spaces between the screennames!\r\n", 1);
				irc_send("$foo : \r\n", 1);
				irc_send("$foo :add_permit screenname[,screenname2,...,screennameN] - Add screenname (possibly multiple screenname) to your permit list, removing from deny list.\r\n", 1);
				irc_send("$foo :add_deny screenname[,screenname2,...,screennameN] - Add nick (possibly multiple screenname) to your deny list, removing from permit list.\r\n", 1);
				irc_send("$foo :buddyinfo screenname - Get signon time, idle time, evil level, and user class for a buddy.\r\n", 1);
				irc_send("$foo :add_buddy screenname[,screenname2,...,screennameN] [group] - Add screenname (possibly multiple screennames) to your buddy list.  If you give a group, the screenname will be added to that buddy group.\r\n", 1);
				irc_send("$foo :remove_buddy screenname[,screenname2,...,screennameN] - Remove screenname (possibly multiple screennames) from your buddy list.\r\n", 1);
				irc_send("$foo :evil screenname [anon] (or warn screenname [anon]) - Warn screenname, optionally anonymously.\r\n", 1);
				irc_send("$foo :remove_permit screenname[,screenname2,...,screennameN] - Remove screenname (possibly multiple screennames) from permit list.\r\n", 1);
				irc_send("$foo :remove_deny screenname[,screenname2,...,screennameN] - Remove screenname (possibly multiple screennames) from deny list.\r\n", 1);
				irc_send("$foo :onbuddies - List buddies who are currently signed on (and who don't have you on block.)\r\n", 1);
				irc_send("$foo :buddylist - List everyone on your buddylist.\r\n", 1);
				irc_send("$foo :permitlist - See who is on your permit list.\r\n", 1);
				irc_send("$foo :denylist - See who is on your deny list.\r\n", 1);
				irc_send("$foo :savebuddies [OSCAR] - DCC SENDs you a copy of your buddylist.  By default it will be in \"TOC format\" - use the OSCAR parameter for \"OSCAR format\".\r\n", 1) if $dccip;
				irc_send("$foo :loadbuddies - DCC GETs a copy of your buddylist and uses that as your new buddylist.  You must do this before sending the file.\r\n", 1);
				irc_send("$foo : \r\n", 1);
				irc_send("$foo :Note on savebuddies\\loadbuddies: savebuddies will send you a CTCP savebuddies (loadbuddies sends CTCP loadbuddies.\r\n", 1);
				irc_send("$foo :This allows IRC client scripts to be written to automate the sending and receiving of the file.\r\n", 1);
				irc_send("$foo :There are two buddylist formats which savebuddies and loadbuddies understand.\r\n", 1);
				irc_send("$foo :The preferred format, TOC format, is used internally by TOC and most TOC clients will export in this format.\r\n", 1);
				irc_send("$foo :OSCAR format is the format that the Windows AOL Instant Messenger client exports its buddylist in.\r\n", 1);
			} elsif($param eq "chat") {
				irc_send("$foo :join chat_name - Create/join a chatroom called chat_name.\r\n", 1);
				irc_send("$foo :join_exchange exchange chat_name - Create/join a chatroom in a different exchange (see below.)\r\n", 1);
				irc_send("$foo :whisper chat_id user message - Whisper to user in chat chat_id (the chat_id is the number after #aimchat- in the channel name.)\r\n", 1);
				#I don't think AOL has implemented this. --MS
				#irc_send("$foo :chat_evil chat_id nick [anon] (or chat_warn chat_id nick [anon]) - Warn nick inside chat_id, optionally anonymously.\r\n", 1);
				irc_send("$foo : \r\n", 1);
				irc_send("$foo :Note on join_exchange: The default exchange is 4.  However, many AIM chats (including most/all listed in AOL's 'Hot Chats' use exchange 5.\r\n", 1);
				irc_send("$foo : \r\n", 1);
				irc_send("$foo :To invite someone into a chat, use the IRC INVITE command on their AIM- screenname.\r\n", 1);
				irc_send("$foo :Example: /invite AIM-SomeDude #aimchat-1234\r\n", 1);
				irc_send("$foo :Your IRC client might have an easier way to do that - many allow you to omit the channel name when inviting into the channel you are currently in.\r\n", 1);
			} elsif($param eq "misc") {
				irc_send("$foo :get_info screenname - Get info for screenname.\r\n", 1);
				irc_send("$foo :set_profile new profile - Set your profile.  You can use some HTML formating.\r\n", 1);
				irc_send("$foo :get_dir screenname - Get directory info for screenname.\r\n", 1);
				irc_send("$foo :set_dir [info] - Without info, gives you the syntax that info must be in.  With info, sets your directory info.\r\n", 1);
				irc_send("$foo :dir_search [info] - Without info, gets the syntax that info must be in (the same as that of set_dir).  With info, searches the AOL Instant Messenger directory.\r\n", 1);
				irc_send("$foo :sendidle (0|1) - Send the TOC server your idle information?\r\n", 1);
				irc_send("$foo :format_screenname screenname - Change the formatting (capitalization, spaces) of your screenname\r\n", 1);
				irc_send("$foo :change_password old_password new_password - Change your AIM password\r\n", 1);
			} elsif($param eq "debug") {
				if($debug) {
					irc_send("$foo :restart - Restart aimirc.  This will close the IRC connection and all AIM connections and launch a new aimirc process.\r\n", 1);
					irc_send("$foo :newnick nick - Create a new nickname on irc.\r\n", 1);
					irc_send("$foo :setlevel debug_channel level - Set debugging channel debug_channel to level (higher is more verbose, 1 to disable).  The special channel \"all\" will set the level of all channels at once.\r\n", 1);
					irc_send("$foo :showlevels - List all debugging channels and their levels.\r\n", 1);
					irc_send("$foo :rehash - Reload /etc/aimirc.conf and $home/.aimirc .\r\n", 1);
					irc_send("$foo :reload - Evaluates $0.  This should let you make almost any change to Toc.pm or aimirc without having to do a full restart.\r\n", 1);
					irc_send("$foo :raw who text - Send a raw IRC or AIM command (AIM commands are SFLAP-encoded but not quoted.) If who is irc, it will be sent as an IRC command.  If who is the IRC nickname or AIM nickname of someone connected to this aimirc server, text will be sent over that AIM connection.\r\n", 1);
					irc_send("$foo :inject text - Act as though we got text from the IRC server.\r\n", 1);
					irc_send("$foo :eval text - Evaluate text as Perl code.  All exceptions will be trapped and displayed.\r\n", 1);
				} else {
					irc_send("$foo :Debugging support is not enabled.  Edit /etc/aimirc.conf or $home/.aimirc and send SIGHUP to PID $$.\r\n", 1);
				}
			} elsif($param eq "multinick") {
				irc_send("$foo :To sign on multiple AIM screennames under your current IRC connection, just use multiple signon commands.\r\n", 1);
				irc_send("$foo :The first screenname you sign on will be the \"default screenname\".\r\n", 1);
				irc_send("$foo :The default screenname is the screenname which outgoing IMs are sent to and which $usnick commands; such as add_buddy, remove_buddy, and signoff; effect.\r\n", 1);
				irc_send("$foo :Note that messages/whispers to chatrooms will always be sent with the screenname that joined the chatroom.\r\n", 1);
				irc_send("$foo :When you receive an incoming IM on a screenname other than the default one, {screenname} will be prepended to the IM.\t\n", 1);
				irc_send("$foo :multinick commands:\r\n", 1);
				irc_send("$foo :\tlistnames - list screennames that you are signed on as.  Also tells you your default screenname.\r\n", 1);
				irc_send("$foo :\tswitchname screenname - switch to a new default screenname\r\n", 1);
				irc_send("$foo :\tsignoffall - sign off all screennames\r\n", 1);
			#} elsif($param eq "introduction") {
			#	irc_send("$foo :
			} elsif($param eq "pounce") {
				irc_send("$foo :A pounce will automatically send an IM to a buddy when that buddy comes online.\r\n", 1);
				irc_send("$foo :Your pounces will be saved when you sign off but cannot trigger unless you are signed on.\r\n", 1);
				irc_send("$foo :When you sign on, you will be reminded if you have any untriggered pounces.\r\n", 1);
				irc_send("$foo :Each pounce is deleted after it is triggered, so it only will happen once.\r\n", 1);
				irc_send("$foo :Pounce commands:\r\n", 1);
				irc_send("$foo :\tadd_pounce screenname text - Pounce on screenname with a message of text.\r\n", 1);
				irc_send("$foo :\tremove_pounce number - Remove pounce number.  You can find the number for the pounce you wish to remove by doing a list_pounces.\r\n", 1);
				irc_send("$foo :\tlist_pounces - List your remaining pounces.\r\n", 1);
			} else {
				irc_send("$foo :aimirc $version, (c)1999-2000 Matthew Sachs.\r\n", 1);
				irc_send("$foo :aimirc homepage: http://www.zevils.com/linux/aimirc/\r\n", 1);
				irc_send("$foo :This program is licensed under Version 2 the GNU Public License.\r\n", 1);
				irc_send("$foo :A copy of the license is available at http://www.gnu.org/copyleft/gpl.txt\r\n", 1);
				irc_send("$foo :To see the commands available for a specific topic, use the command help topic.  The following topics are available:\r\n", 1);
				irc_send("$foo :\tbasics - basic commands\r\n", 1);
			 	irc_send("$foo :\tbuddies - buddylist manipulation, etc.\r\n", 1);
				irc_send("$foo :\tchat - chatroom commands\r\n", 1);
				irc_send("$foo :\tmisc - miscellaneous commands\r\n", 1);
				irc_send("$foo :\tmultinick - using aimirc with multiple AIM screennames from one IRC connection.\r\n", 1);
				irc_send("$foo :\tpounce - pounce commands and overview\r\n", 1);
				#irc_send("$foo :\tintroduction - introduction to aimirc and AOL Instant Messenger.\r\n", 1);
				irc_send("$foo :NOTE: Remove all spaces from screennames (also referred to as nicknames or nicks) before using in any AIMIRC command or operation.  nick is the AIM nick, not the IRC one created by prepending $prefix.\r\n", 1);
				irc_send("$foo :AIM stands for AOL Instant Messenger, which is a trademark of America Online, Inc.\r\n", 1);
				irc_send("$foo :To send an IM to someone whose screenname is SomeDude, send an IRC message to ${prefix}SomeDude.\r\n", 1);
				irc_send("$foo :That person must be on your buddylist, have sent you an IM recently, or be added to IRC via the add command.\r\n", 1);
				irc_send("$foo : \r\n", 1);
				irc_send("$foo :You need an AOL Instant Messenger account to use aimirc.  Get one at http://aim.aol.com/aimnew/Aim/register.adp\r\n", 1);
			}
		} elsif($cmd eq "webpage") {
			irc_send(irc_privmsg($usnick, $nnick, html2txt(get($param), $nnick))) if $param;
		} elsif($cmd eq "switchname") {
			unless($param) {
				irc_send(irc_privmsg($usnick, $nnick, "Usage: switchname screenname"));
			} else {
				if(switchnick($nnick, normalize $param)) {
					irc_send(irc_privmsg($usnick, $nnick, "You are not signed on under that screenname!"));
				} else {
					irc_send(irc_privmsg($usnick, $nnick, "Your default screenname is now $param."));
				}
			}
		} elsif($cmd eq "signoffall") {
			do_signoff_all($nnick);
		} elsif($cmd eq "listnames") {
			irc_send(irc_privmsg($usnick, $nick, "Your default screenname is $aim_connections{$nnick}{aimnick}."));
			foreach $screenname(keys %{$aim_connections{$nnick}{screennames}}) {
				irc_send(irc_privmsg($usnick, $nick, $screenname));
			}
		} else {
			irc_send(irc_privmsg($usnick, $nick, "Unknown command - /msg $usnick help for help."));
		}
	} elsif(/^PRIVMSG +(\S+)(\@\S+)? +:?(.+)/i) { #$nick sent $3 to $1 (where $1 ne $usnick)
		$target = noprefix($longnicks{normalize($1)}); $msg = $3;
		$recipient = normalize($1);
		$msg = process_ctcp($nnick, normalize $1, $msg);
		return unless $msg;

		if($recipient eq "#aimirc-debug" and $debug) {
			$msg =~ s/^(aimserv)\S*\s+//;
			if($msg eq "restart" and $1) {
				phoenix;
			} elsif($msg =~ /^newnick (.+)/ and $1) {
				irc_send(irc_newnick($1));
			} elsif($msg =~ /^setlevel (\S+) (\S+)/) {
				if($1 eq "all") {
					foreach $level(keys %debug) { $debug{$level} = $2; }
				} else {
					$debug{$1} = $2;
				}
			} elsif($msg =~ /^rehash/) {
				&rehash;
			} elsif($msg =~ /^reload/) {
				&reload;
			} elsif($msg =~ /^showlevels/) {
				foreach $level(keys %debug) { irc_send(irc_privmsg($usnick, "#aimirc-debug", "$level: $debug{$level}")); }
			} elsif($msg =~ /^inject (.+)/ and $1) {
				process_irc_message($1);
			} elsif($msg =~ /^raw (\S+) (.+)/ and $1 and $2) {
				if($1 eq "irc") {
					irc_send("$2\r\n");
				} elsif($aim_connections{$1}) {
					sflap_put($aim_connections{normalize($1)}{socket}, sflap_encode($2, 0, 1));
				} else {
					$success = 0;
					AIMNICK: foreach $nick(keys %aim_connections) {
						$nnick = normalize($nick);
						if(normalize($aim_connections{$nnick}{aimnick}) eq normalize($1)) {
							$success = 1;
							sflap_put($aim_connections{$nnick}{socket}, sflap_encode($2, 0, 1));
							last AIMNICK;
						}
					}
					irc_send(irc_privmsg($usnick, "#aimirc-debug", "Couldn't find that person.")) unless $success;
				}
			} elsif($msg =~ /^eval (.+)/ and $1) {
				eval $1;
				irc_send(irc_privmsg($usnick, "#aimirc-debug", $@, "EVAL: "));
			} else {
				irc_send(irc_privmsg($usnick, "#aimirc-debug", "Invalid debug command - /msg aimserv help debug for help)"));
			}
		} elsif ($recipient =~ /^#aimchat-(\d+)$/) {
			chat_send($aim_connections{$nnick}{screennames}{$chatnames{$1}}{socket}, $1, $msg) if $aim_connections{$nnick};
		} elsif ($recipient !~ /^#/) {
			if($aim_connections{$nnick}) {
				if($irc_connections{$nnick} and $shortcircuit) {
					irc_send(irc_privmsg($aim_connections{$nnick}{aimnick}, $recipient, html2txt(txt2html($msg))));
				} else {
					message($aim_connections{$nnick}{socket}, $target, $msg);
					$nicks{$target}{$nnick} = time if $nicks{$target}{$nnick} != -1;
				}
			} else {
				irc_send(irc_privmsg($usnick, $nick, "You must be signed onto AOL Instant Messenger via aimirc to send messages to AIM users.  /msg AIMServ help for details."));
			}
		}
	} elsif(/^AWAY *(.*)/) {
		if($1 =~ /:?(.*)/) {
			$irc_away{$nnick} = $1;
			if($aim_connections{$nnick}) {
				$aim_connections{$nnick}{away} = $1;
				foreach $screenname(keys %{$aim_connections{$nnick}{screennames}}) {
					set_away($aim_connections{$nnick}{screennames}{$screenname}{socket}, $1);
				}
			}
		} else {
			delete $irc_away{$nnick};
			if($aim_connections{$nnick}) {
				delete $aim_connections{$nnick}{away};
				foreach $screenname(keys %{$aim_connections{$nnick}{screennames}}) {
					delete $aim_connections{$nnick}{screennames}{$screenname}{away_buddies};
					set_away($aim_connections{$nnick}{screennames}{$screenname}{socket});
				}
			}
		}
	} elsif(/^NICK +(\S+)/) { #Nick change
		if($aim_connections{$nnick}) {
			$newnick = normalize($1);
			$aim_connections{$newnick} = $aim_connections{$nnick};
			$aim_connections{$newnick}{nick} = $newnick;
			delete $aim_connections{$nnick};
			foreach $nick(keys %nicks) {
				next unless $nicks{$nick}{$nnick};
				$nicks{$nick}{$newnick} = $nicks{$nick}{$nnick};
				delete $nicks{$nick}{$nnick};
			}
		}
	} elsif(/^QUIT/) {
		delete $irc_away{$nnick};
		do_signoff_all($nnick, 1) if $aim_connections{$nnick};
	} elsif(/^PING/) {
		irc_send("PONG $us\r\n");
	}
}

# Process an incoming TOC message
sub process_aim_message($$$) {
	my ($connection, $msg, $screenname) = @_;
	my($cmd, $val, $inick, $ar, $pounce);
	my($nnick) = normalize($connection->{nick});

	my($multinick, $socket) = ("", $connection->{screennames}{$screenname}{socket});
	$multinick = "{$screenname} " if $screenname ne $connection->{aimnick};

	#warn "AIM got $msg for $connection->{nick}\n";
	$msg =~ /^([^:]+):(.+)/;
	$cmd = $1; $val = $2;
	if($cmd eq "ERROR") {
		$val =~ /([^:]+):?(.*)/;
		Toc::debug_print("Error $1: " . aim_strerror($1, $2), "errors", 1);
		irc_send(irc_privmsg($usnick, $connection->{nick}, "${multinick}Error $1: " . aim_strerror($1, $2)));
	} elsif($cmd eq "DIR_STATUS") {
		if($val == 0) {
			irc_send(irc_privmsg($usnick, $connection->{nick}, "Directory info successfully updated."));
		} else {
			irc_send(irc_privmsg($usnick, $connection->{nick}, "Could not update directory info."));
		}
	} elsif($cmd eq "CONFIG") {
		if(!$msg) {
			irc_send(irc_privmsg($usnick, $connection->{nick}, "Woah there, you have an empty configuration!"));
			irc_send(irc_privmsg($usnick, $connection->{nick}, "Either you've just created this account or AOL lost the buddylists again."));
			if($buddylists{safename $screenname}) {
				irc_send(irc_privmsg($usnick, $connection->{nick}, "Fortunately, we have a backup of your buddylist from the last time you signed on to this aimirc - we'll load that for you."));
				update_config($socket, $buddylists{safename $screenname});
			} elsif($dcc) {
				irc_send(irc_privmsg($usnick, $connection->{nick}, "If you have a copy of your buddylist from the Win/Mac AIM client or from a savebuddies, you can import it via the loadbuddies command - \"/msg $usnick loadbuddies\"."));
			}
		} else {
			$buddylists{safename $screenname} = $msg;
			update_config($socket, $msg);
		}
	} elsif($cmd eq "IM_IN") {
		my $nick;
		$val =~ /([^:]+):(.):(.*)/;
		my $autoflag = $2;
		my $message = $3;
		$inick = $1; $inick =~ tr/ //d;
		$nnick = lc($inick);

		unless($nicks{noprefix $nnick}) {
			irc_send(irc_newnick($prefix . $inick));
		}
		truncwarn($connection->{nick}, $inick) unless $nicks{$nnick}{normalize $connection->{nick}};

		($autoflag eq "T") ? ($ar = "[automatic response] ") : ($ar = "");
		@lines = html2txt($message, $nick);

		foreach $line(@lines) {
			$line = "$multinick$line";
		}

		irc_send(irc_privmsg($prefix . $inick, $connection->{nick}, $ar . $lines[0]));
		shift @lines;
		foreach $line(@lines) {
			irc_send(irc_privmsg($prefix . $inick, $connection->{nick}, "[continued]\t\t$line"));
		}

		if(($ar eq "") and $connection->{away} and (time - $connection->{screennames}{$screenname}{away_buddies}{$nnick} > $time)) {
			my $tmp;
			my %config = deref(get_config($screenname));
			my $class = $config{Buddies}{$nnick}{class};
			if(substr($class, 0, 1) eq "A") {
				$tmp = "[automated reply] " . $connection->{away};
			} else {
				$tmp = $connection->{away};
			}
			message($socket, $nnick, $tmp, 1);
			$connection->{screennames}{$screenname}{away_buddies}{$nnick} = time;
		}
		$nicks{noprefix $nnick}{$connection->{nick}} = time if $nicks{noprefix $nnick}{$connection->{nick}} != -1;
	} elsif($cmd eq "UPDATE_BUDDY") {
		$val =~ /([^:]+):(.):([^:]+):([^:]+):([^:]+):(.+)/;
		$inick = $xinick = $1; $inick =~ tr/ //d;
		$nnick = lc($inick);
		$ircnick = lc($prefix) . $nnick;
		Toc::debug_print("$connection->{nick} UPDATE_BUDDY: $val", "buddies", 1);

		if($2 eq "T") {
			%temp = deref(get_config($screenname));
			{
				local $^W = 0;
				irc_send(irc_privmsg($usnick, $connection->{nick}, "$multinick$xinick has gone away")) if substr($temp{Buddies}{$nnick}{class}, 2, 1) ne "U" and substr($6, 2, 1) eq "U";
				irc_send(irc_privmsg($usnick, $connection->{nick}, "$multinick$xinick is no longer away")) if substr($temp{Buddies}{$nnick}{class}, 2, 1) eq "U" and substr($6, 2, 1) ne "U";
			}

			irc_send(irc_newnick($prefix . $inick)) unless haskeys($nicks{noprefix $nnick});
			unless($temp{Buddies}{$nnick}{online}) {
				truncwarn($connection->{nick}, $inick);
				irc_send(irc_privmsg($usnick, $connection->{nick}, "$multinick$xinick has arrived"));
				$i = -1;
				foreach $pounce(@{$connection->{screennames}{$screenname}{pounces}}) {
					$i++;
					Toc::debug_print("$pounce->{who} eq $nnick?", "IRC", 1);
					next unless normalize $pounce->{who} eq $nnick;
					Toc::debug_print("Yep.", "IRC", 1);
					my $class = $temp{Buddies}{$nnick}{class};
					my $tmp;
					if(substr($class, 0, 1) eq "A") {
						$tmp = "[automated pounce] " . $pounce->{what};
					} else {
						$tmp = $pounce->{what};
					}
					Toc::debug_print("Sending $tmp.", "IRC", 1);
					message($socket, $nnick, $tmp, 1);
					splice(@{$connection->{screennames}{$screenname}{pounces}}, $i, 1);
					splice(@{$pounces{$screenname}}, $i, 1) if $savepounces > 0;
				}
			}
			update_buddy($screenname, $nnick, $6, $3, $4, $5, 1);
			$nicks{noprefix $nnick}{$connection->{nick}} = -1;
		} else {
			update_buddy($screenname, $nnick, $6, $3, $4, $5, 0);
			irc_send(irc_privmsg($usnick, $connection->{nick}, "$multinick$xinick has departed"));
			delete $nicks{noprefix $nnick}{$connection->{nick}};
			unless(haskeys($nicks{noprefix $nnick}) > 1) {
				irc_send(":$prefix$inick QUIT :I signed off of AIM (UPDATE_BUDDY)\r\n");
				delete $nicks{noprefix $nnick};
			}
		}
	} elsif($cmd eq "EVILED") {
		$val =~ /([^:]+):(.*)/;
		$connection->{screennames}{$screenname}{evil} = $1;
		irc_send(irc_privmsg($usnick, $connection->{nick}, $multinick . ($2 || "Anonymous") . " has just evilled you.  Your new evil level is $1%."));
	} elsif($cmd eq "CHAT_JOIN") {
		$val =~ /([^:]+):(.*)/;
		$topic = $2;
		chomp $topic;

		$chattopics{$1} = "{$screenname} $topic";
		$chatnames{$1} = $screenname;
		send_join($usnick, "#aimchat-$1");
		send_server_mode("#aimchat-$1 +o $usnick");
		irc_send(":$usnick MODE #aimchat-$1 +sint\r\n");
		irc_send(":$usnick TOPIC #aimchat-$1 :{$screenname} $topic\r\n");
		irc_send(":$usnick INVITE $connection->{nick} :#aimchat-$1\r\n");
		irc_send(irc_privmsg($usnick, $connection->{nick}, "Join IRC channel #aimchat-$1 to join AIM chat $topic.")) unless $chatinvites{$1};
		delete $chatinvites{$1};
		$longnicks{"#aimchat-$1"} = "#aimchat-$1";
	} elsif($cmd eq "CHAT_IN") {
		my $nick;
		my ($sender, $nsender, $msg, $line, @lines);

		$val =~ /([^:]+):([^:]+):(.):(.*)/;

		$sender = $2;
		$sender =~ tr/ //d;
		$nsender = normalize($sender);

		if(normalize($screenname) ne $nsender) {
			$msg = html2txt($4, $nick);

			if(lc($3) eq "t") {
				Toc::debug_print("$sender whispered to $connection->{nick} in chat $1 ($2): $msg", "chat", 2);
				irc_send(irc_privmsg("$prefix$sender", $connection->{nick}, "(whispered in #aimchat-$1): $msg"));
			} else {
				Toc::debug_print("$sender said to $connection->{nick} in chat $1 ($2): $msg", "chat", 2);
				unless($chatjoined{$1}) {
					$chatqueue{$1} .= irc_privmsg("$prefix$sender", "#aimchat-$1", $msg);
				} else {
					irc_send(irc_privmsg("$prefix$sender", "#aimchat-$1", $msg));
				}
			}
		}
	} elsif($cmd eq "CHAT_UPDATE_BUDDY") {
		my($who, @who);

		$val =~ /([^:]+):(.):(.+)/;
		$who = $3;
		$who =~ tr/ //d;

		@who = split(/:/, $who);
		if(lc($2) eq "t") {
			foreach $who(@who) {
				next if normalize($who) eq $screenname;
				$chats{$1}{$who} = 1;
				irc_send(irc_newnick("$prefix$who"));
				send_join("$prefix$who", "#aimchat-$1");

				$nicks{normalize($who)}{"chat-$1"} = -1;
				truncwarn($connection->{nick}, $who);
			}
		} else {
			foreach $who(@who) {
				next if normalize($who) eq $screenname;
				delete $chats{$1}{$who};
				irc_send(":" . substr("$prefix$who", 0, $ircservers{$servermode}{nicklen}) . " PART #aimchat-$1\r\n");
				delete $nicks{normalize($who)}{"chat-$1"};
			}
		}
	} elsif($cmd eq "CHAT_INVITE") {
		$val =~ /([^:]+):([^:]+):([^:]+):(.*)/;
		Toc::debug_print("$connection->{nick} has been invited to chat $1 ($4) [$2] by $3", "chat", 2);
		$chatinvites{$2} = $connection->{nick};
		$chatnames{$2} = $screenname;
		irc_send(irc_privmsg($usnick, $connection->{nick}, "$3 has invited us to chatroom $1 for the following reason: " . html2txt($4) . ".  To accept, join #aimchat-$2"));
	} elsif($cmd eq "GOTO_URL") {
		$val =~ /[^:]+:(.+)/;
		my $html = get("http://toc-d01.blue.aol.com/$1");
		$html =~ s/<I>Legend:.*//m;
		Toc::debug_print($html, "html", 2);
		irc_send(irc_privmsg($usnick, $connection->{nick}, html2txt($html, $connection->{nick})));
	} elsif($cmd eq "ADMIN_NICK_STATUS") {
		$val =~ /([^:]+):?(.*)/;
		if($1 != 0) {
			irc_send(irc_privmsg($usnick, $connection->{nick}, "Nick status - return code $1 (params $2)"));
		} else {
			irc_send(irc_privmsg($usnick, $connection->{nick}, "Nickname successfully reformatted."));
		}
	} elsif($cmd eq "ADMIN_PASSWD_STATUS") {
		$val =~ /([^:]+):?(.*)/;
		if($1 != 0) {
			irc_send(irc_privmsg($usnick, $connection->{nick}, "Password status - return code $1 (params $2)"));
		} else {
			irc_send(irc_privmsg($usnick, $connection->{nick}, "Password successfully changed."));
		}
	}
}

# Convert HTML into text suitable for IRC
sub html2txt($;$) {
	my ($msg, $nick, $parsetree, @lines, $formatter) = @_;
	my($linkct, $link, $elem, $node) = 0;

	$parsetree = HTML::TreeBuilder->new;
	$parsetree->{_ignore_unknown} = 0;
	$parsetree->parse($msg);
	$parsetree->eof;

	$formatter = new HTML::FormatAIMIRC (leftmargin => 0, rightmargin => 4096);
	$formatter->{_original_html} = $msg; #We use this to determine whether to add a closing tag for "unknown tags"
	$msg = $formatter->format($parsetree);
	$parsetree->delete;
	return $msg;
}

# Debugging
sub Toc::debug_print($$$) {
	my($text, $type, $level) = @_;
	my($line, @lines);

	return unless $debug;
	return if defined($debug{$type}) and $level > $debug{$type};

	if($aimircdebug and $debug < 2) {
		@lines = split(/[\r\n]+/, $text);

		foreach $line(@lines) {
			irc_send(":$usnick PRIVMSG #aimirc-debug :($type, $level) $line\r\n", 1);
		}
	} else {
		chomp $text;
		print STDERR "$text\n";
	}
}

# Send something to IRC
sub irc_send($;$) {
	my ($msg, $nodbg) = @_;

	return unless $msg;

	Toc::debug_print("To IRC  : $msg", "irc", 2) unless $nodbg;
	undef $rv;
	$! = EAGAIN;
	while(!defined($rv) && $! == EAGAIN) {
		$rv = $upstream->syswrite($msg, length $msg);
		if($rv != length $msg) {
			substr($msg, 0, $rv) = "";
			undef $rv;
			$! = EAGAIN;
		} elsif(!defined($rv) && $! != EAGAIN) {
			die "Couldn't write to IRC: $!";
		}
	}
	return 1;
}

# Dereference a hashref
sub deref($) {
	my $href = shift;
	return %$href;
}

# Reload the configuration file
sub rehash() {
	irc_send(irc_privmsg($usnick, "#aimirc-debug", "Rehashing..."));
	if(-r "/etc/aimirc.conf") {
		do "/etc/aimirc.conf";
		$@ =~ tr/\r//d;
		irc_send(irc_privmsg($usnick, "#aimirc-debug", $@, "EVAL: "));
		if($@) {
			irc_send(irc_privmsg($usnick, "#aimirc-debug", "Couldn't reload /etc/aimirc.conf - there were errors."));
		} else {
			irc_send(irc_privmsg($usnick, "#aimirc-debug", "Reloaded /etc/aimirc.conf"))
		}
	} else {
		irc_send(irc_privmsg($usnick, "#aimirc-debug", "Not loading /etc/aimirc.conf - couldn't read"));
	}
	if(-r "$home/.aimirc") {
		do "$home/.aimirc" if -r "$home/.aimirc";
		irc_send(irc_privmsg($usnick, "#aimirc-debug", $@, "EVAL: "));
		if($@) {
			irc_send(irc_privmsg($usnick, "#aimirc-debug", "Couldn't reload $home/.aimirc - there were errors."));
		} else {
			irc_send(irc_privmsg($usnick, "#aimirc-debug", "Reloaded $home/.aimirc"))
		}
	} else {
		irc_send(irc_privmsg($usnick, "#aimirc-debug", "Not loading $home/.aimirc - couldn't read"));
	}
	irc_send(irc_privmsg($usnick, "#aimirc-debug", "Rehash complete!"));
}

# Re-eval aimirc
sub reload() {
	irc_send(irc_privmsg($usnick, "#aimirc-debug", "Reloading $0..."));
	$reload = 1;
	local $SIG{__DIE__} = sub { $@ = shift; };
	do $0;
	irc_send(irc_privmsg($usnick, "#aimirc-debug", $@, "EVAL: "));
	if($@) {
		irc_send(irc_privmsg($usnick, "#aimirc-debug", "Couldn't reload $0 - there were errors."));
	} else {
		irc_send(irc_privmsg($usnick, "#aimirc-debug", "Reload complete!"));
	}
}

# Display version information
sub dispver() {
	print "aimirc: IRC <-> AOL Instant Messenger gateway.\n";
	print "AOL Instant Messenger, AOL, and America Online are trademarks of America Online, Inc.\n";
	print "Version: $VERSION\n";
	print "Use $0 --help for command-line options.\n";
	print "Use $0 --license to see the license (GPL v2)\n";
	exit 0;
}

# Dispaly licensing info
sub license() { print $license; exit 0; }

# Display commandline help
sub help() {
	print <<EOF
aimirc - IRC <-> AOL Instant Messenger gateway
AOL Instant Messenger, AOL, and America Online are trademarks of America Online, Inc.
Version $VERSION

Usage: $0 [--version] [--license] [--help] [--config conffile] [--config conffile] ...

You can use either the short or long forms with one or two dashes in
whatever combination you want.  However, you can't combine options as in
$0 -VC.

	--version, -V:			Display version information and exit

	--license:			Display license information and exit

	--help, -h:			Print this message and exit

	--config, -C:			Specify configuration files to use.
					This option overrides the default
					configuration file locations.
					You may specify this option multiple
					times to use multiple configuration
					files.

This is also an option for every directive in the configuration file.
The options have the same names as the directives, but prefix them with
two dashes (--) instead of the Perl variable type identifies (\$\@\%).

See the included README file for more information.
EOF
;
	exit 0;
}

# Sign on to AIM
sub do_signon($$$$) {
	my($tparam, $textra, $tusnick, $tnick, $nparam, %temp, @ret, $flags, $nnick, %config) = @_;

	$nparam = normalize($tparam);
	$nnick = normalize($tnick);

	if($verbose_signon) {
		@ret = signon $nparam, $textra, \&socksub, sub { irc_send(irc_privmsg($tusnick, $tnick, $_[0])) };
	} else {
		@ret = signon $nparam, $textra, \&socksub;
	}
	%config = deref(get_config($nparam));
	if($ret[0] == 0) {
		$aim_connections{$nnick}{nick} = $nnick;
		$aim_connections{$nnick}{screennames}{$nparam}{socket} = $ret[1];
		$aim_connections{$nnick}{screennames}{$nparam}{permtype} = $ret[2]->{permtype};
		$aim_connections{$nnick}{screennames}{$nparam}{report_idle} = $sendidle;
		$aim_connections{$nnick}{screennames}{$nparam}{idletime} = time;
		$aim_connections{$nnick}{screennames}{$nparam}{is_idle} = 0;
		$aim_connections{$nnick}{aimnick} ||= $nparam;
		$irc_connections{$nparam} = $nnick;

		switchnick($nnick, $nparam) if $aim_connections{$nnick}{aimnick} eq $nparam;
		%temp = %{$ret[2]};

		irc_send(irc_privmsg($tusnick, $nnick, "You are now connected to AOL Instant Messenger as $nparam."));

		unless($nicks{$nparam}) {
			irc_send(irc_newnick($prefix . $tparam));
		}
		$nicks{$nparam}{$nnick} = -1;

		if(not $config{gotconf}) {
			irc_send(irc_privmsg($usnick, $connection->{nick}, "Woah there, you have an empty configuration!"));
			irc_send(irc_privmsg($usnick, $connection->{nick}, "Either you've just created this account or AOL lost the buddylists again."));
			if($buddylists{safename $screenname}) {
				irc_send(irc_privmsg($usnick, $connection->{nick}, "Fortunately, we have a backup of your buddylist from the last time you signed on to this aimirc - we'll load that for you."));
				update_config($socket, $buddylists{safename $screenname});
			} elsif($dcc) {
				irc_send(irc_privmsg($usnick, $connection->{nick}, "If you have a copy of your buddylist from the Win/Mac AIM client or from a savebuddies, you can import it via the loadbuddies command - \"/msg $usnick loadbuddies\"."));
			}
		} else {
			$buddylists{safename $screenname} = conf2str(%config);
		}
		if($irc_away{$nnick}) {
			$aim_connections{$nnick}{away} = $irc_away{$nnick};
			set_away($aim_connections{$nnick}{screennames}{$nparam}{socket}, $irc_away{$nnick});
		}
		if($pounces{safename $nparam}) {
			$aim_connections{$nnick}{screennames}{$nparam}{pounces} = $pounces{safename $nnick};
			irc_send(irc_privmsg($usnick, $nnick, "You have " . scalar @{$pounces{safename $nnick}} . " pounces.")) if scalar @{$pounces{safename $nnick}};
		}
		if($profiles{safename $nparam}) {
			set_info($aim_connections{$nnick}{screennames}{$nparam}{socket}, $profiles{safename $nnick});
			irc_send(irc_privmsg($usnick, $nnick, "Your profile has been set."));
		}
	} else {
		irc_send(irc_privmsg($tusnick, $nnick, $err));
	}
}

# Signoff a particular screenname
sub do_signoff($$;$) {
	my ($nick, $connection, $already_off, $xnick, $nparam, %config) = @_;

	$nparam = safename Toc::_hnick($connection);
	if($nparam and $savebuddies > 0) {
		%config = deref(get_config($aim_connections{Toc::_hnick($connection)}));
		$buddylists{$nparam} = conf2str(%config);
	}

	delete $irc_connections{Toc::_hnick($connection)};
	foreach $xnick(keys %nicks) {
		delete $nicks{$xnick}{$nick};
		next if normalize $xnick eq normalize $usnick;
		irc_send(":$prefix$xnick QUIT :I signed off of AIM (do_signoff)\r\n") unless haskeys($nicks{$xnick}) > 1;
	}

	delete $aim_connections{$nick}{screennames}{Toc::_hnick($connection)};

	if(UNIVERSAL::isa($connection, "IO::Socket::INET")) {
		delete $aim_connections{$connection->fileno};
		signoff($connection);
	}
	if($aim_connections{$nick}) {
		irc_send(irc_privmsg($usnick, $nick, "You have been signed off of AOL Instant Messenger as " . Toc::_hnick($connection))) unless $already_off;
		if(haskeys $aim_connections{$nick}{screennames}) {
			$xnick = (keys %{$aim_connections{$nick}{screennames}})[0];
			irc_send(irc_privmsg($usnick, $nick, "Your new default screenname is $xnick."));
			switchnick($nick, $xnick);
		} else {
			delete $aim_connections{$nick};
		}
	}
}

# We use this so we can handle both SSL and non-SSL.
sub socksub {
	if($ssl) {
		SSLv3->new(
			PeerAddr => $tocserver,
			PeerPort => $tocport,
			SSL_verify_mode => 0x00,
		);
	} else {
		IO::Socket::INET->new(
			PeerAddr => $tocserver,
			PeerPort => $tocport,
		);
	}
}

# Send mode as if it's coming from the server
sub send_server_mode($) {
	my $mode = shift;

	$mode = "MODE $mode";
	$mode .= " " . time if $servermode ne "ts";
	$mode .= "\r\n";
	irc_send($mode);
}

# Join a channel
sub send_join($$) {
	my($user, $channel, $ret) = @_;

	irc_newnick($user);
	$user = substr($user, 0, $ircservers{$servermode}{nicklen});

	if($servermode eq "ts") {
		$user = "\@$user" if normalize($user) eq normalize($usnick);
		$ret = "SJOIN " . time . " $channel + :$user\r\n";
	} else {
		$ret = ":$user JOIN $channel\r\n";
	}

	irc_send($ret);
}

# Receive a message from IRC
sub irc_recv(;$) {
	$noblock = $_[0];

	undef $rv;
	$! = EAGAIN;

	while(not $getbuff[0] and $! == EAGAIN and !defined($rv)) {
		$buff = ' ' x 512;
		$rv = $upstream->sysread($buff, 512);
		die "Couldn't read from IRC: $!" if !defined($rv) && $! != EAGAIN;
		if($! != EAGAIN) {
			#print STDERR "Reading from IRC...\n";
			if($incbuff) {
				$buff = "$incbuff$buff";
				undef $incbuff;
			}
			unless($buff =~ /\n$/) {
				$idx = rindex($buff, "\n") + 1;
				$incbuf = substr($buff, $idx, length $buff - $idx + 1, "");
			}
			push @getbuff, split(/[\r\n]+/, $buff);
			#print STDERR "Getbuff is " . join("\n", @getbuff);
			#print STDERR "\n";
		}
		last if $noblock;
	}
	$ret = shift @getbuff;
	Toc::debug_print("From IRC: $ret", "irc", 2) if $ret;
	#print STDERR "Returning $ret\n";

	return $ret;
}

# Warn if a screenname is being truncated due to IRC max nicklen
sub truncwarn($$) {
	my($who, $what) = @_;

	irc_send(irc_privmsg($usnick, $who,
		"\02WARNING\02: Screenname $what has been truncated to IRC nickname " . $shortnicks{noprefix $what}))

		if noprefix($shortnicks{noprefix($what)}) ne normalize($what);
}

# Switch the default screenname for an IRCnick
sub switchnick($$) {
	my($nnick, $nparam) = @_;
	my $oldnick = $aim_connections{$nnick}{aimnick};

	return 1 unless $aim_connections{$nnick}{screennames}{$nparam};

	$aim_connections{$nnick}{aimnick} = $nparam;
	$aim_connections{$nnick}{socket} = $aim_connections{$nnick}{screennames}{$nparam}{socket};

	return 0;
}

# Clean up nicknames, send keepalives/idle, checkpoint, etc.
sub timestuff() {
	$lasttime = $currtime;
	Toc::debug_print("Reaping nicks...", "nicks", 3);
	ANICK: foreach $anick(keys %nicks) {
		next if normalize($anick) eq normalize($usnick);
		next if $anick =~ /^chat-\d+/;
		$kill = 1;
		Toc::debug_print("\tSO WE MEET AGAIN, $anick.", "nicks", 3);
		foreach $bnick(keys %{$nicks{$anick}}) {
			next if $bnick eq $usnick;
			Toc::debug_print("\t\t$bnick was using $anick...", "nicks", 3);
			next ANICK if $kill == 0;
			if($nicks{$anick}{$bnick} == -1) {
				$kill = 0;
				Toc::debug_print("\t\t\tpermenantly.", "nicks", 3);
			} elsif (($currtime - $nicks{$anick}{$bnick}) < 3600) {
				$kill = 0;
				Toc::debug_print("\t\t\tsince " . $currtime - $nicks{$anick}{$bnick} . " seconds ago.", "nicks", 3);
			}
		}
		if($kill == 1) {
			delete $nicks{$anick};
			irc_send(":$prefix$anick QUIT :Waah, nobody wants me (reaped)\r\n");
			Toc::debug_print("\t$anick, HAVE A NICE AFTERLIFE. ($anick reaped)", "nicks", 1);
		} else {
			Toc::debug_print("\t$anick, YOU LIVE FOR NOW.", "nicks", 3);
		}
	}

	#Part from the chat-channels that we joined in response to someone joining a #aimchat-1234 without being invited or doing an AIMServ join
	foreach $chattimer(keys %chattimer) {
		if(($currtime - $chattimer{$chattimer}) >= 60) {
			irc_send(":$usnick PART #aimchat-$chattimer\r\n");
			delete $chattimer{$chattimer};
		}
	}


	#Only send idle/keepalive packets every other time through the loop
	if($keepalive) {
		foreach $connection(keys %aim_connections) {
			foreach $screenname(keys %{$aim_connections{$connection}{screennames}}) {
				next unless $screenname;
				if($aim_connections{$connection}{screennames}{$screenname}{socket}) {
					if(sflap_keepalive($aim_connections{$connection}{screennames}{$screenname}{socket}) == -1) {
						irc_send(irc_privmsg($usnick, $aim_connections{$connection}{nick}, "There was an error with your AOL Instant Messenger connection for screenname $screenname: $err"));
						do_signoff($aim_connections{$connection}{nick}, $aim_connections{$connection}{screennames}{$screenname}{socket});
					} else {
						if($aim_connections{$connection}{screennames}{$screenname}{report_idle} and not $aim_connections{$connection}{screennames}{$screenname}{is_idle} and ($currtime - $aim_connections{$connection}{screennames}{$screenname}{idletime}) >= 360) {
							if(set_idle($aim_connections{$connection}{screennames}{$screenname}{socket}, $currtime - $aim_connections{$connection}{screennames}{$screenname}{idletime}) == -1) {
								irc_send(irc_privmsg($usnick, $aim_connections{$connection}{nick}, "There was an error with your AOL Instant Messenger connection for screenname $screenname: $err"));
								do_signoff($aim_connections{$connection}{nick}, $aim_connections{$connection}{screennames}{$screenname}{socket});
							} else {
								$aim_connections{$connection}{screennames}{$screenname}{is_idle} = 1;
							}
						}
					}
				} else {
					irc_send(irc_privmsg($usnick, $aim_connections{$connection}{nick}, "There was an error with your AOL Instant Messenger connection for screenname $screenname: $err"));
					do_signoff($aim_connections{$connection}{nick}, undef);
				}
			}
		}
		$keepalive = 0;
	} else {
		$keepalive = 1;
	}

	if($currtime - $checktime >= $checkpoint*60 and $checkpoint > 0) {
		checkpoint;
	}
}

# Signoff all screennames for a particular IRCnick
sub do_signoff_all($;$) {
	my ($nnick, $already_off) = @_;

	foreach $screenname(keys %{$aim_connections{$nnick}{screennames}}) {
		do_signoff($nnick, $aim_connections{$nnick}{screennames}{$screenname}{socket}, 1);
	}
	irc_send(irc_privmsg($usnick, $nick, "All connections signed off of AOL Instant Messenger.")) unless $already_off;
	delete $aim_connections{$nnick};
}

# Notify signed-on users that we're going down
sub going_down() {
	my ($user, @users) = (undef, keys %aim_connections);

	checkpoint unless $did_checkpoint;
	$did_checkpoint = 1;
	foreach $user(@users) {
		next if $aim_connections{$user}{notified}++;
		irc_send(irc_privmsg($usnick, $user, "aimirc is going down.  You have been signed off of AOL Instant Messenger."));
	}
}

# Encode a message for CTCPing - you must still irc_send(":$sender PRIVMSG $target :$this")
sub irc_ctcp_quote($) {
	my($delim, $null) = (chr(001), chr(000));
	my $message = shift;

	$message =~ s/\\/\\\\/g;
	$message =~ s/$delim/\\a/g;
	$message =~ s/\n/\\\n/g;
	$message =~ s/\r/\\\r/g;
	$message =~ s/$null/\\$null/g;
	$message =~ s/:/\\/g;
	return $message;
}

# Decode an incoming CTCP
sub irc_ctcp_unquote($) {
	my($delim, $null) = (chr(001), chr(000));
	my $message = shift;

	$message =~ s/\\\\/\\/g;
	$message =~ s/\\a/$delim/g;
	$message =~ s/\\\n/\n/g;
	$message =~ s/\\\r/\r/g;
	$message =~ s/\\$null/$null/g;

	return $message;
}

# Process an incoming IRC command for CTCPs
sub process_ctcp($$$) {
	my($from, $to, $message) = @_;
	my ($delim, @ctcp, $ctcp, $cmd, $args) = (chr(001));
	my($filename, $ipaddr, $port, $filesize, $socket, $buff);

	return $message unless $message =~ /$delim/;

	@ctcp = map { $_ = irc_ctcp_unquote $_; Toc::debug_print("CTCP: $_", "ctcp", 2) if $_; $_; } split(/$delim+/, $message);
	shift @ctcp;
	$message =~ s/$delim.*//g;
	Toc::debug_print("After CTCP: $message", "ctcp", 2);

	CTCP: foreach $ctcp(@ctcp) {
		$ctcp =~ /^(\S+) ?(.*)$/;
		$cmd = $1; $args = $2;

		Toc::debug_print("Processing CTCP $ctcp: command $cmd", "irc", 2);
		irc_send(irc_ctcp($to, $from, $ctcp, 1)) if $cmd eq "PING";
		$message .= "\02ACTION\02 $args" if $cmd eq "ACTION"; #If you "/me runs" an AIMer, it'll turn into "<B>ACTION</B> runs".  Anyone got any better ideas?
		if($cmd eq "DCC") {
			($cmd, $args) = split(/ /, $args, 2);
			if($cmd eq "SEND") {
				if(not $dccget{$from}) {
					irc_send(irc_privmsg($to, $from, "I'm not accepting DCCs from you at this time."));
					next CTCP;
				}
				$args =~ /(.+)\s+(\d+)\s+(\d+)\s+(\d+)/; #Handles spaces in filename
				($filename, $ipaddr, $port, $filesize) = ($1, $2, $3, $4);
				if($dccget{$from} eq "loadbuddies" and $filesize > 4096) {
					irc_send(irc_privmsg($to, $from, "Sorry, I won't accept buddylists larger than 4k."));
					delete $dccget{$from};
					next CTCP;
				} else {
					$socket = IO::Socket::INET->new(
						PeerAddr => $ipaddr,
						PeerPort => $port,
						Timeout => 5
					);
					unless($socket) {
						irc_send(irc_privmsg($to, $from, "Couldn't receive your DCC: $@"));
						next CTCP;
					}
					$flags = '';
					fcntl($socket, F_GETFL, $flags) or die "Couldn't get flags for DCC socket: $!";
					$flags |= O_NONBLOCK;
					fcntl($socket, F_SETFL, $flags) or die "Couldn't set flags for DCC socket: $!";
					push @dccqueue, {socket => $socket, size => $filesize, what => $dccget{$from}, from => $from, to => $to, got => 0, direction => "GET", buff => "", screenname => $aim_connections{$from}{aimnick}};
					delete $dccget{$from};
					irc_send(irc_privmsg($to, $from, "Okay, I'll get your DCC of $filename."));
				}
			}
		}
	}
	return $message;
}

# Like irc_privmsg
sub irc_ctcp($$$;$) {
	my($from, $to, $message, $reply) = @_;
	my $delim = chr(001);

	return ":$from " . ($reply ? "NOTICE" : "PRIVMSG") . " $to :$delim" . irc_ctcp_quote($message) . "$delim\r\n";
}

#Someone's sending us a file: DCC SEND filename IPaddr port filesize

sub loadbuddies($$) {
	my($socket, $buff) = @_;
	my($permtype, $line, @sections, $var, $val, $conf, $buddy);

	if($buff !~ /^Buddy {$/m) { #TOC-style
		update_config($socket, $buff);
		set_config($socket, get_config(Toc::_hnick($socket)));
		return 1;
	} else {
		foreach $line(split(/[\r\n]+/, $buff)) {
			if($line =~ /^\s*(\S+) {\s*/) {
				push @sections, $1;
			} elsif($line =~ /^\s*}\s*$/) {
				pop @sections;
			} else {
				$line =~ /^\s*(\S+)\s*(.*?)\s*$/;
				$var = $1; $val = $2;
				if(lc($sections[0]) eq "buddy" and lc($sections[1]) eq "list") {
					if($val) {
						$conf .= "g $var\n";
						while($val =~ s/\"(.+?)\"//g) {
							($buddy = $1) =~ tr/ //d;
							$val .= " $buddy";
						}
						Toc::debug_print("Got buddylist group $var = $val", "config", 3);
						foreach $buddy(split(/\s+/, $val)) {
							Toc::debug_print("\tAdding $buddy to group", "config", 3);
							$conf .= "b $buddy\n";
						}
					}
				} elsif(lc($sections[0] eq "Privacy")) {
					if(lc($var) eq "allowlist" and $val) {
						while($val =~ s/\"(.+?)\"//g) {
							($buddy = $1) =~ tr/ //d;
							$val .= " $buddy";
						}
						Toc::debug_print("Got permit list = $val", "config", 3);
						foreach $buddy(split(/\s+/, $val)) {
							Toc::debug_print("\tAdding $buddy to permit list", "config", 3);
							$conf .= "p $buddy\n";
						}
					} elsif(lc($var) eq "denylist" and $val) {
						while($val =~ s/\"(.+?)\"//g) {
							($buddy = $1) =~ tr/ //d;
							$val .= " $buddy";
						}
						Toc::debug_print("Got deny list = $val", "config", 3);
						foreach $buddy(split(/\s+/, $val)) {
							Toc::debug_print("\tAdding $buddy to deny list", "config", 3);
							$conf .= "d $buddy\n";
						}
					} elsif(lc($var) eq "pref") {
						Toc::debug_print("Permit mode is $val", "config", 3);
						if(lc($val) eq "allowall") {
							$conf .= "m 1\n";
						} elsif(lc($val) eq "denyall") {
							$conf .= "m 2\n";
						} elsif(lc($val) eq "allowsome") {
							$conf .= "m 3\n";
						} else {
							$conf .= "m 4\n";
						}
					}
				}
			}
		}
		if($conf) {
			update_config($socket, $conf);
			set_config($socket, get_config(Toc::_hnick($socket)));
			return 1;
		} else {
			return 0;
		}
	}

}

# DCC send a file to someone - you must irc_send this!  Returns the empty string on error.
sub irc_dcc($$$$$) {
	my($from, $to, $what, $why, $filename, $msg, $flags, $socket) = @_;

	if(!$dccip) {
		irc_send(irc_privmsg($from, $to, "The administrator of this server has not configured an IP to use for DCC, so DCC SEND has been disabled."));
		return "";
	}

	$socket = IO::Socket::INET->new(
		LocalPort => 0,
		Listen => 1,
		Proto => 'tcp',
		LocalAddr => $dccip,
		Timeout => 5
	);

	unless($socket) {
		irc_send(irc_privmsg($from, $to, "Couldn't create DCC socket: $@"));
		return "";
	} else {
		$flags = '';
		if(!fcntl($socket, F_GETFL, $flags)) {
			irc_send(irc_privmsg($from, $to, "Couldn't get flags for DCC socket: $!"));
			return "";
		}
		$flags |= O_NONBLOCK;
		if(!fcntl($socket, F_SETFL, $flags)) {
			irc_send(irc_privmsg($from, $to, "Couldn't set flags for DCC socket: $!"));
			return "";
		}

		#We set {put} to -1 to indicate that the client hasn't connected yet.
		push @dccqueue, {ssocket => $socket, size => length($what), what => $why, from => $from, to => $to, put => -1, direction => "SEND", buff => $what};
		Toc::debug_print("DCC SEND buff: $what", "DCC", 3);
		return irc_ctcp($from, $to, "DCC SEND $filename " . unpack("N", inet_aton($dccip)) . " " . $socket->sockport . " " . length($what));
	}
}

# Make a screenname safe to be used in a filename.
# This is probably not needed, but just because you're paranoid it doesn't
# meant they're not out to get you.
sub safename($) {
	my($dangerous_name) = shift;
	$dangerous_name =~ tr!<>|/\0!!d;
	return $dangerous_name;
}

sub checkpoint() {
	if(-d $directory and -w $directory) {
		if($savebuddies > 1) {
			mkdir("$directory/buddylists", 0700) if not -d "$directory/buddylists";
			foreach $screenname(keys %buddylists) {
				open(BUDDYLIST, ">$directory/buddylists/$screenname");
				print BUDDYLIST $buddylists{$screenname};
				close BUDDYLIST;
			}
		}
		if($saveprofiles > 1) {
			mkdir("$directory/profiles", 0700) if not -d "$directory/profiles";
			foreach $screenname(keys %profiles) {
				open(PROFILE, ">$directory/profiles/$screenname");
				print PROFILE $profiles{$screenname};
				close PROFILE;
			}
		}
		if($savepounces > 1) {
			mkdir("$directory/pounces", 0700) if not -d "$directory/pounces";
			foreach $screenname(keys %pounces) {
				open(POUNCES, ">$directory/pounces/$screenname");
				foreach $pounce(@{$pounces{$screenname}}) {
					print POUNCES "$pounce->{who} $pounce->{what}\n";
				}
				close POUNCES;
			}
		}
	} else {
		print STDERR "Warning!  $directory is unwritable - not checkpointing.\n";
		Toc::debug_print("Warning!  $directory is unwritable - not checkpointing.", "errors", 1);
	}
}

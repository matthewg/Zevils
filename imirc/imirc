#!/usr/bin/perl

#See README for licensing/copyright information.

sub BEGIN {
	require File::Basename;
	push @INC, File::Basename::dirname($0);
}

#use Thread qw(async);
use IO::Handle;
use IO::Socket;
use IO::Select;
use POSIX;
use Toc qw(:all);
use Carp;
$Carp::Verbose = 1;

undef $@;
eval {
	require HTML::FormatText;
	require HTML::Parse;
};

if($@) {
	print STDERR "You do not have the HTML::FormatText and HTML::Parse modules installed.\n";
	print STDERR "There are at least three possible ways to install these modules:\n";
	print STDERR "1) [preferred] Get them as a package from your OS vendor or Linux distributor.\n";
	print STDERR "        In Debian, you can install the libhtml-tree-perl package.\n";
	print STDERR "        I'm not sure about anything else.\n";
	print STDERR "2) Use the CPAN module to install it.  Run perl -MCPAN -e shell and \n";
	print STDERR "        type install HTML::Tree when you get to the CPAN prompt.\n";
	print STDERR "3) Download the source from CPAN and install it.  The source is located\n";
	print STDERR "        at http://www.perl.com/CPAN/modules/by-module/HTML/ in a file\n";
	print STDERR "        called HTML-Tree-VERSION.tar.gz where VERSION is the latest version\n";
	print STDERR "        of HTML-Tree.\n";
	die "\n";
}

$SIG{__DIE__}  = sub { croak $_[0] };

$home = (getpwuid($>))[7];

#Defaults
$prefix = "AIM-";
$usnick = "AIMServ";
$us = "aimserv.matthewg.port.net"; #IRC server name to claim to be
$them = "127.0.0.1"; #Hostname of IRC server to connect to
$themport = 6667;
$ourpass = "foo";
$theirpass = "bar";
$servermode = "dal2";  #Should be either dal2 or dragonfire.
			#You can try something else, but I don't think the
			#default method works.

require "/etc/aimirc.conf" if -r "/etc/aimirc.conf";
require "$home/.aimirc" if -r "$home/.aimirc";
$version = "0.80";

@args = @ARGV;


%ircservers = (
	dal2 => {
		nick => "NICK _NICK_ 1 _TIME_ _USER_ $us $us 0 :AOL Instant Messenger client via aimirc\r\n",
		server => "SERVER $us 1 :AOL Instant Messenger services\r\n",
		uspass => 1,
		theirpass => 1,
		nicklen => 30
	},
	dragonfire => {
		nick => "NICK _NICK_ 1 _TIME_ _USER_ $us $us :AOL Instant Messenger client via aimirc\r\n",
		server => "SERVER $us 1 :AOL Instant Messenger services\r\n",
		uspass => 1,
		theirpass => 1,
		nicklen => 10
	},
	ircu => {
		nick => ":$us NICK _NICK_ 1 _TIME_ _USER_ $us $us :AOL Instant Messenger services\r\n",
		server => "SERVER $us 1 _TIME_ _TIME_ PO9 AIM Services\r\n",
		uspass => 1,
		theirpass => 1,
		nicklen => 9
	},
	rfc => {
		nick => ":$us NICK _NICK_ 1\r\n:_NICK_ USER _USER_ $us $us :AOL Instant Messenger client via aimirc\r\n",
		server => "SERVER $us 1 :AOL Instant Messenger serices\r\n",
		uspass => 1,
		theirpass => 1,
		nicklen => 9
	}
);


#We don't need no stinking ampersands!
$pid = fork;
exit if $pid;
die "Couldn't fork: $!" unless defined($pid);

POSIX::setsid() or die "Can't start a new session: $!";
sub kill_handler {
	$upstream->close;
	foreach $connections(keys %$aim_connections) {
		$connections->{socket}->close;
	}
	exit 1;
}

$SIG{INT} = $SIG{TERM} = \&kill_handler;

#Restart on SIGHUP
sub phoenix {
	$upstream->close;
	foreach $key(keys %aim_connections) {
		$aim_connections{$key}{socket}->close if $aim_connections{$key}{socket};
	}
	exec($0, @args);
}
$SIG{HUP} = \&phoenix;


#Hello Mort!
sub REAPER {
	1 until (-1 == waitpid(-1, WNOHANG));
	$SIG{CHLD} = \&REAPER;
}
$SIG{CHLD} = \&REAPER;

#Connect

#enc: `sflap encode buflen (1 iff TYPE_SIGNON else 0) seqno`
#dec: `sflap decode`

$| = 1;

$upstream = IO::Socket::INET->new("$them:$themport");
do { $upstream->print("PASS $ourpass :1\r\n") if $ourpass and $ircservers{$servermode}{uspass}; } or die "Couldn't send PASS: $@\n";
$upstream->print(irc_subparms($ircservers{$servermode}{server})) or die "Couldn't send PASS: $@\n";

if($theirpass and $ircservers{$servermode}{theirpass}) {
	while(($in !~ /PASS (.+) :1/)) {
		chomp($in = $upstream->getline);
		warn "$in\n" if $debug >= 2;
	}
	
	$in =~ /^PASS (.+) :1/;
	$pass = $1;
	$pass =~ s/\s*//g;	#Remove spaces from crypted password
	if($pass ne $theirpass and $pass ne crypt($theirpass, substr($pass, 0, 2))) { die("Upstream server gave the wrong password!\n"); }
}

if($servermode eq "dal2") {
	while($in !~ /EBURST/) {
		chomp($in = $upstream->getline);
		warn "$in\n" if $debug >= 2;
	}
}

$upstream->print(irc_newnick($usnick)) or die "Couldn't make aimserv: $@\n";
$upstream->print(":$us MODE $usnick +o\r\n");

$aimselect = IO::Select->new();
$ircselect = IO::Select->new();
$ircselect->add($upstream);

if($debug) {
	$upstream->print(":$usnick JOIN #aimirc-debug\r\n");
	$upstream->print(":$us MODE #aimirc-debug +nk $ourpass\r\n");
}

while(1 == 1) {
	exit(255) unless $upstream;
	@aims = $aimselect->can_read(.01);
	foreach $aim(@aims) {
		$connection = $aim_connections{$filenos[$aim->fileno]};
		process_aim_message($connection);
	}
	@aims = $aimselect->has_error(.01);
	foreach $aim(@aims) {
		$connection = $aim_connections{$filenos[$aim->fileno]};
		$fileno = $aim->fileno;
		irc_send(irc_privmsg($usnick, $connection->{nick}, "You have been signed off of AIM.")) if $connection;
		delete $aim_connections{$filenos[$fileno]};
		delete $aim_connections{$connection->{nick}} if $connection and $connection->{nick};
		$aimselect->remove($connection);
		signoff($connection);
	}

	if($ircselect->can_read(.01)) {
		$_ = $upstream->getline;
		chomp; chop;
		Toc::debug_print("From IRC: $_", "irc", 2);
		process_irc_message($_);
	}
	if((time % 100) == 0) { #Cleanup nicks
		ANICK: foreach $anick(keys %nicks) {
			$kill = 1;
			foreach $bnick(keys %{$nicks{normalize($anick)}}) {
				next ANICK if $kill == 0;
				$kill = 0 if $nicks{normalize($anick)}{$bnick} == -1;
				$kill = 0 if (time - $nicks{normalize($anick)}{$bnick}) < 3600;
			}
			if($kill == 1) {
				delete $nicks{normalize($anick)};
				irc_send(":$prefix$anick QUIT :$prefix$anick\r\n");
			}
		}
	}
}

sub irc_subparms($;$$) {
	my($input, $user, $nick, $time) = @_;
	$time = time;
	$input =~ s/_TIME_/$time/g;
	$input =~ s/_USER_/$user/g;
	$input =~ s/_NICK_/$nick/g;
	warn "$input\n" if $debug >= 2;
	return $input;
}

sub irc_privmsg {
	my($from, $to, $msg) = @_;
	return ":$from PRIVMSG $to :$msg\r\n";
}

sub irc_newnick {
	my($nick, $user, $string) = shift;
	($user = $nick) =~ s/^$prefix//;
	$nick = substr($nick, 0, $ircservers{$servermode}{nicklen}) if length $nick > $ircservers{$servermode}{nicklen};
	$string = irc_subparms($ircservers{$servermode}{nick}, $user, $nick);
	$string .= ":$nick MODE $nick +i\r\n";
	return $string;
}

sub process_irc_message {
	my $nick;
	if(/:([^ ]+) PRIVMSG $usnick :(.+)/i) { #$1 sent $2 to $usnick
		$nick = $1; $msg = $2;
		$cmd = undef; $extra = undef; $param = undef;
		$msg =~ /(\S+) (\S+)( ?.*)/ or $cmd = $msg;
		$cmd = $1 unless $cmd; $param = $2 if $2; $extra = substr($3, 1) || "" if $3;
		$cmd ||= $msg; #For cmds w/o param
		#warn "Cmd: $cmd\nParam: $param: Extra: $extra\n\n";
		unless($aim_connections{$nick} or ($cmd eq "signon") or ($cmd eq "help")) {
			irc_send(irc_privmsg($usnick, $nick, "You must use the signon command to sign on to AOL Instant Messenger before using this service."));
		} elsif($cmd eq "signon") {
			@ret = signon $param, $extra, sub {
				irc_send(irc_privmsg($usnick, $nick, $_[0]))
			};
			if($ret[0] == 0) {
				$aim_connections{$nick}{nick} = $nick;
				$aim_connections{$nick}{aimnick} = $param;
				$aim_connections{$nick}{socket} = $ret[1];
				$aim_connections{$nick}{permtype} = $ret[2]->{permtype};
				%temp = %{$ret[2]};
				$aim_connections{$nick}{bold} = $aim_connections{$nick}{italic} = $aim_connections{$nick}{underlined} = $aim_connections{$nick}{color} = 1;
				foreach $buddy(keys %{$temp{Buddies}}) {
					$buddy =~ tr/ //d; $buddy = lc($buddy);
					add_buddy($aim_connections{$nick}{socket}, $buddy, $temp{Buddies}{$buddy}{group}, 1);
				}
				foreach $buddy(keys %{$temp{permit}}) {
					$buddy =~ tr/ //d; $buddy = lc($buddy);
					add_permit($aim_connections{$nick}{socket}, $buddy, 1);
				}
				foreach $buddy(keys %{$temp{deny}}) {
					$buddy =~ tr/ //d; $buddy = lc($buddy);
					add_deny($aim_connections{$nick}{socket}, $buddy, 1);
				}
				$filenos[$aim_connections{$nick}{socket}->fileno] = $nick;
				$aimselect->add($aim_connections{$nick}{socket});
				irc_send(irc_privmsg($usnick, $nick, "You are now connected to AOL Instant Messenger."));
				unless($nicks{normalize($param)}) {
					irc_send(irc_newnick($prefix . normalize($param)));
					$nicks{normalize($param)}{$nick} = -1;
				}
			} else {
				irc_send(irc_privmsg($usnick, $nick, $err));
			}
		} elsif ($cmd eq "buddylist") {
			my(%groups, $buddy, $group);
			%temp = deref(get_config($aim_connections{$nick}{aimnick}));
			foreach $buddy(sort keys %{$temp{Buddies}}) {
				push @{$groups{$temp{Buddies}{$buddy}{group}}}, $buddy;
			}
			foreach $group(sort keys %groups) {
				foreach $buddy(sort @{$groups{$group}}) {
					irc_send(irc_privmsg($usnick, $nick, "$buddy ($group)"));
				}
			}
		} elsif ($cmd eq "onbuddies") {
			my(%groups, $buddy, $group);
			%temp = deref(get_config($aim_connections{$nick}{aimnick}));
			foreach $buddy(sort keys %{$temp{Buddies}}) {
				push @{$groups{$temp{Buddies}{$buddy}{group}}}, $buddy if $temp{Buddies}{$buddy}{online};
			}
			foreach $group(sort keys %groups) {
				foreach $buddy(sort @{$groups{$group}}) {
					irc_send(irc_privmsg($usnick, $nick, "$buddy ($group)"));
				}
			}
		} elsif ($cmd eq "permitlist") {
			%temp = deref(get_config($aim_connections{$nick}{aimnick}));
			irc_send(irc_privmsg($usnick, $nick, join(" ", sort keys(%{$temp{permit}}))));
		} elsif ($cmd eq "denylist") {
			%temp = deref(get_config($aim_connections{$nick}{aimnick}));
			irc_send(irc_privmsg($usnick, $nick, join(" ", sort keys(%{$temp{deny}}))));
		} elsif ($cmd eq "signoff") {
				irc_send(":$prefix" . normalize($aim_connections{$nick}{aimnick}) . " QUIT\r\n");
				delete $aim_connections{$aim_connections{$nick}{socket}->fileno};
				$aimselect->remove($aim_connections{$nick}{socket});
				signoff($aim_connections{$nick}{socket});
				delete $aim_connections{$nick};
				irc_send(irc_privmsg($usnick, $nick, "Bye!"));
		} elsif ($cmd eq "buddyinfo") {
			%temp = deref(get_config($aim_connections{$nick}{aimnick}));
			$param = lc($param);
			$group = $temp{Buddies}{$param}{group};
			if($temp{Buddies}{$param}) {
				local $^W = 0;
				$msg = ":$usnick PRIVMSG $nick :";
				$msg .= "Group: $group\t" if $group and $group ne "Buddies";
				$msg .= "Signon time: " . localtime($temp{Buddies}{$param}{signon}) . "\tIdle time: $temp{Buddies}{$param}{idle} minutes\tUser class: ";
				$msg .= parseclass($temp{Buddies}{$param}{class}) . "\r\n";
				irc_send($msg);
			} else {
				irc_send(irc_privmsg($usnick, $nick,  "That persion is either not on your buddy list or not signed on."));
			}
		} elsif ($cmd eq "add_buddy") {
			$param = lc($param);
			$group = $extra || "Buddies";
			add_buddy($aim_connections{$nick}{socket}, $param, $group);
		} elsif ($cmd eq "remove_buddy") {
			$param = lc($param);
			remove_buddy($aim_connections{$nick}{socket}, $param);
			irc_send(irc_privmsg($usnick, $nick, "$param has departed"));
		} elsif ($cmd eq "evil" or $cmd eq "warn") {
			$param = lc($param);
			if($extra ne "anon") {
				$extra = 0;
			} else {
				$extra = 1;
			}
			evil($aim_connections{$nick}{socket}, $param, $extra);
		} elsif ($cmd eq "add_permit") {
			$param = lc($param);
			add_permit($aim_connections{$nick}{socket}, $param);
		} elsif ($cmd eq "add_deny") {
			$param = lc($param);
			add_deny($aim_connections{$nick}{socket}, $param);
		} elsif ($cmd eq "remove_deny") {
			$param = lc($param);
			remove_deny($aim_connections{$nick}{socket}, $param);
		} elsif ($cmd eq "remove_permit") {
			$param = lc($param);
			remove_permit($aim_connections{$nick}{socket}, $param);
		} elsif ($cmd eq "join") {
			if($aim_connections{$nick}{chats}{$param} == 1) { #We're invited
				chat_accept($aim_connections{$nick}{socket}, $param);
			} else {
				$extra ? chat_join($aim_connections{$nick}{socket}, "$param $extra") : chat_join($aim_connections{$nick}{socket}, $param);
			}
		} elsif ($cmd eq "get_permit_mode") {
			irc_send(irc_privmsg($usnick, $nick, $aim_connections{$nick}{permtype}));
		} elsif ($cmd eq "set_permit_mode") {
			$aim_connections{$nick}{permtype} = $param;
			permtype($aim_connections{$nick}{socket}, $param);
		} elsif ($cmd eq "list_permit_modes") {
			irc_send(irc_privmsg($usnick, $nick, "1=Permit All, 2=Deny All, 3=Permit only those on permit list"));
		} elsif ($cmd eq "chat") {
			chat_send($aim_connections{$nick}{socket}, $param, $extra);
		} elsif ($cmd eq "whisper") {
			$extra =~ /(\S+) (.*)/;
			chat_whisper($aim_connections{$nick}{socket}, $param, $1, $2);
		} elsif ($cmd eq "chat_evil" or $cmd eq "chat_warn") {
			$extra =~ /(\S+) (.*)/;
			$foo = undef;
			$foo = "norm" if $2 ne "anon";
			$foo ne "norm" ? $foo = 1 : $foo = 0;
			evil($aim_connections{$nick}{socket}, $param, $foo);
		} elsif ($cmd eq "invite") {
			$param = lc($param);
			$extra =~ /(\S+) (\S+)/;
			@temp = split(/,/, $param);
			chat_invite($aim_connections{$nick}{socket}, $1, @temp, $2);
		} elsif ($cmd eq "part") {
			delete $aim_connections{$nick}{chat}{$param};
			chat_leave($aim_connections{$nick}{socket}, $param);
		} elsif ($cmd eq "info") {
			$param = lc($param);
			get_info($aim_connections{$nick}{socket}, $param);
		} elsif ($cmd eq "set_info") {
			set_info($aim_connections{$nick}{socket}, "$param $extra");
		} elsif ($cmd eq "get_dir") {
			get_directory($aim_connections{$nick}{socket}, $param);
		} elsif ($cmd eq "set_dir") {
			$param = "$param $extra";
			if($param and $param ne "set_dir") {
				@temp = split(/:/, $param);
				%temp = (
					first_name => unshift @temp,
					middle_name => unshift @temp,
					last_name => unshift @temp,
					maiden_name => unshift @temp,
					city => unshift @temp,
					state => unshift @temp,
					country => unshift @temp,
					email => unshift @temp,
					allow_web_searches => unshift @temp
				);
				set_directory($aim_connections{$nick}{socket}, %temp);
			} else {
				irc_send(irc_privmsg($usnick, $nick, "first name:middle name:last name:maiden name:city:state:country:email:websearch.  Don't put any colons in any of these.  If you put anything in the websearch field, people can find your directory info using web searches."));
			}
		} elsif ($cmd eq "dir_search") {
			$param = "$param $extra";
			if($param and $param ne "dir_search") {
				@temp = split(/:/, $param);
				%temp = (
					first_name => unshift @temp,
					middle_name => unshift @temp,
					last_name => unshift @temp,
					maiden_name => unshift @temp,
					city => unshift @temp,
					state => unshift @temp,
					country => unshift @temp,
					email => unshift @temp,
					allow_web_searches => unshift @temp
				);
				directory_search($aim_connections{$nick}{socket}, %temp);
			} else {
				irc_send(irc_privmsg($usnick, $nick, "first name:middle name:last name:maiden name:city:state:country:email:websearch.  Don't put any colons in any of these.  If you put anything in the websearch field, people can find your directory info using web searches."));
			}
		} elsif ($cmd eq "bold") {
			$aim_connections{$nick}{bold} = $param;
		} elsif ($cmd eq "italic") {
			$aim_connections{$nick}{italic} = $param;
		} elsif ($cmd eq "underlined") {
			$aim_connections{$nick}{underlined} = $param;
		} elsif ($cmd eq "color") {
			$aim_connections{$nick}{color} = $param;
		} elsif ($cmd eq "add") {
			$param =~ tr/ //d; $inick = lc($param);
			unless($nicks{normalize($inick)}) {
				irc_send(irc_newnick($prefix . $param));
			}
			$nicks{$inick}{$nick} = time;
		} elsif ($cmd eq "help") {
			$foo = ":$usnick PRIVMSG $nick";
			$upstream->print("$foo :aimirc $version, (c)1999 Matthew Sachs.\r\n");
			$upstream->print("$foo :This program is licensed under Version 2 the GNU Public License.\r\n");
			$upstream->print("$foo :A copy of the license is available at http://www.gnu.org/copyleft/gpl.txt\r\n");
			$upstream->print("$foo :The following commands are available (use /msg $usnick command params to send):\r\n");
			$upstream->print("$foo :NOTE: Remove all spaces from nicks.  nick is an AIM nick, not an IRC one.\r\n");
			$upstream->print("$foo :help - show this screen\r\n");
			$upstream->print("$foo :signon nick pass - sign on to AOL Instant Messenger (AIM).  You must do this before any of the other commands\r\n");
			$upstream->print("$foo :signoff - sign off of AIM\r\n");
			$upstream->print("$foo :buddyinfo name - get signon time, idle time, evil level, and user class for a buddy\r\n");
			$upstream->print("$foo :add_buddy nick [group] - add nick to your buddy list.  If you give a group, buddy will be added to that group\r\n");
			$upstream->print("$foo :remove_buddy nick - remove nick from your buddy list\r\n");
			$upstream->print("$foo :evil nick [anon] (or warn nick [anon]) - warn nick, optionally anonymously\r\n");
			$upstream->print("$foo :add_permit nick - add nick to your permit list, removing from deny list\r\n");
			$upstream->print("$foo :add_deny nick - add nick to your deny list, removing from permit and buddy lists\r\n");
			$upstream->print("$foo :remove_permit nick - remove nick from permit list\r\n");
			$upstream->print("$foo :remove_deny nick - remove nick from deny list\r\n");
			$upstream->print("$foo :join topic - create and join a new chatroom with topic set to topic\r\n");
			$upstream->print("$foo :chat chat_id message - send message to chat chat_id\r\n");
			$upstream->print("$foo :whisper chat_id user message - whisper to user in chat chat_id\r\n");
			$upstream->print("$foo :chat accept_ chat_id - accept an invitation to chat chat_id\r\n");
			$upstream->print("$foo :invite buddy1,buddy2,...,buddyn chat_id message - invite buddies into a chat\r\n");
			$upstream->print("$foo :info nick - get info for nick\r\n");
			$upstream->print("$foo :set_info new info - set your info\r\n");
			$upstream->print("$foo :onbuddies - list buddies who are currently on\r\n");
			$upstream->print("$foo :buddylist - list all buddies\r\n");
			$upstream->print("$foo :permitlist - see who is on your permit list\r\n");
			$upstream->print("$foo :denylist - see who is on your deny list\r\n");
			$upstream->print("$foo :get_permit_mode - see your current permit mode\r\n");
			$upstream->print("$foo :set_permit_mode newmode - set your permit mode\r\n");
			$upstream->print("$foo :list_permit_modes - list the valid permit modes and their definitions\r\n");
			$upstream->print("$foo :get_dir nick - Get directory info for nick\r\n");
			$upstream->print("$foo :set_dir [info] - Without info, gives you the syntax that info must be in.  With info, sets your directory info.\r\n");
			$upstream->print("$foo :dir_search [info] - Without info, gets the syntax that info must be in (the same as that of set_dir).  With info, searches the AOL Instant Messenger directory.\r\n");
			$upstream->print("$foo :bold 0/1 - When set to 1 (the default), HTML bold tags will be translated to their IRC formatting equivalent.\r\n");
			$upstream->print("$foo :italic 0/1 - When set to 1 (the default), HTML italic tags will be translated to their IRC formatting equivalent.\r\n");
			$upstream->print("$foo :underlined 0/1 - When set to 1 (the default), HTML underlined tags will be translated to their IRC formatting equivalent.\r\n");
			$upstream->print("$foo :add nick - Create an IRC nickname for nick.  Use this to talk to someone who's not on your buddylist.\r\n");
			#$upstream->print("$foo :color 0/1 - When set to 1 (the default), HTML color (<FONT COLOR=...>)  tags will be translated to their IRC formatting equivalent.\r\n");
		} else {
			irc_send(irc_privmsg($usnick, $nick, "Unknown command - /msg $usnick help for help."));
		}
	} elsif(/:(\S+) PRIVMSG (\S+) :(.+)/i) { #$1 sent $3 to $2 (where $2 ne $usnick)
		$nick = $1; $target = normalize(aimnick($2)); $msg = $3;
		if($2 eq "#aimirc-debug") {
			$msg =~ s/^(aimserv)\S*\s+//;
			if($msg eq "restart" and $1) {
				phoenix;
			} elsif($msg =~ /^newnick (.+)/ and $1) {
				irc_send(irc_newnick($1));
			} elsif($msg =~ /^setlevel (\S+) (\S+)/) {
				$debug{$1} = $2;
			} else {
				irc_send(irc_privmsg($usnick, "#aimirc-debug", "To use aimserv admin commands, say 'aimserv, command params'.  Valid commands are restart, newnick (which takes the nick to create as a parameter), and setlevel (which takes a type and a level as parameters - only messages less then or equal to that level will be shown for that type.)"));
			}
		} else {
			message($aim_connections{$nick}{socket}, $target, $msg);
			$nicks{substr($target, 4)}{$nick} = time if $nicks{substr($target, 4)}{$nick} != -1;
		}
	} elsif(/^:(\S+) AWAY(.*)/) {
		$nick = $1;
		if($2 =~ /:(.*)/) {
			$aim_connections{$nick}{away} = $1;
			set_away($aim_connections{$nick}{socket}, $1);
		} else {
			delete $aim_connections{$nick}{away};
			delete $aim_connections{$nick}{away_buddies};
			set_away($aim_connections{$nick}{socket});
		}
	} elsif(/^:(\S+) NICK (\S+)/) { #Nick change
		$aim_connections{$2} = $aim_connections{$1};
		$aim_connections{$1}{nick} = $2;
		delete $aim_connections{$1};
		$filenos[$aim_connections{$2}{socket}->fileno] = $2 if $aim_connections{$2}{socket};
	} elsif(/^:(\S+) QUIT/) {
		delete $aim_connections{$aim_connections{$1}{socket}->fileno} if $aim_connections{$1}{socket};
		$aimselect->remove($aim_connections{$1}{socket}) if $aim_connections{$1}{socket};
		signoff($aim_connections{$1}{socket}) if $aim_connections{$1}{socket};
		delete $aim_connections{$1};
	} elsif(/^PING/) {
		irc_send("PONG $us\r\n");
	}
}

sub process_aim_message {
	my ($connection) = shift;
	my($msg, $cmd, $val, $inick, $ar);

	$msg = sflap_get($connection->{socket});
	if($msg eq "-1") {
		irc_send(irc_privmsg($usnick, $connection->{nick}, "Error reading: $err"));
		return;
	}
	#warn "AIM got $msg for $connection->{nick}\n";
	$msg =~ /^([^:]+):(.+)/;
	$cmd = $1; $val = $2;
	if($cmd eq "ERROR") {
		$val =~ /([^:]+):?(.*)/;
		Toc::debug_print("Error $1: " . aim_strerror($1), "errors", 1);
		irc_send(irc_privmsg($usnick, $connection->{nick}, "Error $1: " . aim_strerror($1)));
	} elsif($cmd eq "CONFIG") {
		update_config($connection->{socket}, $msg);
	} elsif($cmd eq "IM_IN") {
		my $nick;
		$val =~ /([^:]+):(.):(.*)/;
		($inick = $1) =~ tr/ //d;
		Toc::debug_print("$prefix$inick is sending an IM to $connection->{nick}: $3", "IM", 2);
		unless($nicks{normalize($inick)}) {
			irc_send(irc_newnick($prefix . $inick));
		}
		($2 eq "T") ? ($ar = "[automatic response] ") : ($ar = "");
		@lines = html2txt($3, $nick);
		irc_send(irc_privmsg($prefix . $inick, $connection->{nick}, $ar . $lines[0]));
		shift @lines;
		foreach $line(@lines) {
			irc_send(irc_privmsg($prefix . $inick, $connection->{nick}, "[continued]\t\t$line"));
		}

		if(($ar eq "") and $connection->{away} and not $connection->{away_buddies}{$inick}) {
			$connection->{away_buddies}{$inick} = 1;
			message($connection->{socket}, $inick, $connection->{away}, 1);
		}
		$nicks{normalize($inick)}{$connection->{nick}} = time if $nicks{normalize($inick)}{$connection->{nick}} != -1;
	} elsif($cmd eq "UPDATE_BUDDY") {
		$val =~ /([^:]+):(.):([^:]+):([^:]+):([^:]+):(.+)/;
		($inick = $1) =~ tr/ //d; $inick = lc($inick);
		Toc::debug_print("$connection->{nick} UPDATE_BUDDY: $val", "buddies", 1);
		if($2 eq "T") {
			%temp = deref(get_config($connection->{aimnick}));
			irc_send(irc_privmsg($usnick, $connection->{nick}, "$inick has arrived")) unless $temp{Buddies}{$inick}{online};
			{
				local $^W = 0;
				irc_send(irc_privmsg($usnick, $connection->{nick}, "$inick has gone away")) if substr($temp{Buddies}{$inick}{class}, 2, 1) ne "U" and substr($6, 2, 1) eq "U";
				irc_send(irc_privmsg($usnick, $connection->{nick}, "$inick is no longer away")) if substr($temp{Buddies}{$inick}{class}, 2, 1) eq "U" and substr($6, 2, 1) ne "U";
			}
			update_buddy($connection->{aimnick}, $inick, $6, $3, $4, $5, 1);

			irc_send(irc_newnick($prefix . $inick)) unless scalar keys %{$nicks{normalize($inick)}};;
			$nicks{normalize($inick)}{$connection->{nick}} = -1;
		} else {
			update_buddy($connection->{aimnick}, $inick, $6, $3, $4, $5, 0);
			irc_send(irc_privmsg($usnick, $connection->{nick}, "$inick has departed"));
			delete $nicks{normalize($inick)}{$connection->{nick}};
			delete $nicks{normalize($inick)} unless keys %{$nicks{normalize($inick)}};
			irc_send(":$prefix$inick QUIT :$prefix$inick\r\n") unless scalar keys %{$nicks{normalize($inick)}};
		}
	} elsif($cmd eq "EVILED") {
		$val =~ /([^:]+):(.*)/;
		$connection->{evil} = $1;
		irc_send(irc_privmsg($usnick, $connection->{nick}, $2 || "Anonymous" . " has just evilled you.  Your new evil level is $1%."));
	} elsif($cmd eq "CHAT_JOIN") {
		$val =~ /([^:]+):(.*)/;
		$connection->{chats}{$1} = $2;
		Toc::debug_print("$connection->{nick} has joined chat $2 (ID $1)", "chat", 2);
		irc_send(irc_privmsg($usnick, $connection->{nick}, "You have joined chat $2.  Chat id is $1."));
	} elsif($cmd eq "CHAT_IN") {
		my $nick;
		$val =~ /([^:]+):([^:]+):(.+):(.*)/;
		Toc::debug_print("$2 said to $connection->{nick} in chat $1: $lines[0]", "chat", 2);
		$msg = ":$usnick PRIVMSG $connection->{nick} :$2 ";
		($3 eq "T" or $3 eq "t") ? $msg .= "whispered " : $msg .= "said ";
		@lines = html2txt($4, $nick);
		$msg .= "in chat $1: $lines[0]\r\n";
		shift @lines;
		foreach $line(@lines) {
			Toc::debug_print("[continued] $line", "chat", 2);
			$msg .= irc_privmsg($usnick, $connection->{nick}, "[continued]\t\t$line");
		}
		irc_send($msg);
	} elsif($cmd eq "CHAT_UPDATE_BUDDY") {
		$val =~ /([^:]+):(.):(.+)/;
		irc_send(":$usnick PRIVMSG $connection->{nick} :The following users have ");
		($2 eq "T") ? (irc_send("joined")) : (irc_send("left"));
		irc_send(" chat $connection->{chats}{$1}: $3\r\n");
	} elsif($cmd eq "CHAT_INVITE") {
		$val =~ /([^:]+):([^:]+):([^:]+):(.*)/;
		Toc::debug_print("$connection->{nick} has been invited to chat $1 ($4) [$2] by $3", "chat", 2);
		$connection->{chats}{$2} = 1;
		irc_send(irc_privmsg($usnick, $connection->{nick}, "$3 has invited us to chatroom $1 ($4).  To accept, /msg $usnick join $2"));
	} elsif($cmd eq "CHAT_LEFT") {
		irc_send(irc_privmsg($usnick, $connection->{nick}, "Chat $connection->{chats}{$val} has been dropped."));
		delete $connection->{chats}{$val};
	} elsif($cmd eq "GOTO_URL") {
		$val =~ /[^:]+:(.+)/;
		irc_send(irc_privmsg($usnick, $connection->{nick}, "AOL wants you to go to the URL http://toc-d01.blue.aol.com:5190/$1"));
	}
}

sub html2txt {
	my ($msg, $nick, $parsetree) = @_;
	$parsetree = HTML::TreeBuilder->new->parse($msg);
	my($linkct, $link, $elem, $node) = 0;
	foreach $node (@{$parsetree->extract_links("a")}) { #For every <A HREF
		($link, $elem) = @$node;
		while(ref(${$$elem{_content}}[0])) {
			${$$elem{_content}}[0] = ${$$elem{_content}}[0]->{_content}[0];
		}
		${$$elem{_content}}[0] .= " {$link}";
	}
	$parsetree->traverse(\&tsub);
	return split(/\n/, HTML::FormatText->new(leftmargin => 0, rightmargin => 4096)->format($parsetree));
}

sub tsub {
	my($bold, $italic, $underline, $color) = (chr(2), chr(oct(26)), chr(oct(37)), chr(3));
	my($node, $startflag, $xnode, $nick) = @_;
	return 1 unless $startflag;
	foreach $xnode(@{$node->{_content}}) {
		if(ref $xnode) {
			$xnode->traverse(\&tsub);
		} else {
			$xnode = "$bold$xnode$bold" if $node->{_tag} eq "b" and $aim_connections{$nick}{bold} == 1;
			$xnode = "$italic$xnode$italic" if $node->{_tag} eq "i" and $aim_connections{$nick}{italic} == 1;
			$xnode = "$underline$xnode$underline" if $node->{_tag} eq "u" and $aim_connections{$nick}{underlined} == 1;
		}
	}
}

sub aimnick {
	my($nick) = shift;
	$nick = lc($nick);
	$nick =~ s/^$prefix//i;
	return $nick;
}


sub Toc::debug_print($$$) {
	my($text, $type, $level) = @_;
	my($line, @lines);

	return unless $debug;
	return if defined($debug{$type}) and $level > $debug{$type};

	@lines = split(/[\r\n]+/, $text);

	foreach $line(@lines) {
		$upstream->print(":$usnick PRIVMSG #aimirc-debug :($type, $level) $line\r\n");
	}
}

sub irc_send {
	Toc::debug_print("To IRC  : $_[0]", "irc", 2);
	$upstream->print($_[0]);
}

sub deref($) {
	my $href = shift;
	return %$href;
}

#!/usr/bin/perl

$license = <<EOF
Copyright (c) 1999-2001 Matthew Sachs.  All Rights Reserved.

   This program is free software; you can redistribute it and/or
   modify it under the terms of version 2 of the GNU General Public License
   as published by the Free Software Foundation.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

   The GNU General Public License is included with the aimirc distribution
   under the filename COPYING.

 AOL Instant Messenger, AOL, and America Online are trademarks of America Online, Inc.
EOF
;

use strict;
use vars qw($home $version $VERSION @args $prefix $usnick $us $them $themport $ourpass $theirpass $servermode $time $verbose_signon $ssl @default_conffiles $fork $verbose $sendidle $tocserver $tocport %dcc $savebuddies $saveprofiles $savepounces $directory $shortcircuit @conffiles $debug %debuglevel $dccip %ircservers $dcc $reload $upstream %aim_connections %irc_connections $aimircdebug %longnicks @dccqueue $lasttime $checktime $keepalive $themname %nicks %shortnicks %chatinvites %chattopics %chattime %profiles %pounces %buddylists %chantimer %chatjoined %chatnames %chatqueue %chats %dccget %debug %irc_away $license @getbuff $numeric $starttime);

sub loadconf();
sub loaddat($);
sub mainloop();
sub connect_to_irc();
sub going_down();
sub do_signoff_all($;$);
sub timestuff($);
sub switchnick($$);
sub irc_newnick($);
sub noprefix($);
sub haskeys($);
sub irc_subparms($;$$);
sub irc_privmsg($$$;$$$);
sub process_irc_message($);
sub process_aim_message($$$);
sub html2txt($;$);
sub Toc::debug_print($$$);
sub irc_send($;$);
sub deref($);
sub rehash();
sub reload();
sub dispver();
sub license();
sub help();
sub do_signon($$$$);
sub do_signoff($$;$);
sub irc_recv(;$);
sub manglewarn($$);
sub irc_ctcp_quote($);
sub irc_ctcp_unquote($);
sub process_ctcp($$$$);
sub irc_ctcp($$$;$);
sub loadbuddies($$);
sub irc_dcc($$$$$$);
sub safename($);
sub savedat($);
sub num2base64($);
sub base642num($);
sub got_im($$$$);
sub irc_mode($$$);
sub irc_join($$);
sub irc_kick($$$;$);
sub irc_part($$;$);
sub irc_error($$$);
sub irc_topic($$$);
sub irc_pong();
sub irc_quit($;$);
sub irc_invite($$$);
sub ircirfy($);
sub bounce_join($$);

$starttime = time;

$| = 1;

sub END { going_down; }

sub BEGIN {
	require FindBin;
	use lib $FindBin::Bin;

	eval {
		require HTML::FormatText;
		require HTML::Parse;
	};

	if($@) {
		print STDERR "Couldn't require HTML::FormatText and/or HTML::Parse.  Here's why:\n";
		print STDERR "$@\n";
		print STDERR "\n\n";
		print STDERR "And here's what that probably means...\n\n";
		print STDERR "You do not have the HTML::FormatText and HTML::Parse modules installed.\n";
		print STDERR "There are at least three possible ways to install these modules:\n";
		print STDERR "1) [preferred] Get them as a package from your OS vendor or Linux distributor.\n";
		print STDERR "        In Debian, you can install the libhtml-tree-perl and \n";
		print STDERR "        libhtml-format-perl packages.  I'm not sure about\n";
		print STDERR "        other operating systems or distributions.\n";
		print STDERR "2) Use the CPAN module to install it.  Run perl -MCPAN -e shell and \n";
		print STDERR "        type install HTML::Tree when you get to the CPAN prompt, and\n";
		print STDERR "        then install HTML::FormatText .\n";
		print STDERR "3) Download the source from CPAN and install it.  The source is located\n";
		print STDERR "        at http://www.perl.com/CPAN/modules/by-module/HTML/ in a file\n";
		print STDERR "        called HTML-Tree-VERSION.tar.gz where VERSION is the latest version\n";
		print STDERR "        of HTML-Tree.  You will also need the HTML-Format-VERSION.tar.gz\n";
		print STDERR "        package.\n";
		die "\n";
	}
}

use FindBin;
use lib $FindBin::Bin;

use IO::Handle;
use IO::Socket;
use POSIX;
use Carp;
use Getopt::Long;
use LWP::Simple;
use File::Basename;
use FormatAIMIRC;

$Carp::Verbose = 1;

eval { require Data::Dumper; };

use Toc qw(:all);

$SIG{__DIE__}  = sub { croak $_[0] };

$home = (getpwuid($>))[7];
$version = $VERSION = "1.2";

@args = @ARGV;

# setpriority(0, $$, 19);


#Defaults
$prefix = "AIM-";
$usnick = "AIMServ";
$us = "aimserv.your.irc.net";
$them = "127.0.0.1";
$themport = 6667;
$ourpass = "foo";
$theirpass = "bar";
$servermode = "dal2";
$time = 60*5; #Five minutes
$verbose_signon = 0;
$ssl = 1;
@default_conffiles = ("/etc/aimirc.conf", "$home/.aimirc");
$fork = 1;
$verbose = 0;
$sendidle = 1;
$tocserver = 'toc.oscar.aol.com';
$tocport = 80;
$dcc = 1;
$savebuddies = 2;
$saveprofiles = 2;
$savepounces = 2;
$directory = "$home/.aimirc.dat";
$shortcircuit = 1;
$numeric = num2base64(42);
*debuglevel = *debug;	#We can now reference debuglevels as %debuglevel or %debug

loadconf();

unless($reload) {
	if($fork) {
		#We don't need no stinking ampersands!
		my $pid = fork;
		exit if $pid;
		die "Couldn't fork: $!" unless defined($pid);

		POSIX::setsid() or die "Can't start a new session: $!";
	}
	sub kill_handler {
		my($connection);
		going_down;
		$upstream->close;
		foreach $connection(values %aim_connections) {
			$connection->{socket}->close;
		}
		exit 1;
	}
}

$SIG{INT} = $SIG{TERM} = \&kill_handler;
$SIG{CHLD} = 'IGNORE';

#Restart on SIGHUP
sub phoenix {
	my($connection, $screenname);
	going_down;
	$upstream->close;
	foreach $connection(values %aim_connections) {
		foreach $screenname(values %{$connection->{screennames}}) {
			$screenname->{socket}->close if $screenname->{socket};
		}
	}
	exec($0, @args);
}
$SIG{HUP} = \&rehash;


#Hello Mort!
sub REAPER {
	1 until (-1 == waitpid(-1, WNOHANG));
	$SIG{CHLD} = \&REAPER;
}
$SIG{CHLD} = \&REAPER;

$lasttime = $checktime = time;
$keepalive = 0;
mainloop();

sub loaddat($) {
	my($screenname, $buddylist, $profile, $pounce, $profiles, $pounces, $who, $what) = shift;

	$screenname = safename $screenname;

	#Who needs subroutines when you've got copy and paste?
	#Incidentally, this is what I mean by that "code cleanup" item in TODO
	#But would a trillion tiny functions be any cleaner?
	#Oh well - who reads this anyway?
	if((-d $directory and -r $directory) or mkdir($directory, 0700)) {
		local $/ = undef;
		if($savebuddies and -r "$directory/buddylists/$screenname") {
			open(BUDDYLIST, "<$directory/buddylists/$screenname");
			$buddylists{$screenname} = <BUDDYLIST>;
			close BUDDYLIST;
		}

		if($saveprofiles and -r "$directory/profiles/$screenname") {
			open(PROFILE, "<$directory/profiles/$screenname");
			$profiles{$screenname} = <PROFILE>;
			close PROFILE;
		}

		if($savepounces and -r "$directory/pounces/$screenname") {
			open(POUNCE, "<$directory/pounces/$screenname");
			$pounces = <POUNCE>;
			close POUNCE;
			delete $pounces{$screenname};
			foreach $_(split(/\n/, $pounces)) {
				($who, $what) = split(/\s+/, $_, 2);
				push @{$pounces{$screenname}}, {who => $who, what => $what};
			}
		}
	} else {
		if($savebuddies or $saveprofiles or $savepounces) {
			print STDERR "Warning - could not create $directory: $!\n";
			print STDERR "Fix it or we can't save buddies, profiles, or pounces to disk.\n";
			print STDERR "(Sleeping for 5 seconds to make sure you read this...)\n";
			sleep 5;
		}
	}
}

sub loadconf() {
	my($errors, $foundconfig, $conffile, %temp, $server, $output);
	#First we check to see what config files to use.
	#Then we use the config files.
	#Then we process command-line options.
	#We do it this way so that command-line options can override config files, and
	#  you can still specify config files on the command-line.

	Getopt::Long::Configure("no_ignore_case");
	Getopt::Long::Configure("pass_through");


	$errors = &GetOptions(
		"version|V" => \&dispver,
		"license" => \&license,
		"config|C=s\@" => \@conffiles,
		"help|h" => \&help,
		"output=s" => \$output
	);

	@conffiles = @default_conffiles unless $conffiles[0];

	if(!$errors) {
		print STDERR "Try $0 --help if you need help.\n";
		exit 1;
	}

	if(defined $output) {
		close STDOUT;
		close STDERR;
		open(STDOUT, ">>$output") or die "Couldn't open STDOUT: $!\n";
		open(STDERR, ">>&STDOUT") or die "Couldn't open STDERR: $!\n";
	}

	#Okay, try loading the config files

	$foundconfig = 0;

	foreach $conffile(@conffiles) {
		$conffile =~ s/~/$home/;
		if(-r $conffile) {
			print STDERR "Reading config file $conffile\n" if $verbose;
			do $conffile;
			die $@ if $@;
			$foundconfig = 1;
		} else {
			print STDERR "Couldn't read config file $conffile\n" if $verbose;
		}
	}

	unless($foundconfig) {
		print STDERR "We couldn't find a config file.\n";
		print STDERR "You must edit aimirc.conf and copy it to either /etc/aimirc.conf or\n";
		print STDERR "   $home/.aimirc.  If you have already done this, make sure the aimirc\n";
		print STDERR "   user has permission to read it.\n";
		print STDERR "Or, perhaps you specified a config file with the --config (-C) option.\n";
		print STDERR "If you want to specify everything on the command-line and not use a config\n";
		print STDERR "   file (why?) then just give it a blank config file to make it happy.\n";
		exit 1;
	}

	#Now process additional command-line options

	Getopt::Long::Configure("no_pass_through");

	$errors = &GetOptions(
		"us=s" => \$us,
		"them=s" => \$them,
		"themport=i" => \$themport,
		"ourpass=s" => \$ourpass,
		"theirpass=s" => \$theirpass,
		"servermode=s" => \$servermode,
		"prefix=s" => \$prefix,
		"usnick=s" => \$usnick,
		"time=i" => \$time,
		"ssl:i" => \$ssl,
		"fork:i" => \$fork,
		"verbose|v" => \$verbose,
		"debug:i" => \$debug,
		"debuglevel=s\%" => \%debuglevel,
		"verbose_signon:i" => \$verbose_signon,
		"sendidle:i" => \$sendidle,
		"tocserver=s" => \$tocserver,
		"tocport=i" => \$tocport,
		"dccip=s" => \$dccip,
		"dcc:i" => \$dcc,
		"savebuddies:i" => \$savebuddies,
		"saveprofiles:i" => \$saveprofiles,
		"savepounces:i" => \$savepounces,
		"directory=s" => \$directory,
		"shortcircuit:i" => \$shortcircuit,
		"numeric=s" => \$numeric,
	);

	if(!$errors) {
		print STDERR "Try $0 --help if you need help.\n";
		exit 1;
	}

	%temp = %ircservers; #Preserve custom ircservers

	%ircservers = (
		dal2 => {
			nick => "NICK _NICK_ 1 _TIME_ _USER_ $us $us 0 :AOL Instant Messenger client via aimirc\r\n",
			server => "SERVER $us 1 :AOL Instant Messenger services\r\n",
			uspass => 1,
			theirpass => 1,
			nicklen => 30,
			pass => "PASS $ourpass :1\r\n",
		},
		dragonfire => {
			nick => "NICK _NICK_ 1 _TIME_ _USER_ $us $us :AOL Instant Messenger client via aimirc\r\n",
			server => "SERVER $us 1 :AOL Instant Messenger services\r\n",
			uspass => 1,
			theirpass => 1,
			nicklen => 10,
			pass => "PASS $ourpass :1\r\n"
		},
		ircu => {
			nick => "NICK _NICK_ 1 _TIME_ _USER_ $us +i :AOL Instant Messenger services\r\n",
			server => "SERVER $us 1 _TIME_ _TIME_ P09 :AIM Services\r\n",
			uspass => 1,
			theirpass => 1,
			nicklen => 9,
			pass => "PASS :$ourpass\r\n"
		},
		rfc => {
			nick => "NICK _NICK_ 1\r\n:_NICK_ USER _USER_ $us $us :AOL Instant Messenger client via aimirc\r\n",
			server => "SERVER $us 1 :AOL Instant Messenger serices\r\n",
			uspass => 1,
			theirpass => 1,
			nicklen => 9,
			pass => "PASS :$ourpass\r\n"
		},
		ts => {
			nick => "NICK _NICK_ 1 _TIME_ +i _USER_ $us $us :AOL Instant Messenger client via aimirc\r\n",
			server => "SERVER $us 1 :AOL Instant Messenger serices\r\nSVINFO 3 1 0 :_TIME_\r\n",
			uspass => 1,
			theirpass => 1,
			nicklen => 9,
			pass => "PASS $ourpass :TS\r\n",
		},
		unreal => {
			nick => "NICK _NICK_ 1 _TIME_ _USER_ $us $us 0 :AOL Instant Messenger client via aimirc\r\n",
			server => "SERVER $us 1 :AOL Instant Messenger services\r\n",
			uspass => 1,
			theirpass => 1,
			nicklen => 30,
			pass => "PASS :$ourpass\r\n",
		},
		p10 => {
			nick => "$numeric N _NICK_ 1 _TIME_ _USERNAME_ _HOST_ +i A ${numeric}_NUMERIC_ :AOL Instant Messenger client via aimirc\r\n",
			server => "SERVER $us 1 _TIME_ _TIME_ J10 ${numeric}]]] :AOL Instant Messenger services\r\n$numeric EB\r\n$numeric EA\r\n",
			uspass => 1,
			theirpass => 1,
			nicklen => 9,
			pass => "PASS :$ourpass\r\n",
		},
			
	);

	foreach $server(keys %temp) { #Preserve custom ircservers
		$ircservers{$server} = $temp{$server};
	}

	if($ssl) {
		eval {
			require SSLv3;
		};

		if($@) {
			print STDERR "Couldn't load Perl module SSLv3.\n";
			print STDERR "This is probably due to a problem with IO::Socket::SSL.  Here's what Perl thinks:\n";
			print STDERR "$@\n";
			print STDERR "\n\n";
			print STDERR "And here's what that probably means...\n\n";
			print STDERR "You do not have the IO::Socket::SSL module installed.\n";
			print STDERR "There are at least two possible ways to install these modules:\n";
			print STDERR "1) [preferred] Get them as a package from your OS vendor or Linux distributor.\n";
			print STDERR "2) Use the CPAN module to install it.  Run perl -MCPAN -e shell and \n";
			print STDERR "        type install IO::Socket::SSL when you get to the CPAN prompt.\n";
			print STDERR "3) Download the source from CPAN and install it.  The source is located\n";
			print STDERR "        at http://www.perl.com/CPAN/modules/by-module/IO/ in a file\n";
			print STDERR "        called IO-Socket-SSL-VERSION.tar.gz where VERSION is the latest version\n";
			print STDERR "        of IO::Socket::SSL.\n";
			print STDERR "Note that IO::Socket::SSL has a couple of dependencies.\n";
			print STDERR "It requires the Net::SSLeay perl module and the OpenSSL library.\n";
			print STDERR "\n";
			print STDERR "IO::Socket::SSL is only required if you want to use SSL to communicate with TOC.\n";
			print STDERR "SSL is a type of encryption.\n";
			print STDERR "If you don't want SSL, set $ssl to 0 in your aimirc.conf (or .aimirc)\n";
			print STDERR "Alternatively, you can use the --ssl 0 command-line option.\n";
			die "\n";
		}

		SSLv3->context_init(SSL_verify_mode => 0x00, SSL_server => 0);
	}
}

sub mainloop() {
	my($connection, $screenname, $msg, $multinick, $i, $rv, $buff, $getrv, $rvbuff, $currtime, $nick, $sndata);
	my($rin, $win, $ein, $nfound, @fds, $fileno);
	$rin = $win = $ein = '';

	unless($reload) {
		connect_to_irc();
		$aimircdebug = 0;

		irc_send(irc_newnick($usnick)) or die "Couldn't make aimserv: $!\n";
		irc_send(irc_mode($usnick, $usnick, "-i"));
		irc_send(irc_mode($usnick, $usnick, "+oa"));

		irc_send(irc_join($usnick, "#aimirc-debug"));
		irc_send(irc_mode($us, "#aimirc-debug", "+o $usnick"));
		irc_send(irc_mode($usnick, "#aimirc-debug", "+nsk $ourpass"));
		$aimircdebug = 1;
		$longnicks{'#aimirc-debug'} = '#aimirc-debug';

		while(1 == 1) {
			exit(255) unless $upstream;
			$rin = $ein = '';
			foreach $nick(keys %aim_connections) {
				foreach $screenname(keys %{$aim_connections{$nick}{screennames}}) {
					if(!$aim_connections{$nick}{screennames}{$screenname}{socket}) {
						delete $aim_connections{$nick}{screennames}{$screenname};
						next;
					} 
					$fileno = $aim_connections{$nick}{screennames}{$screenname}{socket}->fileno;
					vec($rin, $fileno, 1) = 1;
					$fds[$fileno] = {nick => $nick, screenname => $screenname};
				}
			}

			vec($rin, $upstream->fileno, 1) = 1;
			$fds[$upstream->fileno] = {nick => $usnick};

			$ein = $rin;
			$nfound = select($rin, undef, $ein, 0.01);
			for($fileno = 0; $fileno <= $#fds; $fileno++) {
				next unless vec($ein, $fileno, 1) or vec($rin, $fileno, 1);
				$nick = $fds[$fileno]->{nick};

				if(vec($ein, $fileno, 1)) {
					$screenname = $fds[$fileno]->{screenname};
					$connection = $aim_connections{$nick};
					$multinick = "";
					$multinick = " for screenname $screenname" unless $screenname eq $connection->{aimnick} or $connection->{screennames}{$screenname}{inchan};
					irc_send(irc_privmsg($usnick, $nick, "There was an 511 error with your AOL Instant Messenger connection${multinick}: $err", "", "", $screenname));
					do_signoff($nick, $connection->{screennames}{$screenname}{socket});
					next;
				}

				if($nick eq $usnick) {
					$_ = irc_recv(1); #Don't block
					process_irc_message($_) if $_;
				} else {
					$screenname = $fds[$fileno]->{screenname};
					$connection = $aim_connections{$nick};

					$msg = sflap_get($connection->{screennames}{$screenname}{socket});
					if($msg eq "-1" and $! != EAGAIN) {
						$multinick = "";
						$multinick = " for screenname $screenname" unless $screenname eq $connection->{aimnick} or $connection->{screennames}{$screenname}{inchan};
						irc_send(irc_privmsg($usnick, $nick, "There was an 526 error with your AOL Instant Messenger connection${multinick}: $err", "", "", $screenname));
						do_signoff($nick, $connection->{screennames}{$screenname}{socket});
					} elsif($msg ne "-1") {
						process_aim_message($connection, $msg, $screenname);
					}				
				}
			}

			DCC: for($i = 0; $i <= $#dccqueue; $i++) {
				$dcc = $dccqueue[$i];
				my $screenname = $dcc->{screenname};
				if($dcc->{direction} eq "GET") {
					undef $rv;
					$! = EAGAIN;
					while($! == EAGAIN and !defined($rv)) {
						$buff = ' ' x 102;
						$rv = $dcc->{socket}->sysread($buff, 102); #A tenth of a kilobyte - should be okay even for slow connections
						if (!defined($rv) && $! != EAGAIN) {
							irc_send(irc_privmsg($dcc->{to}, $dcc->{from}, "DCC connection dropped: $!", "", "", $screenname));
							$dcc->{socket}->close;
							splice(@dccqueue, $i, 1);
							next DCC;
						}
						if(!defined($rv) && ($! == EAGAIN)) {
							next DCC;
						}
						$dcc->{buff} .= $buff;
						$dcc->{got} += $rv;
						Toc::debug_print("DCC got $rv bytes ($dcc->{got} of $dcc->{size})", "DCC", 2);

						$dcc->{socket}->print(pack("N", $dcc->{got})) if(($dcc->{got} % 2048) == 0 or $dcc->{got} == $dcc->{size}); # Every 2048 bytes, write number of bytes received

						if($dcc->{got} == $dcc->{size}) {
							Toc::debug_print("DCC $dcc->{direction} $dcc->{what} from $dcc->{from} to $dcc->{to} completed.", "DCC", 1);
							Toc::debug_print($dcc->{buff}, "DCC", 3);
							$dcc->{socket}->close;
							irc_send(irc_privmsg($dcc->{to}, $dcc->{from}, "DCC completed.", "", "", $screenname));
							if(loadbuddies($aim_connections{$dcc->{from}}{screennames}{$dcc->{screenname}}{socket}, $dcc->{buff})) {
								irc_send(irc_privmsg($dcc->{to}, $dcc->{from}, "Buddylist loaded.", "", "", $screenname));
							} else {
								irc_send(irc_privmsg($dcc->{to}, $dcc->{from}, "Could not load buddylist - is it in the correct format?", "", "", $screenname));
							}
							splice(@dccqueue, $i, 1);
						}
					}
				} elsif($dcc->{direction} eq "SEND") {
					if($dcc->{put} == -1) {
						undef $rv;
						vec($rin, $dcc->{ssocket}->fileno, 1) = 1;
						#Anyone trying to connect to us?
						if(!select($rin, $win, $ein, 0.01)) {
							if(time - $dcc->{starttime} > 60*10) {
								irc_send(irc_privmsg($dcc->{from}, $dcc->{to}, "DCC connection timed out.", "", "", $screenname));
								$dcc->{ssocket}->close;
								splice(@dccqueue, $i, 1);
							}
							next DCC;
						}
						$rv = $dcc->{ssocket}->accept;
						if(defined $rv) {
							$dcc->{socket} = $rv;
							$dcc->{put} = 0;
						} elsif($! and $! != EAGAIN) {
							irc_send(irc_privmsg($dcc->{from}, $dcc->{to}, "DCC connection dropped: $!", "", "", $screenname));
							$dcc->{ssocket}->close;
							splice(@dccqueue, $i, 1);
							next DCC;
						}
					} else {
						undef $rv;
						$! = EAGAIN;
						while($! == EAGAIN and !defined($rv)) {
							if($dcc->{put} < $dcc->{size}) {
								$buff = substr($dcc->{buff}, 0, 102, "");
								$rv = $dcc->{socket}->syswrite($buff, length $buff); #A tenth of a kilobyte - should be okay even for slow connections
								if (!defined($rv) && $! != EAGAIN) {
									irc_send(irc_privmsg($dcc->{from}, $dcc->{to}, "DCC connection dropped: $!", "", "", $screenname));
									$dcc->{socket}->close;
									$dcc->{ssocket}->close;
									splice(@dccqueue, $i, 1);
									next DCC;
								}
								if(!defined($rv) && ($! == EAGAIN)) {
									next DCC;
								}
								$dcc->{put} += $rv;
								Toc::debug_print("DCC put $rv bytes ($dcc->{put} of $dcc->{size})", "DCC", 2);
							}

							if(($dcc->{put} % 2048) == 0 or $dcc->{put} == $dcc->{size}) {
								Toc::debug_print("Waiting for ACK...", "DCC", 3);
								undef $getrv;
								$! = EAGAIN;
								undef $rvbuff;
								while($! == EAGAIN and !defined($getrv)) {
									$buff = ' ' x 4;
									$getrv = $dcc->{socket}->sysread($buff, 4);
									if(!defined($getrv) && $! != EAGAIN) {
										irc_send(irc_privmsg($dcc->{from}, $dcc->{to}, "DCC connection dropped: $!", "", "", $screenname));
										$dcc->{socket}->close;
										$dcc->{ssocket}->close;
										splice(@dccqueue, $i, 1);
										next DCC;
									}
									if(!defined($getrv) && ($! == EAGAIN)) {
										next DCC;
									} elsif($getrv < 4) {
										Toc::debug_print("ACK incomplete - got $rvbuff", "DCC", 3);
										$rvbuff .= $buff;
										undef $getrv;
									}
									$dcc->{got} = unpack("N", $rvbuff . $buff);
									Toc::debug_print("ACK received - client got $dcc->{got} of $dcc->{size} (we put $dcc->{put})", "DCC", 3);
								}
							}

							if($dcc->{got} == $dcc->{size}) {
								Toc::debug_print("DCC $dcc->{direction} $dcc->{what} from $dcc->{from} to $dcc->{to} completed.", "DCC", 1);
								$dcc->{socket}->close;
								$dcc->{ssocket}->close;
								irc_send(irc_privmsg($dcc->{from}, $dcc->{to}, "DCC completed.", "", "", $screenname));
								splice(@dccqueue, $i, 1);
							}
						}
					}
				}
			}

			$currtime = time;
			foreach $nick(keys %aim_connections) {
				next unless $nick;
				$connection = $aim_connections{$nick};
				foreach $screenname(keys %{$connection->{screennames}}) {
					next unless $screenname;
					$sndata = $connection->{screennames}{$screenname};
					next unless $sndata and ref $sndata eq "HASH" and defined $sndata->{signontime};
					next if $sndata->{gotconf};
					next if ($currtime - $sndata->{signontime}) <= 10;
					if(!$sndata->{ison}) {
						irc_send(irc_privmsg($usnick, $nick, "Your attempt to connect to AOL Instant Messenger has failed."));
						do_signoff($nick, $sndata->{socket}, 1);
					} else {
						irc_send(irc_privmsg($usnick, $connection->{nick}, "AOL did not send your buddylist!", "", "", $screenname));
						irc_send(irc_privmsg($usnick, $connection->{nick}, "Either you've just created this account or AOL is having problems - maybe they lost the buddylists again.", "", "", $screenname));
						$sndata->{gotconf} = 1;
						if($buddylists{safename $screenname}) {
							irc_send(irc_privmsg($usnick, $connection->{nick}, "Fortunately, we have a backup of your buddylist from the last time you signed on to this aimirc - we'll load that for you.", "", "", $screenname));
							update_config($sndata->{socket}, $buddylists{safename $screenname});
						} elsif($dcc) {
							irc_send(irc_privmsg($usnick, $connection->{nick}, "If you have a copy of your buddylist from the Win/Mac AIM client or from a savebuddies, you can import it via the loadbuddies command - \"/msg $usnick loadbuddies\".", "", "", $screenname));
							update_config($sndata->{socket}, "m 4\n");
						} else {
							update_config($sndata->{socket}, "m 4\n");
						}
					}
				}
			}

			#Do this loop about once every 100 seconds
			if((($currtime % 100) == 0) and ($currtime - $lasttime) >= 100) { #Cleanup nicks
				timestuff($currtime);
				$lasttime = $currtime;
			}
		}
	}
}

sub connect_to_irc() {
	my($flags, $in, $pass);

	$upstream = IO::Socket::INET->new(PeerAddr => "$them:$themport", Timeout => 5) or die "Couldn't connect to IRC server $them:$themport ($!)\n";

	$flags = 0;
	fcntl($upstream, F_GETFL, $flags) or die "Couldn't get flags for upstream: $!";
	$flags |= O_NONBLOCK;
	fcntl($upstream, F_SETFL, $flags) or die "Couldn't set flags for upstream: $!";

	do { irc_send($ircservers{$servermode}{pass}) if $ourpass and $ircservers{$servermode}{uspass}; } or die "Couldn't send PASS: $!\n";
	irc_send(irc_subparms($ircservers{$servermode}{server})) or die "Couldn't send PASS: $!\n";

	$in = "...";

	if($theirpass and $ircservers{$servermode}{theirpass}) {
		while($in and ($in !~ /PASS :?(.+)/)) {
			$in = irc_recv();
			chomp $in;
			if($in =~ /^ERROR :(.+)/) {
				print STDERR "IRC connection error: $1\n";
				exit 1;
			} elsif($in =~ /^SERVER (\S+)/) {
				$themname = $1;
			}
		}

		$in =~ s/ :1// if $in;
		$in =~ s/ :TS// if $in;
		$in =~ /^PASS :?(.+)/ if $in;
		$pass = $1;
		$pass =~ s/\s*//g if $pass;	#Remove spaces from crypted password
		if($pass and $theirpass and ($pass ne $theirpass and $pass ne crypt($theirpass, substr($pass, 0, 2)))) { die("Upstream server gave the wrong password!\n"); }
	}
}

# Create a new IRCnick, with mangling and anti-collide
sub irc_newnick($) {
	my($nick, $user, $string, $shortnick) = shift;
	$nick =~ tr/ //d;
	$user = $nick;
	$user =~ s/^$prefix//;

	Toc::debug_print("Shall we create $nick?", "nicks", 2);
	return if haskeys($nicks{noprefix $nick});
	$shortnick = ircify($nick);
	$nicks{noprefix($shortnick)}{$usnick} = time;
	Toc::debug_print("\tCreating $nick (normalized " . normalize($nick) . ", shortnick $shortnick)", "nicks", 1);
	$longnicks{normalize($shortnick)} = $nick;
	$shortnicks{noprefix($nick)} = $shortnick;
	$string = irc_subparms($ircservers{$servermode}{nick}, $user, $shortnick);
	$string .= ":$shortnick MODE $shortnick +i\r\n";
	return $string;
}

# Remove $prefix
sub noprefix($) {
	my $nick = shift;
	$nick =~ s/^$prefix//i;
	return normalize $nick;
}

# Does the hashref have any keys?
sub haskeys($) {
	my $hashref = shift;
	return scalar keys %$hashref;
}

# Substitute parameters in %ircservers strings
sub irc_subparms($;$$) {
	my($input, $user, $nick, $time) = @_;
	$time = time;
	$input =~ s/_TIME_/$time/g;
	$input =~ s/_USER_/$user/g;
	$input =~ s/_NICK_/$nick/g;
	return $input;
}

# Format an IRC private message - you must still irc_send it!
sub irc_privmsg($$$;$$$) {
	my($from, $to, $msg, $prefix, $notice, $screenname, $line, $ret, $text, $maxlen, $temp) = @_;
	$prefix ||= "";

	return unless $from and $to and $msg;

	$to = "#aimirc-$screenname" if $screenname and $aim_connections{normalize $to}{screennames}{$screenname}{inchan};

	$from = ircify($from);
	if($from ne $usnick and not haskeys($nicks{noprefix($from)})) {
		irc_send(irc_newnick($from));
	}

	$maxlen = 450 - length($from) - length($to);
	foreach $line(split(/[\r\n]+/, $msg)) {
		$text = "$prefix$line";
		while($text) {

			#IRC has a max cmd len of 512.
			#Split up messages which would exceed this length
			#Try to split up on word boundaries.

			if(length($text) > $maxlen) {
				$temp = substr($text, 0, $maxlen, "");
				$text = $1.$text if $temp =~ s/\s+(\S+)$//;
			} else {
				$temp = $text;
				$text = "";
			}
			$ret .= ":$from " . ($notice ? "NOTICE" : "PRIVMSG") . " $to :$temp\r\n";
		}
	}
	return $ret or $msg;
}

# Process an incoming IRC message
sub process_irc_message($) {
	my($aimnick, $nick, $chat, $who, $msg, $screenname, $sndata, %time, %group, %connections, $foo, @temp, $group, $i, $pounce, $target, $recipient, $level, $success, $newnick, %temp);

	$_ = shift;

	if(s/^:(\S+)(!\S+@\S+)?\s+//) {
		$nick = $1;
	} else {
		$nick = $themname;
	}
	my $nnick = normalize($nick);

	if($aim_connections{$nnick}) {
		foreach $screenname(keys %{$aim_connections{$nnick}{screennames}}) {
			$sndata = $aim_connections{$nnick}{screennames}{$screenname};
			$sndata->{idletime} = time;
			if($sndata->{is_idle}) {
				$sndata->{is_idle} = 0;
				if($sndata->{socket} and set_idle($sndata->{socket}, 0) == -1 and $! != EAGAIN) {
					irc_send(irc_privmsg($usnick, $nick, "There was an 815 error with your AOL Instant Messenger connection: $err", "", "", $screenname), 2);
					do_signoff($nnick, $sndata->{socket});
				}
			}
		}
	}

	if(/^ERROR +:(.+)/) {
		print STDERR "IRC server error: $1\n";
		exit 1;
	} elsif(/^KILL +(\S+)/i) {
		delete $nicks{noprefix $1};
	} elsif(/^VERSION/i) {
		irc_send(irc_error($nick, 351, "aimirc-$VERSION. $us :aimirc"));
	} elsif(!/#aimirc-debug/i and (/^JOIN +.?#aimirc-(\S+)/i or /^SJOIN +\d+ +#aimirc-(\S+) +\S+ +:(\S+)/i)) {
		my $screenname = $1;
		$nick = $2 if $2;
		$nnick =~ tr/\@+//d;
		$nnick = normalize($nick);
		my $dude;
		my %config = deref get_config $screenname;

		#print STDERR "Got $nnick joining $screenname ($_)\n";
		if(not defined $irc_connections{$screenname} or $irc_connections{$screenname} ne $nnick) {
			#print STDERR "Doing bounce_join\n";
			bounce_join($nick, "#aimirc-$screenname");
		} else {
			$aim_connections{$nnick}{screennames}{$screenname}{inchan} = 1;
			irc_send(irc_join($usnick, "#aimirc-$screenname"));
			irc_send(irc_mode($us, "#aimirc-$screenname", "+o $usnick"));
			irc_send(irc_mode($usnick, "#aimirc-$screenname", "-o $nick"));
			irc_send(irc_mode($usnick, "#aimirc-$screenname", "+ints"));
			foreach $dude(keys %nicks) {
				next unless $nicks{$dude}{$screenname};
				irc_send(irc_join("$prefix$dude", "#aimirc-$screenname"));
				irc_send(irc_mode($usnick, "#aimirc-$screenname", "+v $prefix$dude")) if exists $config{Buddies}{$dude};
			}
		}
	} elsif(/^JOIN +.?#aimchat-(\d+)/i or /^SJOIN +\d+ +#aimchat-(\d+) +\S+ +:(\S+)/i) {
		my $chat = $1;
		$nick = $2 if $2;
		$nick =~ tr/\@+//d; #Only needed for Hybrid?
		$nnick = normalize($nick);

		if((not $chatinvites{$chat} and not $chattopics{$chat}) or ($chatinvites{$chat} and $nnick ne normalize($chatinvites{$chat}))) {
			bounce_join($nick, "#aimchat-$chat");
		} elsif($aim_connections{$nnick}) {
			$chatjoined{$chat} = 1;
			if($chatinvites{$chat}) {
				chat_accept($aim_connections{$nnick}{screennames}{$chatnames{$chat}}{socket}, $chat);
			} else {
				irc_send($chatqueue{$chat});
				delete $chatqueue{$chat};
			}
			irc_send(irc_mode($usnick, "#aimchat-$chat", "+o $nnick"));
		}
	} elsif(/^INVITE +(\S+) +:?#aimchat-(\d+)/i) {
		my $recipient = noprefix($1);
		my $chat = $2;
		my $topic = $chattopics{$chat};

		$topic =~ s/^{.+?} //;
		chat_invite($aim_connections{$nnick}{screennames}{$chatnames{$chat}}{socket}, $chat, "Please come to $topic.", $recipient) if $aim_connections{$nnick};
	} elsif(/^MODE +#aimchat-(\d+) +:?(.+)/i) {
		my $chat = $1;
		my $modes = $2;
		my ($mode, $parms, @matches, @modes, @params, @tparams, $params, $modestring, $modechar, $modeparm, $modetype, $status);

		irc_send(irc_error($nick, 504, "You cannot change modes in AIM chat channels.")) if $aim_connections{$nnick};

		$modes =~ tr/+-/-+/;
		$modes =~ s/\s*\d+[\r\n]*$// unless $aim_connections{$nnick};
		#Toc::debug_print("Modes: $modes", "errors", 3);
		@matches = $modes =~ m/([-+][a-zA-Z]+)\s*/g or Toc::debug_print("Mode parse failed.", "errors", 3);
		foreach $modestring(@matches) {
			#Toc::debug_print("Mode parse suceeded: $modestring", "errors", 3);
			$modetype = substr($modestring, 0, 1, "");
			#Toc::debug_print("modetype is $modetype", "errors", 3);
			MODE: while($modechar = substr($modestring, 0, 1, "")) {
				#Toc::debug_print("Got modechar $modechar", "errors", 3);
				if($modechar =~ /[vbokl]/) { #Mode takes a parm
					$modes =~ s/(?:\s|\A)([^-+]\S*)(?:\s|\Z)/ / or next MODE;
					$modeparm = $1;
					#Toc::debug_print("Mode takes parm, parm is $modeparm", "errors", 3);
				} else {
					$modeparm = "";
				}
				if($modechar eq "o" and normalize($modeparm) eq normalize($usnick)) {
					if($modetype eq "+") {
						irc_send(irc_mode(($servermode eq "ts") ? $us : $usnick, "#aimchat-$chat", "+o $usnick"));
					}
				} elsif($modechar eq "o" and $aim_connections{normalize($modeparm)} and $modetype eq "-") {
					#Do nothing
				} elsif(($modechar eq "t" or $modechar eq "s" or $modechar eq "n" or $modechar eq "i") and $modetype eq "-") {
					#Do nothing
				} else {
					#Toc::debug_print("Adding to \@modes: (char => $modechar, type => $modetype, parm => $modeparm)", "errors", 3);
					push @modes, { char => $modechar, type => $modetype, parm => $modeparm };
				}
			}
		}
		#foreach $mode(@modes) {
		#	Toc::debug_print("Got mode: " . $mode->{type} . $mode->{char} . " " . $mode->{parm}, "irc", 3);
		#}

		$modestring = "";
		$parms = "";
		foreach $mode(sort { $a->{type} cmp $b->{type} } @modes) {
			if($mode->{type} eq "-" and not $status & 1) { #We have a -, modestring doesn't
				$modestring .= "-";
				$status |= 1;
			} elsif($mode->{type} eq "+" and not $status & 2) { #We have a +, modestring doesn't
				$modestring .= "+";
				$status |= 2;
			}
			$modestring .= $mode->{char};
			$parms .= " $mode->{parm}" if $mode->{parm};
		}

		$modestring .= $parms;

		#Toc::debug_print("Mode parse final: $modestring", "errors", 3);

		irc_send(irc_mode($usnick, "#aimchat-$chat", $modestring)) if $modestring;
	} elsif(/^TOPIC +#aimchat-(\d+)/i) {
		irc_send(irc_error($nick, 505, "Cannot change topic in AIM chat channels."));
		irc_send(irc_topic($usnick, "#aimchat-$1", $chattopics{$1}));
	} elsif(/^KICK +#aimchat-(\d+) +(\S+)/i) {
		irc_send(irc_error($nick, 503, "Cannot kick users from AIM chat channels."));
		irc_send(irc_join($2, "#aimchat-$1"));
		if(normalize($2) eq normalize($usnick)) {
			irc_send(irc_mode(($servermode eq "ts") ? $us : $usnick, "#aimchat-$1", "+o $usnick"));
		}
	} elsif(/^PART +#aimchat-(\d+)/i) {
		if(exists $aim_connections{$nnick}{screennames}{$chatnames{$1}}) {
			Toc::debug_print("$nick left aimchat $1 ($chattopics{$1}).", "chat", 1);
			if($aim_connections{$nnick} and $chattopics{$1}) {
				chat_leave($aim_connections{$nnick}{screennames}{$chatnames{$1}}{socket}, $1) if $aim_connections{$nnick};
				irc_send(irc_part($usnick, "#aimchat-$1"));
				foreach $who(keys %{$chats{$1}}) {
					delete $chats{$1}{$who};
					delete $nicks{normalize($who)}{"chat-$1"};
					irc_send(irc_part(":$prefix$who", "#aimchat-$1"));
				}
				delete $chattopics{$1};
				delete $chatnames{$1};
				delete $chatjoined{$1};
			}
		}
	} elsif(!/#aimirc-debug/i and /^PART +#aimirc-(\S+)/i) {
		my $screenname = $1;
		my $dude;

		if(exists $aim_connections{$nnick}{screennames}{$screenname} and $aim_connections{$nnick}{screennames}{$screenname}{inchan}) {
			$aim_connections{$nnick}{screennames}{$screenname}{inchan} = 0;
			foreach $dude(keys %nicks) {
				next unless $nicks{$dude}{$screenname};
				irc_send(irc_part("$prefix$dude", "#aimirc-$screenname"));
			}
			irc_send(irc_part($usnick, "#aimirc-$screenname"));
		}
	} elsif(!/#aimirc-debug/i and (/^(PRIVMSG|NOTICE) +$usnick(\@\S+)? +:?(.+)/i or /^(PRIVMSG|NOTICE) +#aimirc-(\S+) +:?(.+)/i)) {
		my($cmd, $param, $extra, $connection, $screenname, $sndata, %config);

		$screenname = $connection = $sndata = "";
		$screenname = $2 if exists $aim_connections{$nnick}{screennames}{$2};
		$screenname ||= $aim_connections{$nnick}{aimnick} if exists $aim_connections{$nnick};

		Toc::debug_print("Received IRC command from '$screenname'", "irc", 2);

		$msg = process_ctcp($nnick, $usnick, $3, $screenname);
		return unless $msg;

		$cmd = undef; $extra = undef; $param = undef;
		$msg =~ /(\S+) ?(\S*)( ?.*)/ or $cmd = $msg;
		$cmd = $1 unless $cmd; $param = $2 if $2 or $2 eq "0"; $extra = substr($3, 1) || "" if $3;
		$cmd ||= $msg; #For cmds w/o param
		#warn "Cmd: $cmd\nParam: $param: Extra: $extra\n\n";
		$nick = lc($nick);
		$param ||= "";

		if($aim_connections{$nnick}) {
			$connection = $aim_connections{$nnick} if exists $aim_connections{$nnick} and ref $aim_connections{$nnick};
			$sndata = $connection->{screennames}{$screenname} if $connection;
			%config = deref get_config $screenname if $screenname;
		}

		unless($screenname or ($cmd eq "stats") or ($cmd eq "signon") or ($cmd eq "help")) {
			irc_send(irc_privmsg($usnick, $nick, "You must use the signon command to sign on to AOL Instant Messenger before using this service."));
		} elsif($cmd eq "stats") {
			if($param eq "users") {
				irc_send(irc_privmsg($usnick, $nick, scalar(keys(%irc_connections)) . ": " . join(", ", keys %irc_connections)));
			} elsif($param eq "uptime") {
				my($days, $hours, $minutes, $seconds);
				$seconds = time - $starttime;
				$minutes = int($seconds / 60);
				$seconds -= $minutes*60;
				$hours = int($minutes / 60);
				$minutes -= $hours*60;
				$days = int($hours / 24);
				$hours -= $days*24;
				irc_send(irc_privmsg($usnick, $nick, sprintf("Up $days day(s), %02d:%02d:%02d", $hours, $minutes, $seconds)));
			}
		} elsif($cmd eq "signon") {
			$param = normalize $param;
			unless($param and $extra) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: signon screenname password"));
			} else {
				if($connection->{screennames}{$param}) {
					irc_send(irc_privmsg($usnick, $nick, "You are already signed onto AOL instant messenger under that screenname."));
				} else {
					irc_send(irc_privmsg($usnick, $nick, "Signing on to AOL Instant Messenger..."));
					do_signon($param, $extra, $usnick, $nick);
				}
			}
		} elsif ($cmd eq "buddylist") {
			my(%groups, $buddy, $group, $xbuddy, $evil, $line, $buddat);
			my $buddies = 0;

			foreach $buddy(sort keys %{$config{Buddies}}) {
				$xbuddy = $config{Buddies}{$buddy}{unnormalized} || $buddy;
				push @{$groups{$config{Buddies}{$buddy}{group}}}, $xbuddy;
			}
			foreach $group(sort keys %groups) {
				irc_send(irc_privmsg($usnick, $nick, "$group:", "", "", $screenname));
				foreach $buddy(sort @{$groups{$group}}) {
					$buddat = $config{Buddies}{normalize $buddy};
					$evil = $buddat->{evil};
					$line = "\t$buddy";
					$line .= " [online]" if $buddat->{online};
					$line .= " [away]" if $buddat->{online} and substr($buddat->{class}, 2, 1) eq "U";
					$line .= " [warning level $evil%]" if $evil;
					irc_send(irc_privmsg($usnick, $nick, $line, "", "", $screenname));
					$buddies++;
				}
			}
			irc_send(irc_privmsg($usnick, $nick, "Your buddylist is empty.", "", "", $screenname)) unless $buddies;
		} elsif ($cmd eq "onbuddies") {
			my(%groups, $buddy, $group, $xbuddy, $line, $evil, $buddat);
			my $onbuddies = 0;

			foreach $buddy(sort keys %{$config{Buddies}}) {
				$xbuddy = $config{Buddies}{$buddy}{unnormalized} || $buddy;
				push @{$groups{$config{Buddies}{$buddy}{group}}}, $xbuddy if $config{Buddies}{$buddy}{online};
			}
			foreach $group(sort keys %groups) {
				irc_send(irc_privmsg($usnick, $nick, "$group:", "", "", $screenname));
				foreach $buddy(sort @{$groups{$group}}) {
					$buddat = $config{Buddies}{normalize $buddy};
					$evil = $buddat->{evil};
					$line = "\t$buddy";
					$line .= " [away]" if substr($buddat->{class}, 2, 1) eq "U";
					$line .= " [warning level $evil%]" if $evil;
					irc_send(irc_privmsg($usnick, $nick, $line, "", "", $screenname));
					$onbuddies++;
				}
			}
			irc_send(irc_privmsg($usnick, $nick, "None of your buddies are online.", "", "", $screenname)) unless $onbuddies;
		} elsif ($cmd eq "permitlist") {
			irc_send(irc_privmsg($usnick, $nick, join(" ", sort keys(%{$config{permit}})), "", "", $screenname));
			irc_send(irc_privmsg($usnick, $nick, "Your permit list is empty.", "", "", $screenname)) unless haskeys $config{permit};
		} elsif ($cmd eq "denylist") {
			irc_send(irc_privmsg($usnick, $nick, join(" ", sort keys(%{$config{deny}})), "", "", $screenname));
			irc_send(irc_privmsg($usnick, $nick, "Your deny list is empty.", "", "", $screenname)) unless haskeys $config{deny};
		} elsif ($cmd eq "signoff") {
			do_signoff($nnick, $sndata->{socket});
		} elsif ($cmd eq "buddyinfo") {
			unless($param) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: buddyinfo screenname", "", "", $screenname));
			} else {
				$param = normalize $param;
				my $buddyconf = $config{Buddies}{$param};
				if($buddyconf->{online}) {
					local $^W = 0;
					$msg = "Buddy Info for $buddyconf->{unnormalized}\r\n";
					$msg .= "Group: \t\t$buddyconf->{group}\r\n";
					$msg .= "Signon Time: \t" . localtime($buddyconf->{signon}) . "\r\n";
					$msg .= "Idle Time: \t\t$buddyconf->{idle} minutes\r\n";
					$msg .= "User Class: \t" . parseclass($buddyconf->{class}) . "\r\n";
					$msg .= "Warning Level: \t$buddyconf->{evil}%\r\n";
					irc_send(irc_privmsg($usnick, $nick, $msg, "", "", $screenname));
				} else {
					irc_send(irc_privmsg($usnick, $nick,  "That person is either not on your buddy list or not signed on.", "", "", $screenname));
				}
			}
		} elsif ($cmd eq "add_buddy") {
			unless($param) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: add_buddy screenname [group]", "", "", $screenname));
			} else {
				$param = lc($param);
				$group = $extra || "Buddies";
				add_buddy($sndata->{socket}, [split(/,/, $param)], $group);
				irc_send(irc_privmsg($usnick, $nick, "Buddylist updated.", "", "", $screenname));
			}
		} elsif ($cmd eq "remove_buddy") {
			unless($param) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: remove_buddy screenname", "", "", $screenname));
			} else {
				$param = lc($param);
				map { irc_send(irc_part("$prefix" . normalize $_, "#aimirc-$screenname", "Removed from buddylist.")) if delete $nicks{normalize $_}{$screenname} and $sndata->{inchan} } split(/,/, $param);
				remove_buddy($sndata->{socket}, [split(/,/, $param)]);
				irc_send(irc_privmsg($usnick, $nick, "Buddylist updated.", "", "", $screenname));
			}
		} elsif ($cmd eq "evil" or $cmd eq "warn") {
			unless($param) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: $cmd screenname [anon]", "", "", $screenname));
			} else {
				$param = lc($param);
				if($extra ne "anon") {
					$extra = 0;
				} else {
					$extra = 1;
				}
				evil($sndata->{socket}, $param, $extra);
			}
		} elsif ($cmd eq "add_permit") {
			unless($param) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: add_permit screenname", "", "", $screenname));
			} else {
				$param = lc($param);
				add_permit($sndata->{socket}, [split(/,/, $param)]);
				irc_send(irc_privmsg($usnick, $nick, "Permit list updated.", "", "", $screenname));
			}
		} elsif ($cmd eq "add_deny") {
			unless($param) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: add_deny screenname", "", "", $screenname));
			} else {
				$param = lc($param);
				add_deny($sndata->{socket}, [split(/,/, $param)]);
				irc_send(irc_privmsg($usnick, $nick, "Deny list updated.", "", "", $screenname));
			}
		} elsif ($cmd eq "remove_deny") {
			unless($param) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: remove_deny screenname", "", "", $screenname));
			} else {
				$param = lc($param);
				remove_deny($sndata->{socket}, [split(/,/, $param)]);
				irc_send(irc_privmsg($usnick, $nick, "Deny list updated.", "", "", $screenname));
			}
		} elsif ($cmd eq "remove_permit") {
			unless($param) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: remove_permit screenname", "", "", $screenname));
			} else {
				$param = lc($param);
				remove_permit($sndata->{socket}, [split(/,/, $param)]);
				irc_send(irc_privmsg($usnick, $nick, "Permit list updated.", "", "", $screenname));
			}
		} elsif ($cmd eq "join") {
			unless($param) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: join chat_name", "", "", $screenname));
			} else {
				$extra ? chat_join($sndata->{socket}, "$param $extra") : chat_join($sndata->{socket}, $param);
			}
		} elsif ($cmd eq "join_exchange") {
			unless($param and $extra) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: join_exchange exchange chat_name", "", "", $screenname));
			} else {
				chat_join_exchange($sndata->{socket}, $extra, $param);
			}
		} elsif ($cmd eq "get_permit_mode") {
			irc_send(irc_privmsg($usnick, $nick, "Your permit mode is " . permtype($sndata->{socket}) . ".", "", "", $screenname));
		} elsif ($cmd eq "set_permit_mode") {
			unless($param) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: set_permit_mode newmode", "", "", $screenname));
			} else {
				if($param != 1 and $param != 2 and $param != 3 and $param != 4) {
					irc_send(irc_privmsg($usnick, $nick, "That is not a valid permit mode.  See list_permit_modes for valid permit modes.", "", "", $screenname));
				} else {
					permtype($sndata->{socket}, $param);
					irc_send(irc_privmsg($usnick, $nick, "Permit mode set.", "", "", $screenname));
				}
			}
		} elsif ($cmd eq "list_permit_modes") {
			irc_send(irc_privmsg($usnick, $nick, "1=Permit All, 2=Deny All, 3=Permit if and only if on permitlist, 4=Deny if and only if on denylist", "", "", $screenname));
		} elsif ($cmd eq "whisper") {
			$extra =~ /(\S+) (.*)/;
			unless($param and $1 and $2) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: whisper chat_id screenname text", "", "", $screenname));
			} else {
				if(UNIVERSAL::isa($connection->{screennames}{$chatnames{$param}}{socket}, "IO::Socket")) {
					chat_whisper($connection->{screennames}{$chatnames{$param}}{socket}, $param, $1, $2);
				} else {
					irc_send(irc_privmsg($usnick, $nick, "That is not a valid chat ID.", "", "", $screenname));
				}
			}
		} elsif ($cmd eq "chat_evil" or $cmd eq "chat_warn") {
			$extra =~ /(\S+) ?(.*)/;
			unless($param and $extra) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: $cmd chat_id screenname [anon]", "", "", $screenname));
			} else {
				$foo = undef;
				$foo = "norm" if $2 ne "anon";
				$foo ne "norm" ? $foo = 1 : $foo = 0;
				chat_evil($connection->{screennames}{$chatnames{$param}}{socket}, $param, $1, $foo);
			}
		} elsif ($cmd eq "info" or $cmd eq "get_info" or $cmd eq "get_profile") {
			unless($param) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: info screenname", "", "", $screenname));
			} else {
				$param = lc($param);
				get_info($sndata->{socket}, $param);
			}
		} elsif ($cmd eq "set_info" or $cmd eq "set_profile") {
			my $text;
			unless($param) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: $cmd info", "", "", $screenname));
			} else {
				$extra ? ($text = "$param $extra") : ($text = $param);
				set_info($sndata->{socket}, $text);
				$profiles{safename $screenname} = $text if $saveprofiles > 0;
				irc_send(irc_privmsg($usnick, $nick, "Your profile has been updated.", "", "", $screenname));
			}
		} elsif ($cmd eq "get_dir") {
			unless($param) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: get_dir screenname", "", "", $screenname));
			} else {
				get_directory($sndata->{socket}, $param);
			}
		} elsif ($cmd eq "set_dir") {
			$param = "$param $extra" if $extra;
			if($param and $param ne "set_dir") {
				@temp = split(/:/, $param);
					%temp = (
					first_name => shift @temp,
					middle_name => shift @temp,
					last_name => shift @temp,
					maiden_name => shift @temp,
					city => shift @temp,
					state => shift @temp,
					country => shift @temp,
					allow_web_searches => shift @temp
				);
				set_directory($sndata->{socket}, %temp);
			} else {
				irc_send(irc_privmsg($usnick, $nick, "first name:middle name:last name:maiden name:city:state:country:websearch.  Don't put any colons in any of these.  If you put anything in the websearch field, people can find your directory info using web searches.", "", "", $screenname));
			}
		} elsif ($cmd eq "dir_search") {
			$param = "$param $extra" if $extra;
			if($param and $param ne "dir_search") {
				@temp = split(/:/, $param);
				%temp = (
					first_name => shift @temp,
					middle_name => shift @temp,
					last_name => shift @temp,
					maiden_name => shift @temp,
					city => shift @temp,
					state => shift @temp,
					country => shift @temp,
					allow_web_searches => shift @temp
				);
				directory_search($sndata->{socket}, %temp);
			} else {
				irc_send(irc_privmsg($usnick, $nick, "first name:middle name:last name:maiden name:city:state:country:websearch.  Don't put any colons in any of these.  If you put anything in the websearch field, people can find your directory info using web searches.", "", "", $screenname));
			}
		} elsif ($cmd eq "add") {
			unless($param) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: add screenname", "", "", $screenname));
			} else {
				unless($nicks{noprefix $param}) {
					irc_send(irc_newnick($prefix . normalize $param));
				}
				manglewarn($nick, $param);
				$nicks{noprefix $param}{$screenname} = time;	
				irc_send(irc_privmsg($usnick, $nick, "$param has been created on IRC.", "", "", $screenname));
				irc_send(irc_join("$prefix$param", "#aimirc-$screenname")) if $sndata->{inchan};
			}
		} elsif ($cmd eq "sendidle") {
			unless($param == 0 or $param == 1) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: sendidle (0|1)", "", "", $screenname));
			} else {
				$sndata->{report_idle} = $param;
				irc_send(irc_privmsg($usnick, $nick, "Idle reporting changed.", "", "", $screenname));
			}
		} elsif ($cmd eq "format_nickname" or $cmd eq "format_screenname") {
			unless($param) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: $cmd screenname", "", "", $screenname));
			} else {
				$param .= " $extra" if $extra;
				$sndata->{pending_formatted} = $param;
				format_nickname $sndata->{socket}, $param;
			}
		} elsif ($cmd eq "change_password") {
			unless($param and $extra) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: change_password old_password new_password", "", "", $screenname));
			} else {
				change_password $sndata->{socket}, $param, $extra;
			}
		} elsif ($cmd eq "loadbuddies") {
			$dccget{$nnick} = $screenname;
			irc_send(irc_ctcp($usnick, $nnick, "loadbuddies"));
			irc_send(irc_privmsg($usnick, $nnick, "Please DCC SEND $usnick your buddylist.", "", "", $screenname));
		} elsif ($cmd eq "savebuddies") {
			my $oscar = 0;
			my($config, $message, $group, $buddy, %groups, $filename);

			unless($dccip) {
				irc_send(irc_privmsg($usnick, $nick, "savebuddies is not available on this server - the administrator has not specified a DCC IP in the aimirc configuration file.", "", "", $screenname));
			} else {
				$oscar = 1 if $param and lc($param) ne "toc";

				if($oscar) {
					$config =
"Config {
 version 1
}
User {
 screenName $screenname
}
Buddy {
 list {
";
					#"Borrowed" from conf2str
					#Toc::debug_print("TOC to OSCAR: config is " . Data::Dumper::Dumper(%config), "IRC", 1);
					foreach $buddy(keys %{$config{Buddies}}) {
						$group = $config{Buddies}{$buddy}{group};
						#Toc::debug_print("TOC to OSCAR: putting $buddy in $group", "IRC", 1);
						push @{$groups{$group}}, $buddy;
					}
					foreach $group (sort keys %groups) {
						next if $group eq "permit" or $group eq "deny" or $group eq "permtype" or $group eq "groups";
						$config .= "  $group";
						foreach $buddy(sort @{$groups{$group}}) {
							$config .= " $buddy";
						}
						$config .= "\n";
					}
					$config .= " }\n}\nPrivacy {\n";
					$config .= " allowList " . join(" ", keys %{$config{permit}}) . "\n";
					$config .= " blockList " . join(" ", keys %{$config{deny}}) . "\n";
					$config .= " pref ";
					if($config{permtype} == 1) {
						$config .= "AllowAll";
					} elsif($config{permtype} == 2) {
						$config .= "DenyAll";
					} elsif($config{permtype} == 3) {
						$config .= "AllowSome";
					} else {
						$config .= "DenySome";
					}
					$config .= "\n}\n";
					$filename = "$screenname.blt";
				} else {
					$config = conf2str(%config);
					$filename = "$screenname.txt";
				}

				$message = irc_dcc($usnick, $nnick, $config, "savebuddies", $filename, $screenname);
				if($message) {
					irc_send($message);
					irc_send(irc_ctcp($usnick, $nick, "savebuddies"));
					irc_send(irc_privmsg($usnick, $nnick, "Please accept the DCC SEND from $usnick.  The file being sent is your buddylist.", "", "", $screenname));
				}
			}
		} elsif ($cmd eq "add_pounce") {
			unless($param and $extra) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: add_pounce screenname text", "", "", $screenname));
			} elsif($savepounces <= 0) {
				irc_send(irc_privmsg($usnick, $nick, "Pounces have been disabled by the administrator of this server.", "", "", $screenname));
			} else {
				push @{$sndata->{pounces}}, {who => $param, what => $extra};
				irc_send(irc_privmsg($usnick, $nick, "Pounce added.", "", "", $screenname));
				push @{$pounces{safename $screenname}}, {who => $param, what => $extra} if $savepounces > 0;
			}
		} elsif ($cmd eq "remove_pounce") {
			unless(defined $param) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: remove_pounce number", "", "", $screenname));
				return;
			}
			$param = 0 if $param eq "";
			if($savepounces <= 0) {
				irc_send(irc_privmsg($usnick, $nick, "Pounces have been disabled by the administrator of this server.", "", "", $screenname));
			} elsif($sndata->{pounces}->[$param]) {
				splice(@{$sndata->{pounces}}, $param, 1);
				splice(@{$pounces{safename $screenname}}, $param, 1) if $savepounces > 0;
				irc_send(irc_privmsg($usnick, $nick, "Pounce deleted.", "", "", $screenname));
			} else {
				irc_send(irc_privmsg($usnick, $nick, "That pounce does not exist - do \"/msg $usnick list_pounces\" for a list of pounces.", "", "", $screenname));
			}
		} elsif ($cmd eq "list_pounces") {
			if($savepounces <= 0) {
				irc_send(irc_privmsg($usnick, $nick, "Pounces have been disabled by the administrator of this server.", "", "", $screenname));
			} else {
				$i = 0;
				foreach $pounce(@{$sndata->{pounces}}) {
					irc_send(irc_privmsg($usnick, $nick, "$i: $pounce->{who} == $pounce->{what}", "", "", $screenname));
					$i++;
				}
				irc_send(irc_privmsg($usnick, $nick, "You have no pounces.", "", "", $screenname)) if $i == 0;
			}
		} elsif ($cmd eq "help") {
			$foo = ":$usnick PRIVMSG $nick";
			$foo = ":$usnick PRIVMSG #aimirc-$screenname" if $sndata->{inchan};
			if($param eq "basics") {
				irc_send("$foo :help - Show this screen.\r\n", 1);
				irc_send("$foo :signon screenname pass - Sign on to AOL Instant Messenger (AIM).  You must do this before any of the other commands.\r\n", 1);
				irc_send("$foo :signoff - Sign off of AIM.\r\n", 1);
				irc_send("$foo :add screenname - Create an IRC nickname for screenname.  Use this to talk to someone who's not on your buddylist.\r\n", 1);
				irc_send("$foo :get_permit_mode - See your current permit mode.\r\n", 1);
				irc_send("$foo :set_permit_mode newmode - Set your permit mode.\r\n", 1);
				irc_send("$foo :list_permit_modes - List the valid permit modes and their definitions.\r\n", 1);
			} elsif($param eq "buddies") {
				irc_send("$foo :NOTE: For the commands that take screenname[,screenname2,...screennameN] as a parameter, you must have only commas between the screennames.\r\n", 1);
				irc_send("$foo :You may NOT have spaces between the screennames!\r\n", 1);
				irc_send("$foo : \r\n", 1);
				irc_send("$foo :add_permit screenname[,screenname2,...,screennameN] - Add screenname (possibly multiple screenname) to your permit list, removing from deny list.\r\n", 1);
				irc_send("$foo :add_deny screenname[,screenname2,...,screennameN] - Add nick (possibly multiple screenname) to your deny list, removing from permit list.\r\n", 1);
				irc_send("$foo :buddyinfo screenname - Get signon time, idle time, evil level, and user class for a buddy.\r\n", 1);
				irc_send("$foo :add_buddy screenname[,screenname2,...,screennameN] [group] - Add screenname (possibly multiple screennames) to your buddy list.  If you give a group, the screenname will be added to that buddy group.\r\n", 1);
				irc_send("$foo :remove_buddy screenname[,screenname2,...,screennameN] - Remove screenname (possibly multiple screennames) from your buddy list.\r\n", 1);
				irc_send("$foo :warn screenname [anon] - Warn screenname, optionally anonymously.\r\n", 1);
				irc_send("$foo :remove_permit screenname[,screenname2,...,screennameN] - Remove screenname (possibly multiple screennames) from permit list.\r\n", 1);
				irc_send("$foo :remove_deny screenname[,screenname2,...,screennameN] - Remove screenname (possibly multiple screennames) from deny list.\r\n", 1);
				irc_send("$foo :onbuddies - List buddies who are currently signed on (and who don't have you on block.)\r\n", 1);
				irc_send("$foo :buddylist - List everyone on your buddylist.\r\n", 1);
				irc_send("$foo :permitlist - See who is on your permit list.\r\n", 1);
				irc_send("$foo :denylist - See who is on your deny list.\r\n", 1);
				irc_send("$foo :savebuddies [OSCAR] - DCC SENDs you a copy of your buddylist.  By default it will be in \"TOC format\" - use the OSCAR parameter for \"OSCAR format\".\r\n", 1) if $dccip;
				irc_send("$foo :loadbuddies - DCC GETs a copy of your buddylist and uses that as your new buddylist.  You must do this before sending the file.\r\n", 1);
				irc_send("$foo : \r\n", 1);
				irc_send("$foo :Note on savebuddies\\loadbuddies: savebuddies will send you a CTCP savebuddies (loadbuddies sends CTCP loadbuddies.\r\n", 1);
				irc_send("$foo :This allows IRC client scripts to be written to automate the sending and receiving of the file.\r\n", 1);
				irc_send("$foo :There are two buddylist formats which savebuddies and loadbuddies understand.\r\n", 1);
				irc_send("$foo :The preferred format, TOC format, is used internally by TOC and most TOC clients will export in this format.\r\n", 1);
				irc_send("$foo :OSCAR format is the format that the Windows AOL Instant Messenger client exports its buddylist in.\r\n", 1);
			} elsif($param eq "chat") {
				irc_send("$foo :join chat_name - Create/join a chatroom called chat_name.\r\n", 1);
				irc_send("$foo :join_exchange exchange chat_name - Create/join a chatroom in a different exchange (see below.)\r\n", 1);
				irc_send("$foo :whisper chat_id user message - Whisper to user in chat chat_id (the chat_id is the number after #aimchat- in the channel name.)\r\n", 1);
				#I don't think AOL has implemented this. --MS
				#irc_send("$foo :chat_evil chat_id nick [anon] (or chat_warn chat_id nick [anon]) - Warn nick inside chat_id, optionally anonymously.\r\n", 1);
				irc_send("$foo : \r\n", 1);
				irc_send("$foo :Note on join_exchange: The default exchange is 4.  However, many AIM chats (including most/all listed in AOL's 'Hot Chats' use exchange 5.\r\n", 1);
				irc_send("$foo : \r\n", 1);
				irc_send("$foo :To invite someone into a chat, use the IRC INVITE command on their AIM- screenname.\r\n", 1);
				irc_send("$foo :Example: /invite AIM-SomeDude #aimchat-1234\r\n", 1);
				irc_send("$foo :Your IRC client might have an easier way to do that - many allow you to omit the channel name when inviting into the channel you are currently in.\r\n", 1);
			} elsif($param eq "misc") {
				irc_send("$foo :get_profile screenname - Get profile for screenname.\r\n", 1);
				irc_send("$foo :set_profile new profile - Set your profile.  You can use some HTML formating.\r\n", 1);
				irc_send("$foo :get_dir screenname - Get directory info for screenname.\r\n", 1);
				irc_send("$foo :set_dir [info] - Without info, gives you the syntax that info must be in.  With info, sets your directory info.\r\n", 1);
				irc_send("$foo :dir_search [info] - Without info, gets the syntax that info must be in (the same as that of set_dir).  With info, searches the AOL Instant Messenger directory.\r\n", 1);
				irc_send("$foo :sendidle (0|1) - Send the TOC server your idle information?\r\n", 1);
				irc_send("$foo :format_screenname screenname - Change the formatting (capitalization, spaces) of your screenname\r\n", 1);
				irc_send("$foo :change_password old_password new_password - Change your AIM password\r\n", 1);
			} elsif($param eq "debug") {
				if($debug) {
					irc_send("$foo :restart - Restart aimirc.  This will close the IRC connection and all AIM connections and launch a new aimirc process.\r\n", 1);
					irc_send("$foo :newnick nick - Create a new nickname on irc.\r\n", 1);
					irc_send("$foo :setlevel debug_channel level - Set debugging channel debug_channel to level (higher is more verbose, 1 to disable).  The special channel \"all\" will set the level of all channels at once.\r\n", 1);
					irc_send("$foo :showlevels - List all debugging channels and their levels.\r\n", 1);
					irc_send("$foo :rehash - Reload /etc/aimirc.conf and $home/.aimirc .\r\n", 1);
					irc_send("$foo :reload - Evaluates $0.  This should let you make almost any change to Toc.pm or aimirc without having to do a full restart.\r\n", 1);
					irc_send("$foo :raw who text - Send a raw IRC or AIM command (AIM commands are SFLAP-encoded but not quoted.) If who is irc, it will be sent as an IRC command.  If who is the IRC nickname or AIM nickname of someone connected to this aimirc server, text will be sent over that AIM connection.\r\n", 1);
					irc_send("$foo :inject text - Act as though we got text from the IRC server.\r\n", 1);
					irc_send("$foo :eval text - Evaluate text as Perl code.  All exceptions will be trapped and displayed.\r\n", 1);
				} else {
					irc_send("$foo :Debugging support is not enabled.  Edit /etc/aimirc.conf or $home/.aimirc and send SIGHUP to PID $$.\r\n", 1);
				}
			} elsif($param eq "multinick") {
				irc_send("$foo :To sign on multiple AIM screennames under your current IRC connection, just use multiple signon commands.\r\n", 1);
				irc_send("$foo :The first screenname you sign on will be the \"default screenname\".\r\n", 1);
				irc_send("$foo :The default screenname is the screenname which outgoing IMs are sent to and which $usnick commands; such as add_buddy, remove_buddy, and signoff; effect.\r\n", 1);
				irc_send("$foo :Note that messages/whispers to chatrooms will always be sent with the screenname that joined the chatroom.\r\n", 1);
				irc_send("$foo :When you receive an incoming IM on a screenname other than the default one, {screenname} will be prepended to the IM.\t\n", 1);
				irc_send("$foo :multinick commands:\r\n", 1);
				irc_send("$foo :\tlistnames - list screennames that you are signed on as.  Also tells you your default screenname.\r\n", 1);
				irc_send("$foo :\tswitchname screenname - switch to a new default screenname\r\n", 1);
				irc_send("$foo :\tsignoffall - sign off all screennames\r\n", 1);
			#} elsif($param eq "introduction") {
			#	irc_send("$foo :
			} elsif($param eq "pounce") {
				irc_send("$foo :A pounce will automatically send an IM to a buddy when that buddy comes online.\r\n", 1);
				irc_send("$foo :Your pounces will be saved when you sign off but cannot trigger unless you are signed on.\r\n", 1);
				irc_send("$foo :When you sign on, you will be reminded if you have any untriggered pounces.\r\n", 1);
				irc_send("$foo :Each pounce is deleted after it is triggered, so it only will happen once.\r\n", 1);
				irc_send("$foo :Pounce commands:\r\n", 1);
				irc_send("$foo :\tadd_pounce screenname text - Pounce on screenname with a message of text.\r\n", 1);
				irc_send("$foo :\tremove_pounce number - Remove pounce number.  You can find the number for the pounce you wish to remove by doing a list_pounces.\r\n", 1);
				irc_send("$foo :\tlist_pounces - List your remaining pounces.\r\n", 1);
			} else {
				irc_send("$foo :aimirc $version, (c)1999-2001 Matthew Sachs.\r\n", 1);
				irc_send("$foo :aimirc homepage: http://www.zevils.com/programs/aimirc/\r\n", 1);
				irc_send("$foo :This program is licensed under Version 2 the GNU Public License.\r\n", 1);
				irc_send("$foo :A copy of the license is available at http://www.gnu.org/copyleft/gpl.txt\r\n", 1);
				irc_send("$foo :To see the commands available for a specific topic, use the command help topic.  The following topics are available:\r\n", 1);
				irc_send("$foo :\tbasics - basic commands\r\n", 1);
			 	irc_send("$foo :\tbuddies - buddylist manipulation, etc.\r\n", 1);
				irc_send("$foo :\tchat - chatroom commands\r\n", 1);
				irc_send("$foo :\tmisc - miscellaneous commands\r\n", 1);
				irc_send("$foo :\tmultinick - using aimirc with multiple AIM screennames from one IRC connection.\r\n", 1);
				irc_send("$foo :\tpounce - pounce commands and overview\r\n", 1) if $savepounces > 0;
				#irc_send("$foo :\tintroduction - introduction to aimirc and AOL Instant Messenger.\r\n", 1);
				irc_send("$foo :NOTE: Remove all spaces from screennames (also referred to as nicknames or nicks) before using in any AIMIRC command or operation.  nick is the AIM nick, not the IRC one created by prepending $prefix.\r\n", 1);
				irc_send("$foo :AIM stands for AOL Instant Messenger, which is a trademark of America Online, Inc.\r\n", 1);
				irc_send("$foo :To send an IM to someone whose screenname is SomeDude, send an IRC message to ${prefix}SomeDude.\r\n", 1);
				irc_send("$foo :That person must be on your buddylist, have sent you an IM recently, or be added to IRC via the add command.\r\n", 1);
				irc_send("$foo : \r\n", 1);
				irc_send("$foo :You need an AOL Instant Messenger account to use aimirc.  Get one at http://aim.aol.com/aimnew/Aim/register.adp\r\n", 1);
			}
		#} elsif($cmd eq "webpage") {
		#	irc_send(irc_privmsg($usnick, $nnick, html2txt(get($param), $nnick))) if $param;
		} elsif($cmd eq "switchname") {
			unless($param) {
				irc_send(irc_privmsg($usnick, $nnick, "Usage: switchname screenname", "", "", $screenname));
			} else {
				if(switchnick($nnick, normalize $param)) {
					irc_send(irc_privmsg($usnick, $nnick, "You are not signed on under that screenname!", "", "", $screenname));
				} else {
					irc_send(irc_privmsg($usnick, $nnick, "Your default screenname is now $param.", "", "", $param));
				}
			}
		} elsif($cmd eq "signoffall") {
			do_signoff_all($nnick);
		} elsif($cmd eq "listnames") {
			irc_send(irc_privmsg($usnick, $nick, "Your default screenname is " . $sndata->{formatted} . ".", "", "", $screenname));
			foreach $screenname(keys %{$connection->{screennames}}) {
				irc_send(irc_privmsg($usnick, $nick, $connection->{screennames}{$screenname}{formatted}, "", "", $screenname));
			}
		} else {
			irc_send(irc_privmsg($usnick, $nick, "Unknown command - /msg $usnick help for help.", "", "", $screenname));
		}
	} elsif(/^PRIVMSG +(\S+)(\@\S+)? +:?(.+)/i) { #$nick sent $3 to $1 (where $1 ne $usnick)
		$screenname = normalize($aim_connections{$nnick}{screenname});

		$target = noprefix($longnicks{normalize($1)}); $msg = $3;
		$recipient = normalize($1);
		$msg = process_ctcp($nnick, normalize $1, $msg, $screenname);
		return unless $msg;

		if($recipient eq "#aimirc-debug" and $debug) {
			$msg =~ s/^(aimserv)\S*\s+//;
			if($msg eq "restart" and $1) {
				phoenix;
			} elsif($msg =~ /^newnick (.+)/ and $1) {
				irc_send(irc_newnick($1));
			} elsif($msg =~ /^setlevel (\S+) (\S+)/) {
				if($1 eq "all") {
					foreach $level(keys %debug) { $debug{$level} = $2; }
				} else {
					$debug{$1} = $2;
				}
			} elsif($msg =~ /^rehash/) {
				&rehash;
			} elsif($msg =~ /^reload/) {
				&reload;
			} elsif($msg =~ /^showlevels/) {
				foreach $level(keys %debug) { irc_send(irc_privmsg($usnick, "#aimirc-debug", "$level: $debug{$level}")); }
			} elsif($msg =~ /^inject (.+)/ and $1) {
				process_irc_message($1);
			} elsif($msg =~ /^raw (\S+) (.+)/ and $1 and $2) {
				if($1 eq "irc") {
					irc_send("$2\r\n");
				} elsif($aim_connections{$1}) {
					sflap_put($aim_connections{normalize($1)}{socket}, sflap_encode($2, 0, 1));
				} else {
					$success = 0;
					AIMNICK: foreach $nick(keys %aim_connections) {
						$nnick = normalize($nick);
						if(normalize($aim_connections{$nnick}{aimnick}) eq normalize($1)) {
							$success = 1;
							sflap_put($aim_connections{$nnick}{socket}, sflap_encode($2, 0, 1));
							last AIMNICK;
						}
					}
					irc_send(irc_privmsg($usnick, "#aimirc-debug", "Couldn't find that person.")) unless $success;
				}
			} elsif($msg =~ /^eval (.+)/ and $1) {
				eval $1;
				irc_send(irc_privmsg($usnick, "#aimirc-debug", $@, "EVAL: "));
			} else {
				irc_send(irc_privmsg($usnick, "#aimirc-debug", "Invalid debug command - /msg aimserv help debug for help)"));
			}
		} elsif ($recipient =~ /^#aimchat-(\d+)$/) {
			chat_send($aim_connections{$nnick}{screennames}{$chatnames{$1}}{socket}, $1, $msg) if $aim_connections{$nnick};
		} elsif ($recipient !~ /^#/) {
			if($aim_connections{$nnick}) {
				if($irc_connections{normalize $target} and $shortcircuit) {
					got_im($screenname, $target, txt2html($msg), 0);
				} else {
					message($sndata->{socket}, $target, $msg);
				}
				irc_send(irc_privmsg($usnick, "matthewg", "Setting \$nicks{$target}{$screenname} to time"));
				$nicks{$target}{$screenname} = time if $nicks{$target}{$screenname} != -1;
			} else {
				irc_send(irc_privmsg($usnick, $nick, "You must be signed onto AOL Instant Messenger via aimirc to send messages to AIM users.  /msg AIMServ help for details."));
			}
		}
	} elsif(/^AWAY *(.*)/) {
		if($1 =~ /:?(.*)/) {
			$irc_away{$nnick} = $1;
			if($aim_connections{$nnick}) {
				$aim_connections{$nnick}{away} = $1;
				foreach $screenname(keys %{$aim_connections{$nnick}{screennames}}) {
					set_away($aim_connections{$nnick}{screennames}{$screenname}{socket}, $1);
				}
			}
		} else {
			delete $irc_away{$nnick};
			if($aim_connections{$nnick}) {
				delete $aim_connections{$nnick}{away};
				foreach $screenname(keys %{$aim_connections{$nnick}{screennames}}) {
					delete $aim_connections{$nnick}{screennames}{$screenname}{away_buddies};
					set_away($aim_connections{$nnick}{screennames}{$screenname}{socket});
				}
			}
		}
	} elsif(/^NICK +(\S+)/) { #Nick change
		if($aim_connections{$nnick}) {
			$newnick = normalize($1);
			foreach $screenname(keys %{$aim_connections{$nnick}{screennames}}) {
				$irc_connections{$screenname} = $newnick;
			}
			$aim_connections{$newnick} = $aim_connections{$nnick};
			$aim_connections{$newnick}{nick} = $newnick;
			delete $aim_connections{$nnick};
		}

		my($dcc, $i);
		for($i = 0; $i <= $#dccqueue; $i++) {
			$dcc = $dccqueue[$i];
			if($dcc->{direction} eq "SEND" and normalize $dcc->{to} eq $nnick) {
				$dccqueue[$i]->{to} = $newnick;
			} elsif(normalize $dcc->{from} eq $nnick) {
				$dccqueue[$i]->{from} = $newnick;
			}
		}

	} elsif(/^QUIT/) {
		delete $irc_away{$nnick};

		my($dcc, $i);
		for($i = 0; $i <= $#dccqueue; $i++) {
			$dcc = $dccqueue[$i];
			Toc::debug_print("DCC $dcc->{direction} from $dcc->{from} to $dcc->{to}.  Put $dcc->{put}, got $dcc->{got}", "DCC", 2);
			next unless $dcc->{direction} eq "SEND" and $dcc->{put} == -1 and normalize $dcc->{to} eq $nnick;
			Toc::debug_print("Closing DCC listen socket for transfer to $nnick", "DCC", 1);
			$dcc->{ssocket}->close;
			splice(@dccqueue, $i, 1);
			$i--;
		}
		do_signoff_all($nnick, 1) if $aim_connections{$nnick};
	} elsif(/^PING/) {
		irc_send(irc_pong());
	}
}

# Process an incoming TOC message
sub process_aim_message($$$) {
	my ($connection, $msg, $screenname) = @_;
	my($cmd, $val, $inick, $ar, $pounce, %pouncehash, $pouncenum, $sndata, $pouncecount);
	my($nnick) = normalize($connection->{nick});

	$sndata = $connection->{screennames}{$screenname};

	my($multinick, $socket) = ("", $connection->{screennames}{$screenname}{socket});
	$multinick = "{$screenname} " if $screenname ne $connection->{aimnick} and not $sndata->{inchan};

	#This kludge is needed because we set paused at signon and we might
	#miss the initial SIGN_ON
	set_pause($socket, 0) if defined $socket and get_pause($socket);

	#warn "AIM got $msg for $connection->{nick}\n";
	$msg =~ /^([^:]+):?(.*)/;
	$cmd = $1; $val = $2;
	if($cmd eq "ERROR") {
		$val =~ /([^:]+):?(.*)/;
		Toc::debug_print("Error $1: " . aim_strerror($1, $2), "errors", 1);
		irc_send(irc_privmsg($usnick, $connection->{nick}, "${multinick}Error $1: " . aim_strerror($1, $2), "", "", $screenname));
		if(!$sndata->{ison}) {
			irc_send(irc_privmsg($usnick, $nnick, "Your attempt to connect to AOL Instant Messenger has failed.", "", "", $screenname));
			do_signoff($nnick, $sndata->{socket}, 1);
		}
	} elsif($cmd eq "DIR_STATUS") {
		if($val == 0) {
			irc_send(irc_privmsg($usnick, $connection->{nick}, "Directory info successfully updated.", "", "", $screenname));
		} else {
			irc_send(irc_privmsg($usnick, $connection->{nick}, "Could not update directory info.", "", "", $screenname));
		}
	} elsif($cmd eq "CONFIG") {
		$msg =~ s/^CONFIG://;
		$sndata->{gotconf} = 1;
		if($msg !~ /\S/ or $msg eq "" or not defined $msg) {
			irc_send(irc_privmsg($usnick, $connection->{nick}, "Woah there, you have an empty configuration!", "", "", $screenname));
			irc_send(irc_privmsg($usnick, $connection->{nick}, "Either you've just created this account or AOL lost the buddylists again.", "", "", $screenname));
			if($buddylists{safename $screenname}) {
				irc_send(irc_privmsg($usnick, $connection->{nick}, "Fortunately, we have a backup of your buddylist from the last time you signed on to this aimirc - we'll load that for you.", "", "", $screenname));
				update_config($socket, $buddylists{safename $screenname});
			} elsif($dcc) {
				irc_send(irc_privmsg($usnick, $connection->{nick}, "If you have a copy of your buddylist from the Win/Mac AIM client or from a savebuddies, you can import it via the loadbuddies command - \"/msg $usnick loadbuddies\".", "", "", $screenname));
				update_config($socket, "m 4\n");
			} else {
				update_config($socket, "m 4\n");
			}
		} else {
			irc_send(irc_privmsg($usnick, $connection->{nick}, "Got your buddylist.", "", "", $screenname));
			$buddylists{safename $screenname} = $msg if $savebuddies > 0;
			update_config($socket, $msg);
		}
	} elsif($cmd eq "NICK") {
		irc_send(irc_privmsg($usnick, $nnick, "You are now connected to AOL Instant Messenger as $val.", "", "", $screenname)) unless $sndata->{ison};
		$sndata->{formatted} = $val;
		if(!$sndata->{ison}) {
			irc_send(irc_privmsg($usnick, $nnick, "You might want to join #aimirc-$screenname"));

			#Hack hack hack
			irc_send(irc_join($usnick, "#aimirc-$screenname"));
			irc_send(irc_mode($us, "#aimirc-$screenname", "+o $usnick"));
			irc_send(irc_invite($usnick, "#aimirc-$screenname", $nnick));
			irc_send(irc_part($usnick, "#aimirc-$screenname"));

			loaddat($screenname);
			$sndata->{ison} = 1;
			if($irc_away{$nnick}) {
				$connection->{away} = $irc_away{$nnick};
				set_away($sndata->{socket}, $irc_away{$nnick});
			}
			if($pounces{safename $screenname}) {
				@{$sndata->{pounces}} = @{$pounces{safename $screenname}};
				$pouncecount = scalar @{$pounces{safename $screenname}};
				irc_send(irc_privmsg($usnick, $nnick, "You have $pouncecount pounce" . ($pouncecount > 1 ? "s" : "") . ".", "", "", $screenname), 2) if $pouncecount > 0;
			}
			if($profiles{safename $screenname}) {
				set_info($sndata->{socket}, $profiles{safename $screenname});
				irc_send(irc_privmsg($usnick, $nnick, "Your profile has been set.", "", "", $screenname), 2);
			}
		}
	} elsif($cmd eq "IM_IN") {
		$val =~ /([^:]+):(.):(.*)/;
		got_im($1, $screenname, $3, $2);
	} elsif($cmd eq "UPDATE_BUDDY") {
		my($xinick, $ircnick, $i, %config, $class, $ison, $evil, $signontime, $idletime);

		$val =~ /([^:]+):(.):([^:]+):([^:]+):([^:]+):(.+)/;
		$inick = $xinick = $1; 
		$ison = $2;
		$evil = $3;
		$signontime = $4;
		$idletime = $5;
		$class = $6;
		$inick =~ tr/ //d;
		$nnick = lc($inick);
		$ircnick = lc($prefix) . $nnick;
		Toc::debug_print("$connection->{nick} UPDATE_BUDDY: $val", "buddies", 1);

		if($ison eq "T") {
			%config = deref(get_config($screenname));

			irc_send(irc_newnick($prefix . $inick)) unless haskeys($nicks{noprefix $nnick});
			unless($config{Buddies}{$nnick}{online}) {
				manglewarn($connection->{nick}, $inick);
				irc_send($sndata->{inchan} ? (irc_join("$prefix$inick", "#aimirc-$screenname") . irc_mode($usnick, "#aimirc-$screenname", "+v $prefix$inick")) : irc_privmsg($usnick, $connection->{nick}, "$multinick$xinick has arrived"));
				$i = 0;
				map { $pouncehash{$i++} = $_ } @{$sndata->{pounces}};
				foreach $pouncenum(sort { $a <=> $b } keys %pouncehash) {
					$pounce = $pouncehash{$pouncenum};
					next unless normalize $pounce->{who} eq $nnick;
					Toc::debug_print("Yep.", "IRC", 1);
					my $class = $config{Buddies}{$nnick}{class};
					my $tmp;
					if(substr($class, 0, 1) eq "A") {
						$tmp = "[automated pounce] " . $pounce->{what};
					} else {
						$tmp = $pounce->{what};
					}
					Toc::debug_print("Sending $tmp.", "IRC", 1);
					message($socket, $nnick, $tmp, 1);
					delete $pouncehash{$pouncenum};
					irc_send(irc_privmsg($usnick, $connection->{nick}, "Pounce $pouncenum sent to $pounce->{who}.", "", "", $screenname));
				}
				@{$sndata->{pounces}} = ();
				map { push @{$sndata->{pounces}}, $_ } values %pouncehash;
				if($savepounces > 0) {
					@{$pounces{$screenname}} = ();
					map { push @{$pounces{$screenname}}, $_ } values %pouncehash;
				}
			} elsif($irc_connections{$screenname} ne normalize $connection->{nick} or $config{Buddies}{$nnick}{evil} >= $evil + 5) { #If it's us, we already know it.  Unless it's decreasing (does AIM tell us every time our warning level goes down 1%?  Only tell the user every 5 just in case.)
				irc_send(irc_privmsg($usnick, $connection->{nick}, "$multinick${xinick}'s warning level has changed to $evil%.", "", "", $screenname)) unless $evil == $config{Buddies}{$nnick}{evil};
			}
			{
				local $^W = 0;
				irc_send(irc_privmsg($usnick, $connection->{nick}, "$multinick$xinick has gone away", "", "", $screenname)) if substr($config{Buddies}{$nnick}{class}, 2, 1) ne "U" and substr($class, 2, 1) eq "U";
				irc_send(irc_privmsg($usnick, $connection->{nick}, "$multinick$xinick is no longer away", "", "", $screenname)) if substr($config{Buddies}{$nnick}{class}, 2, 1) eq "U" and substr($class, 2, 1) ne "U";
			}
			update_buddy($screenname, $xinick, $class, $evil, $signontime, $idletime, 1);
			$nicks{noprefix $nnick}{$screenname} = -1;
		} else {
			update_buddy($screenname, $nnick, $class, $evil, $signontime, $idletime, 0);
			irc_send($sndata->{inchan} ? irc_part("$prefix$nnick", "#aimirc-$screenname", "I have signed off of AOL Instant Messenger.") : irc_privmsg($usnick, $connection->{nick}, "$multinick$xinick has departed"));
			delete $nicks{noprefix $nnick}{$screenname};
			unless(haskeys($nicks{noprefix $nnick}) > 1) {
				irc_send(irc_quit("$prefix$inick", "I signed off of AIM (UPDATE_BUDDY)"));
				delete $nicks{noprefix $nnick};
			}
		}
	} elsif($cmd eq "EVILED") {
		$val =~ /([^:]+):(.*)/;
		$sndata->{evil} = $1;
		irc_send(irc_privmsg($usnick, $connection->{nick}, $multinick . ($2 || "Anonymous") . " has warned you.  Your new warning level is $1%.", "", "", $screenname));
	} elsif($cmd eq "CHAT_JOIN") {
		my($topic);

		$val =~ /([^:]+):(.*)/;
		$topic = $2;
		chomp $topic;

		$chattopics{$1} = "{$screenname} $topic";
		$chatnames{$1} = $screenname;
		irc_send(irc_join($usnick, "#aimchat-$1"));
		irc_send(irc_mode($us, "#aimchat-$1", "+o $usnick"));
		irc_send(irc_mode($usnick, "#aimchat-$1", "+sint"));
		irc_send(irc_topic($usnick, "#aimchat-$1", "{$screenname} $topic"));
		irc_send(irc_privmsg($usnick, $connection->{nick}, "Join IRC channel #aimchat-$1 to join AIM chat $topic.", "", "", $screenname)) unless $chatinvites{$1};
		irc_send(irc_invite($usnick, "#aimchat-$1", $connection->{nick}));
		delete $chatinvites{$1};
		$longnicks{"#aimchat-$1"} = "#aimchat-$1";
	} elsif($cmd eq "CHAT_IN") {
		my $nick;
		my ($sender, $nsender, $msg, $line, @lines);

		$val =~ /([^:]+):([^:]+):(.):(.*)/;

		$sender = $2;
		$sender =~ tr/ //d;
		$nsender = normalize($sender);

		if(normalize($screenname) ne $nsender) {
			$msg = html2txt($4, $nick);

			if(lc($3) eq "t") {
				Toc::debug_print("$sender whispered to $connection->{nick} in chat $1 ($2): $msg", "chat", 2);
				irc_send(irc_privmsg("$prefix$sender", $connection->{nick}, "(whispered in #aimchat-$1): $msg"));
			} else {
				Toc::debug_print("$sender said to $connection->{nick} in chat $1 ($2): $msg", "chat", 2);
				unless($chatjoined{$1}) {
					$chatqueue{$1} .= irc_privmsg("$prefix$sender", "#aimchat-$1", $msg);
				} else {
					irc_send(irc_privmsg("$prefix$sender", "#aimchat-$1", $msg));
				}
			}
		}
	} elsif($cmd eq "CHAT_UPDATE_BUDDY") {
		my($who, @who);

		$val =~ /([^:]+):(.):(.+)/;
		$who = $3;
		$who =~ tr/ //d;

		@who = split(/:/, $who);
		if(lc($2) eq "t") {
			foreach $who(@who) {
				next if normalize($who) eq $screenname;
				$chats{$1}{$who} = 1;
				irc_send(irc_newnick("$prefix$who"));
				irc_send(irc_join("$prefix$who", "#aimchat-$1"));

				$nicks{normalize($who)}{"chat-$1"} = -1;
				manglewarn($connection->{nick}, $who);
			}
		} else {
			foreach $who(@who) {
				next if normalize($who) eq $screenname;
				delete $chats{$1}{$who};
				irc_send(irc_part(ircify($screenname), "#aimchat-$1"));
				delete $nicks{normalize($who)}{"chat-$1"};
			}
		}
	} elsif($cmd eq "CHAT_INVITE") {
		$val =~ /([^:]+):([^:]+):([^:]+):(.*)/;
		Toc::debug_print("$connection->{nick} has been invited to chat $1 ($4) [$2] by $3", "chat", 2);
		$chatinvites{$2} = $connection->{nick};
		$chatnames{$2} = $screenname;
		irc_send(irc_privmsg($usnick, $connection->{nick}, "$3 has invited us to chatroom $1 for the following reason: " . html2txt($4) . ".  To accept, join #aimchat-$2", "", "", $screenname));
		irc_send(irc_invite($usnick, "#aimchat-$2", $connection->{nick}));
	} elsif($cmd eq "GOTO_URL") {
		$val =~ /[^:]+:(.+)/;
		my $html = get("http://toc-d01.blue.aol.com/$1");
		$html =~ s/<I>Legend:.*//m;
		Toc::debug_print($html, "html", 2);
		irc_send(irc_privmsg($usnick, $connection->{nick}, html2txt($html, $connection->{nick}), "", "", $screenname));
	} elsif($cmd eq "ADMIN_NICK_STATUS") {
		$val =~ /([^:]+):?(.*)/;
		if($1 != 0) {
			delete $sndata->{pending_formatted};
			irc_send(irc_privmsg($usnick, $connection->{nick}, "Nick status - return code $1 (params $2)", "", "", $screenname));
		} else {
			$sndata->{formatted} = delete $sndata->{pending_formatted};
			irc_send(irc_privmsg($usnick, $connection->{nick}, "Nickname successfully reformatted.", "", "", $screenname));
		}
	} elsif($cmd eq "ADMIN_PASSWD_STATUS") {
		$val =~ /([^:]+):?(.*)/;
		if($1 != 0) {
			irc_send(irc_privmsg($usnick, $connection->{nick}, "Password status - return code $1 (params $2)", "", "", $screenname));
		} else {
			irc_send(irc_privmsg($usnick, $connection->{nick}, "Password successfully changed.", "", "", $screenname));
		}
	} elsif($cmd eq "SIGN_ON") {
		#Don't send "You're unpaused!" if it's the initial SIGN_ON
		irc_send(irc_privmsg($usnick, $connection->{nick}, "AOL has unpaused your connection.", "", "", $screenname)) if $sndata->{formatted};
	} elsif($cmd eq "PAUSE") {
		irc_send(irc_privmsg($usnick, $connection->{nick}, "AOL has paused your connection.", "", "", $screenname));
		set_pause($sndata->{socket}, 1);
	}
}

# Convert HTML into text suitable for IRC
sub html2txt($;$) {
	my ($msg, $nick, $parsetree, @lines, $formatter) = @_;
	my($linkct, $link, $elem, $node) = 0;

	$parsetree = HTML::TreeBuilder->new;
	$parsetree->{_ignore_unknown} = 0;
	$parsetree->parse($msg);
	$parsetree->eof;

	$formatter = new HTML::FormatAIMIRC (leftmargin => 0, rightmargin => 4096);
	$formatter->{_original_html} = $msg; #We use this to determine whether to add a closing tag for "unknown tags"
	$msg = $formatter->format($parsetree);
	$parsetree->delete;
	return $msg;
}

# Debugging
sub Toc::debug_print($$$) {
	my($text, $type, $level) = @_;
	my($line, @lines);

	return if $text =~ m!401 $usnick #aimirc-debug :No such nick/channel!i;
	return unless $debug;
	return if defined($debug{$type}) and $level > $debug{$type};

	if($aimircdebug and $debug < 2) {
		@lines = split(/[\r\n]+/, $text);

		foreach $line(@lines) {
			irc_send(":$usnick PRIVMSG #aimirc-debug :($type, $level) $line\r\n", 1);
		}
	} else {
		chomp $text;
		print STDERR "$text\n";
	}
}

# Send something to IRC
sub irc_send($;$) {
	my ($msg, $flags, $nodbg, $rv) = @_;

	return unless $msg;

##HACK HACK HACK HACK
#	$msg =~ s/connection reset by peer/Too many people using aimirc.  Wait for someone to sign off.  Sorry, AOL's fault, not mine./i;

	$flags ||= 0;
	$nodbg = 1 if $flags & 1;

	Toc::debug_print("To IRC  : $msg", "irc", 2) unless $nodbg;
	undef $rv;
	$! = EAGAIN;
	while(!defined($rv) && $! == EAGAIN) {
		$rv = $upstream->syswrite($msg, length $msg);
		if(defined $rv and $rv != length $msg) {
			substr($msg, 0, $rv) = "";
			undef $rv;
			$! = EAGAIN;
		} elsif(!defined($rv)) {
			die "Couldn't write to IRC: $!";
		}
	}
	return 1;
}

# Dereference a hashref
sub deref($) {
	my $href = shift;
	return %$href if ref $href eq "HASH";
	return ();
}

# Reload the configuration file
sub rehash() {
	irc_send(irc_privmsg($usnick, "#aimirc-debug", "Rehashing..."));
	if(-r "/etc/aimirc.conf") {
		do "/etc/aimirc.conf";
		$@ =~ tr/\r//d;
		irc_send(irc_privmsg($usnick, "#aimirc-debug", $@, "EVAL: "));
		if($@) {
			irc_send(irc_privmsg($usnick, "#aimirc-debug", "Couldn't reload /etc/aimirc.conf - there were errors."));
		} else {
			irc_send(irc_privmsg($usnick, "#aimirc-debug", "Reloaded /etc/aimirc.conf"))
		}
	} else {
		irc_send(irc_privmsg($usnick, "#aimirc-debug", "Not loading /etc/aimirc.conf - couldn't read"));
	}
	if(-r "$home/.aimirc") {
		do "$home/.aimirc" if -r "$home/.aimirc";
		irc_send(irc_privmsg($usnick, "#aimirc-debug", $@, "EVAL: "));
		if($@) {
			irc_send(irc_privmsg($usnick, "#aimirc-debug", "Couldn't reload $home/.aimirc - there were errors."));
		} else {
			irc_send(irc_privmsg($usnick, "#aimirc-debug", "Reloaded $home/.aimirc"))
		}
	} else {
		irc_send(irc_privmsg($usnick, "#aimirc-debug", "Not loading $home/.aimirc - couldn't read"));
	}
	irc_send(irc_privmsg($usnick, "#aimirc-debug", "Rehash complete!"));
}

# Re-eval aimirc
sub reload() {
	irc_send(irc_privmsg($usnick, "#aimirc-debug", "Reloading $0..."));
	$reload = 1;
	local $SIG{__DIE__} = sub { $@ = shift; };
	do $0;
	irc_send(irc_privmsg($usnick, "#aimirc-debug", $@, "EVAL: "));
	if($@) {
		irc_send(irc_privmsg($usnick, "#aimirc-debug", "Couldn't reload $0 - there were errors."));
	} else {
		irc_send(irc_privmsg($usnick, "#aimirc-debug", "Reload complete!"));
	}
}

# Display version information
sub dispver() {
	print "aimirc: IRC <-> AOL Instant Messenger gateway.\n";
	print "AOL Instant Messenger, AOL, and America Online are trademarks of America Online, Inc.\n";
	print "Version: $VERSION\n";
	print "Use $0 --help for command-line options.\n";
	print "Use $0 --license to see the license (GPL v2)\n";
	exit 0;
}

# Dispaly licensing info
sub license() { print $license; exit 0; }

# Display commandline help
sub help() {
	print <<EOF
aimirc - IRC <-> AOL Instant Messenger gateway
AOL Instant Messenger, AOL, and America Online are trademarks of America Online, Inc.
Version $VERSION

Usage: $0 [--version] [--license] [--help] [--config conffile] [--config conffile] ...

You can use either the short or long forms with one or two dashes in
whatever combination you want.  However, you can't combine options as in
$0 -VC.

	--version, -V:			Display version information and exit

	--license:			Display license information and exit

	--help, -h:			Print this message and exit

	--config, -C:			Specify configuration files to use.
					This option overrides the default
					configuration file locations.
					You may specify this option multiple
					times to use multiple configuration
					files.

This is also an option for every directive in the configuration file.
The options have the same names as the directives, but prefix them with
two dashes (--) instead of the Perl variable type identifies (\$\@\%).

See the included README file for more information.
EOF
;
	exit 0;
}

# Sign on to AIM
sub do_signon($$$$) {
	my($tparam, $textra, $tusnick, $tnick, $nparam, %temp, @ret, $flags, $nnick, %config, $connection, $sndata, $pouncecount) = @_;

	$nparam = normalize($tparam);
	$nnick = normalize($tnick);

	if($verbose_signon) {
		@ret = signon $nparam, $textra, socksub(), sub { irc_send(irc_privmsg($tusnick, $tnick, $_[0])) };
	} else {
		@ret = signon $nparam, $textra, socksub();
	}
	if($ret[0] == 0) {
		$aim_connections{$nnick}{nick} = $nnick;
		$connection = $aim_connections{$nnick};
		$connection->{screennames}{$nparam}{socket} = $ret[1];
		$sndata = $connection->{screennames}{$nparam};
		$sndata->{permtype} = $ret[2]->{permtype};
		$sndata->{report_idle} = $sendidle;
		$sndata->{idletime} = time;
		$sndata->{is_idle} = 0;
		$sndata->{signontime} = time;
		$sndata->{gotconf} = 0;
		$sndata->{ison} = 0;
		$sndata->{inchan} = 0;

		$connection->{aimnick} ||= $nparam;
		$irc_connections{$nparam} = $nnick;

		switchnick($nnick, $nparam) if $connection->{aimnick} eq $nparam;
		%temp = %{$ret[2]};

		irc_send(irc_privmsg($tusnick, $nnick, "Sent signon attempt for $nparam..."));

		irc_send(irc_newnick($prefix . $tparam));
		$nicks{$nparam}{$nparam} = -1;
	} else {
		irc_send(irc_privmsg($tusnick, $nnick, $err));
	}
}

# Signoff a particular screenname
sub do_signoff($$;$) {
	my ($nick, $connection, $already_off, $xnick, $nparam, %config, $chat, $screenname, $who) = @_;

	return unless $connection;

	$screenname = Toc::_hnick($connection);
	$nparam = safename $screenname;
	if($nparam and $savebuddies > 0) {
		%config = deref(get_config($screenname));
		$buddylists{$nparam} = conf2str(%config) if haskeys $config{Buddies};
	}
	savedat($screenname) if $screenname;
	delete $buddylists{$nparam} if $nparam;
	delete $pounces{$nparam} if $nparam;
	delete $profiles{$nparam} if $nparam;

	foreach $chat(keys %chatnames) {
		next unless $chatnames{$chat} eq $screenname or not $screenname;
		foreach $who(keys %{$chats{$chat}}) {
			delete $chats{$chat}{$who};
			delete $nicks{normalize($who)}{"chat-$chat"};
			irc_send(irc_part("$prefix$who", "#aimchat-$chat"));
		}
		delete $chattopics{$chat};
		delete $chatnames{$chat};
		delete $chatjoined{$chat};
		irc_send(irc_kick($usnick, "#aimchat-$chat", $nick, "The screenname you were using in this chatroom is no longer signed on to AOL Instant Messenger."));
		irc_send(irc_part($usnick, "#aimchat-$chat"));
	}

	delete $irc_connections{$screenname} if $screenname;
	foreach $xnick(keys %nicks) {
		next if normalize $xnick eq normalize $usnick or not $screenname;
		delete $nicks{$xnick}{$screenname}; 
		irc_send(irc_quit("$prefix$xnick", "I signed off of AIM (do_signoff)")) unless haskeys($nicks{$xnick});
	}

	if($screenname and $aim_connections{$nick}{screennames}{$screenname}{inchan}) {
		irc_send(irc_kick($usnick, "#aimirc-$screenname", $nick, "You have been signed off of AOL Instant Messenger."));
		irc_send(irc_part($usnick, "#aimirc-$screenname"));
	}

	if(UNIVERSAL::isa($connection, "IO::Socket::INET")) {
		signoff($connection);
	}
	if($aim_connections{$nick}) {
		irc_send(irc_privmsg($usnick, $nick, "You have been signed off of AOL Instant Messenger as $screenname", "", "", $screenname)) unless $already_off or not $screenname;
		delete $aim_connections{$nick}{screennames}{$screenname} if $screenname;
		if(haskeys $aim_connections{$nick}{screennames}) {
			$xnick = (keys %{$aim_connections{$nick}{screennames}})[0];
			irc_send(irc_privmsg($usnick, $nick, "Your new default screenname is $xnick."));
			switchnick($nick, $xnick);
		} else {
			delete $aim_connections{$nick};
		}
	}
}

# We use this so we can handle both SSL and non-SSL.
sub socksub() {
	if($ssl) {
		return "SSLv3->new(
			PeerAddr => \"$tocserver\",
			PeerPort => \"$tocport\",
			SSL_verify_mode => 0x00,
		);";
	} else {
		return "IO::Socket::INET->new(
			PeerAddr => \"$tocserver\",
			PeerPort => \"$tocport\",
		);";
	}
}

# Send mode as if it's coming from the server
sub irc_mode($$$) {
	my($who, $chan, $modes, $modestr) = @_;

	$modestr = "";
	$modestr = ":$who " unless $who eq $us;
	$modestr .= "MODE $chan $modes";
	$modestr .= " " . time if $servermode ne "ts" and $who eq $us;
	$modestr .= "\r\n";
	return $modestr;
}

# Join a channel
sub irc_join($$) {
	my($user, $channel, $ret) = @_;

	$ret = irc_newnick($user);
	$user = ircify($user);

	if($servermode eq "ts") {
		$user = "\@$user" if normalize($user) eq normalize($usnick);
		$ret .= "SJOIN " . time . " $channel + :$user\r\n";
	} else {
		$ret .= ":$user JOIN $channel\r\n";
	}

	return $ret;
}

# Kick someone from a channel
sub irc_kick($$$;$) {
	my($from, $channel, $nick, $reason) = @_;

	$nick =~ s/\@+//;
	return ":$from KICK $channel $nick" . ($reason ? " :$reason" : "") . "\r\n";
}

# Leave a channel
sub irc_part($$;$) {
	my($from, $channel, $reason) = @_;

	return ":$from PART $channel" . ($reason ? " :$reason" : "") . "\r\n";
}

# Send a numeric IRC error
sub irc_error($$$) {
	my($to, $number, $text) = @_;

	return "$number $to :$text\r\n";
}

# Change the topic for a channel
sub irc_topic($$$) {
	my($from, $channel, $topic) = @_;

	return ":$from TOPIC $channel :$topic\r\n";
}

# Reply to a PING
sub irc_pong() {
	return "PONG $us\r\n";
}

# Leave IRC
sub irc_quit($;$) {
	my($from, $reason) = @_;

	return ":$from QUIT" . ($reason ? " :$reason" : "") . "\r\n";
}

# Do all these bloody IRC commands really need documentation?  RTFRFC.
sub irc_invite($$$) {
	my($from, $channel, $who) = @_;

	return ":$from INVITE $who $channel\r\n";
}

# Receive a message from IRC
sub irc_recv(;$) {
	my($noblock, $rv, $buff, $incbuff, $idx, $ret) = ($_[0]);

	undef $rv;
	$! = EAGAIN;

	while(not $getbuff[0] and $! == EAGAIN and !defined($rv)) {
		$buff = ' ' x 512;
		$rv = $upstream->sysread($buff, 512);
		die "Couldn't read from IRC: $!" if !defined($rv) && $! != EAGAIN;
		if($! != EAGAIN) {
			#print STDERR "Reading from IRC...\n";
			if($incbuff) {
				$buff = "$incbuff$buff";
				undef $incbuff;
			}
			unless($buff =~ /\n$/) {
				$idx = rindex($buff, "\n") + 1;
				$incbuff = substr($buff, $idx, length($buff) - $idx + 1, "");
			}
			push @getbuff, split(/[\r\n]+/, $buff);
			#print STDERR "Getbuff is " . join("\n", @getbuff);
			#print STDERR "\n";
		}
		last if $noblock;
	}
	$ret = shift @getbuff;
	Toc::debug_print("From IRC: $ret", "irc", 2) if $ret;
	#print STDERR "Returning $ret\n";

	return $ret;
}

# Warn if a screenname is being mangled to work with IRC
sub manglewarn($$) {
	my($who, $what) = @_;

	irc_send(irc_privmsg($usnick, $who,
		"\02WARNING\02: Screenname $what has been mangled to IRC nickname " . $shortnicks{noprefix $what}))

		if noprefix($shortnicks{noprefix($what)}) ne normalize($what);
}

# Switch the default screenname for an IRCnick
sub switchnick($$) {
	my($nnick, $nparam) = @_;
	my $oldnick = $aim_connections{$nnick}{aimnick};

	return 1 unless $aim_connections{$nnick}{screennames}{$nparam};

	$aim_connections{$nnick}{aimnick} = $nparam;
	$aim_connections{$nnick}{socket} = $aim_connections{$nnick}{screennames}{$nparam}{socket};

	return 0;
}

# Clean up nicknames, send keepalives/idle, etc.
sub timestuff($) {
	my($currtime, $anick, $kill, $bnick, $chantimer, $cname, $connection, $screenname, $multinick, $sndata, $nick) = shift;

	Toc::debug_print("Reaping nicks...", "nicks", 3);
	ANICK: foreach $anick(keys %nicks) {
		next if normalize($anick) eq normalize($usnick);
		next if exists $irc_connections{noprefix($anick)};
		next if $anick =~ /^chat-\d+/;
		$kill = 1;
		Toc::debug_print("\tSO WE MEET AGAIN, $anick.", "nicks", 3);
		foreach $bnick(keys %{$nicks{$anick}}) {
			next if $bnick eq $usnick;
			Toc::debug_print("\t\t$bnick was using $anick...", "nicks", 3);
			next ANICK if $kill == 0;
			if($nicks{$anick}{$bnick} == -1) {
				$kill = 0;
				Toc::debug_print("\t\t\tpermenantly.", "nicks", 3);
			} elsif (($currtime - $nicks{$anick}{$bnick}) < 3600) {
				$kill = 0;
				Toc::debug_print("\t\t\tsince " . ($currtime - $nicks{$anick}{$bnick}) . " seconds ago.", "nicks", 3);
			}
		}
		if($kill == 1) {
			delete $nicks{$anick};
			irc_send(irc_quit("$prefix$anick", "Waah, nobody wants me (reaped)"));
			Toc::debug_print("\t$anick, HAVE A NICE AFTERLIFE. ($anick reaped)", "nicks", 1);
		} else {
			Toc::debug_print("\t$anick, YOU LIVE FOR NOW.", "nicks", 3);
		}
	}

	#Part from the restricted that we joined in response to someone joining without my authoritay
	foreach $chantimer(keys %chantimer) {
		if(($currtime - $chantimer{$chantimer}) >= 60) {
			irc_send(irc_part($usnick, $chantimer));
			delete $chantimer{$chantimer};
		}
	}


	#Only send idle/keepalive packets every other time through the loop
	if($keepalive) {
		foreach $cname(keys %aim_connections) {
			$connection = $aim_connections{$cname};
			foreach $screenname(keys %{$connection->{screennames}}) {
				next unless $screenname;
				$sndata = $connection->{screennames}{$screenname};
				$multinick = "";
				$multinick = " for screenname $screenname" unless $screenname eq $connection->{aimnick} or $sndata->{inchan};
				next unless $sndata->{ison};
				if($sndata->{socket}) {
					if($sndata->{socket} and sflap_keepalive($sndata->{socket}) == -1 and $! != EAGAIN) {
						irc_send(irc_privmsg($usnick, $aim_connections{$connection}{nick}, "There was an 2371 error with your AOL Instant Messenger connection${multinick}: $err", "", "", $screenname));
						do_signoff(normalize $connection->{nick}, $sndata->{socket});
					} else {
						if($sndata->{report_idle} and not $sndata->{is_idle} and ($currtime - $sndata->{idletime}) >= 360) {
							if($sndata->{socket} and set_idle($sndata->{socket}, $currtime - $sndata->{idletime}) == -1 and $! != EAGAIN) {
								irc_send(irc_privmsg($usnick, $connection->{nick}, "There was an 2376 error with your AOL Instant Messenger connection${multinick}: $err", "", "", $screenname));
								do_signoff($connection->{nick}, $sndata->{socket});
							} else {
								$sndata->{is_idle} = 1;
							}
						}
					}
				} elsif($! != EAGAIN) {
					irc_send(irc_privmsg($usnick, $connection->{nick}, "There was an 2384 error with your AOL Instant Messenger connection${multinick}: $err", "", "", $screenname));
					do_signoff($connection->{nick}, undef);
				}
			}
		}
		$keepalive = 0;
	} else {
		$keepalive = 1;
	}
}

# Signoff all screennames for a particular IRCnick
sub do_signoff_all($;$) {
	my ($nnick, $already_off, $screenname, $nick) = @_;

	foreach $screenname(keys %{$aim_connections{$nnick}{screennames}}) {
		do_signoff($nnick, $aim_connections{$nnick}{screennames}{$screenname}{socket}, 1);
	}
	irc_send(irc_privmsg($usnick, $nick, "All connections signed off of AOL Instant Messenger.")) unless $already_off;
	delete $aim_connections{$nnick};
}

# Notify signed-on users that we're going down
sub going_down() {
	my ($user, @users) = (undef, keys %aim_connections);

	foreach $user(keys %irc_connections) {
		savedat($user);
	}
	foreach $user(@users) {
		next if $aim_connections{$user}{notified}++;
		irc_send(irc_privmsg($usnick, $user, "aimirc is going down.  You have been signed off of AOL Instant Messenger."));
	}
}

# Encode a message for CTCPing - you must still irc_send(":$sender PRIVMSG $target :$this")
sub irc_ctcp_quote($) {
	my($delim, $null) = (chr(001), chr(000));
	my $message = shift;

	$message =~ s/\\/\\\\/g;
	$message =~ s/$delim/\\a/g;
	$message =~ s/\n/\\\n/g;
	$message =~ s/\r/\\\r/g;
	$message =~ s/$null/\\$null/g;
	$message =~ s/:/\\/g;
	return $message;
}

# Decode an incoming CTCP
sub irc_ctcp_unquote($) {
	my($delim, $null) = (chr(001), chr(000));
	my $message = shift;

	$message =~ s/\\\\/\\/g;
	$message =~ s/\\a/$delim/g;
	$message =~ s/\\\n/\n/g;
	$message =~ s/\\\r/\r/g;
	$message =~ s/\\$null/$null/g;

	return $message;
}

# Process an incoming IRC command for CTCPs
sub process_ctcp($$$$) {
	my($from, $to, $message, $screenname) = @_;
	my ($delim, @ctcp, $ctcp, $cmd, $args) = (chr(001));
	my($filename, $ipaddr, $port, $filesize, $socket, $buff, $flags);

	return $message unless $message =~ /$delim/; 

	@ctcp = map { $_ = irc_ctcp_unquote $_; Toc::debug_print("CTCP: $_", "ctcp", 2) if $_; $_; } split(/$delim+/, $message);
	shift @ctcp;
	$message =~ s/$delim.*//g;
	Toc::debug_print("After CTCP: $message", "ctcp", 2);

	CTCP: foreach $ctcp(@ctcp) {
		$ctcp =~ /^(\S+) ?(.*)$/;
		$cmd = $1; $args = $2;

		Toc::debug_print("Processing CTCP $ctcp: command $cmd", "irc", 2);
		if($cmd eq "PING") {
			if($irc_connections{noprefix($to)} eq $from) {
				message($aim_connections{$from}{socket}, noprefix $to, "<!-- NOTICE --><!-- CTCP -->$ctcp");
			} else {
				irc_send(irc_ctcp($to, $from, $ctcp, 1)) if $cmd eq "PING";
			}
		}
		$message .= "\02ACTION\02 $args" if $cmd eq "ACTION"; #If you "/me runs" an AIMer, it'll turn into "<B>ACTION</B> runs".  Anyone got any better ideas?
		if($cmd eq "DCC") {
			$screenname = $dccget{$from} || "";
			($cmd, $args) = split(/ /, $args, 2);
			if($cmd eq "REJECT") {
				my($dcc, $i);
				for($i = 0; $i <= $#dccqueue; $i++) {
					$dcc = $dccqueue[$i];
					Toc::debug_print("DCC $dcc->{direction} from $dcc->{from} to $dcc->{to}", "DCC", 2);
					if($dcc->{direction} eq "SEND" and normalize $dcc->{to} eq $from) {
						Toc::debug_print("$from rejected our DCC.", "DCC", 1);
						$dccqueue[$i]->{socket}->close if $dcc->{socket};
						$dccqueue[$i]->{ssocket}->close if $dcc->{ssocket};
						splice(@dccqueue, $i, 1);
						$i--;
					} elsif(normalize $dcc->{from} eq $from) {
						Toc::debug_print("$from rejected our DCC.", "DCC", 1);
							$dccqueue[$i]->{socket}->close if $dcc->{socket};
						splice(@dccqueue, $i, 1);
						$i--;
					}
				}
			} elsif($cmd eq "SEND") {
				$args =~ /(.+)\s+(\d+)\s+(\d+)\s+(\d+)/; #Handles spaces in filename
				($filename, $ipaddr, $port, $filesize) = ($1, $2, $3, $4);
				if(not $dccget{$from}) {
					irc_send(irc_privmsg($to, $from, "I'm not accepting DCCs from you at this time.", "", "", $screenname));
					irc_send(irc_ctcp($to, $from, "DCC REJECT SEND $filename", 1));
					next CTCP;
				}
				if($dccget{$from} and $filesize > 20480) {
					irc_send(irc_privmsg($to, $from, "Sorry, I won't accept buddylists larger than 20k.", "", "", $screenname));
					delete $dccget{$from};
					irc_send(irc_ctcp($to, $from, "DCC REJECT SEND $filename"));
					next CTCP;
				} else {
					$SIG{ALRM} = sub { die "connection timed out\n"; };
					eval {
						alarm 5;
						$socket = IO::Socket::INET->new(
							PeerAddr => $ipaddr,
							PeerPort => $port
						);
						alarm 0;
					} ;
					unless(!$@ and $socket) {
						irc_send(irc_privmsg($to, $from, "Couldn't receive your DCC: $@"));
						next CTCP;
					}
					$flags = 0;
					fcntl($socket, F_GETFL, $flags) or die "Couldn't get flags for DCC socket: $!";
					$flags |= O_NONBLOCK;
					fcntl($socket, F_SETFL, $flags) or die "Couldn't set flags for DCC socket: $!";
					push @dccqueue, {screenname => $screenname, socket => $socket, size => $filesize, what => $dccget{$from}, from => $from, to => $to, got => 0, direction => "GET", buff => ""};
					delete $dccget{$from};
					irc_send(irc_privmsg($to, $from, "Okay, I'll get your DCC of $filename.", "", "", $screenname));
				}
			}
		}
	}
	return $message;
}

# Like irc_privmsg
sub irc_ctcp($$$;$) {
	my($from, $to, $message, $reply) = @_;
	my $delim = chr(001);

	return ":$from " . ($reply ? "NOTICE" : "PRIVMSG") . " $to :$delim" . irc_ctcp_quote($message) . "$delim\r\n";
}

#Someone's sending us a file: DCC SEND filename IPaddr port filesize

sub loadbuddies($$) {
	my($socket, $buff) = @_;
	my($permtype, $line, @sections, $var, $val, $conf, $buddy);

	if($buff !~ /^Buddy {$/m) { #TOC-style
		update_config($socket, $buff);
		set_config($socket, get_config(Toc::_hnick($socket)));
		return 1;
	} else {
		foreach $line(split(/[\r\n]+/, $buff)) {
			if($line =~ /^\s*(\S+) {\s*/) {
				push @sections, $1;
			} elsif($line =~ /^\s*}\s*$/) {
				pop @sections;
			} else {
				$line =~ /^\s*(\S+)\s*(.*?)\s*$/;
				$var = $1; $val = $2;
				if(lc($sections[0]) eq "buddy" and lc($sections[1]) eq "list") {
					if($val) {
						$conf .= "g $var\n";
						while($val =~ s/\"(.+?)\"//g) {
							($buddy = $1) =~ tr/ //d;
							$val .= " $buddy";
						}
						Toc::debug_print("Got buddylist group $var = $val", "config", 3);
						foreach $buddy(split(/\s+/, $val)) {
							Toc::debug_print("\tAdding $buddy to group", "config", 3);
							$conf .= "b $buddy\n";
						}
					}
				} elsif(lc($sections[0] eq "Privacy")) {
					if(lc($var) eq "allowlist" and $val) {
						while($val =~ s/\"(.+?)\"//g) {
							($buddy = $1) =~ tr/ //d;
							$val .= " $buddy";
						}
						Toc::debug_print("Got permit list = $val", "config", 3);
						foreach $buddy(split(/\s+/, $val)) {
							Toc::debug_print("\tAdding $buddy to permit list", "config", 3);
							$conf .= "p $buddy\n";
						}
					} elsif(lc($var) eq "denylist" and $val) {
						while($val =~ s/\"(.+?)\"//g) {
							($buddy = $1) =~ tr/ //d;
							$val .= " $buddy";
						}
						Toc::debug_print("Got deny list = $val", "config", 3);
						foreach $buddy(split(/\s+/, $val)) {
							Toc::debug_print("\tAdding $buddy to deny list", "config", 3);
							$conf .= "d $buddy\n";
						}
					} elsif(lc($var) eq "pref") {
						Toc::debug_print("Permit mode is $val", "config", 3);
						if(lc($val) eq "allowall") {
							$conf .= "m 1\n";
						} elsif(lc($val) eq "denyall") {
							$conf .= "m 2\n";
						} elsif(lc($val) eq "allowsome") {
							$conf .= "m 3\n";
						} else {
							$conf .= "m 4\n";
						}
					}
				}
			}
		}
		if($conf) {
			update_config($socket, $conf);
			set_config($socket, get_config(Toc::_hnick($socket)));
			return 1;
		} else {
			return 0;
		}
	}

}

# DCC send a file to someone - you must irc_send this!  Returns the empty string on error.
sub irc_dcc($$$$$$) {
	my($from, $to, $what, $why, $filename, $screenname, $msg, $flags, $socket) = @_;

	if(!$dccip) {
		irc_send(irc_privmsg($from, $to, "The administrator of this server has not configured an IP to use for DCC, so DCC SEND has been disabled.", "", "", $screenname));
		return "";
	}

	eval { $socket = IO::Socket::INET->new(
		LocalPort => 0,
		Listen => 1,
		Proto => 'tcp',
		LocalAddr => $dccip
	); };

	unless(!$@ and $socket) {
		irc_send(irc_privmsg($from, $to, "Couldn't create DCC socket: $@", "", "", $screenname));
		return "";
	} else {
		$flags = 0;
		if(!fcntl($socket, F_GETFL, $flags)) {
			irc_send(irc_privmsg($from, $to, "Couldn't get flags for DCC socket: $!", "", "", $screenname));
			return "";
		}
		$flags |= O_NONBLOCK;
		if(!fcntl($socket, F_SETFL, $flags)) {
			irc_send(irc_privmsg($from, $to, "Couldn't set flags for DCC socket: $!", "", "", $screenname));
			return "";
		}

		#We set {put} to -1 to indicate that the client hasn't connected yet.
		push @dccqueue, {screenname => $screenname, starttime => time, ssocket => $socket, size => length($what), what => $why, from => $from, to => $to, put => -1, direction => "SEND", buff => $what};
		Toc::debug_print("DCC SEND buff: $what", "DCC", 3);
		return irc_ctcp($from, $to, "DCC SEND $filename " . unpack("N", inet_aton($dccip)) . " " . $socket->sockport . " " . length($what));
	}
}

# Make a screenname safe to be used in a filename.
# This is probably not needed, but just because you're paranoid it doesn't
# meant they're not out to get you.
sub safename($) {
	my($dangerous_name) = shift;
	$dangerous_name =~ tr!<>|/\0!!d;
	return $dangerous_name;
}

sub savedat($) {
	my($screenname, $pounce) = shift;

	$screenname = safename $screenname;

	if(-d $directory and -w $directory) {
		if($savebuddies) {
			mkdir("$directory/buddylists", 0700) if not -d "$directory/buddylists";
			unlink "$directory/buddylists/$screenname";
			if($buddylists{$screenname}) {
				open(BUDDYLIST, ">$directory/buddylists/$screenname");
				print BUDDYLIST $buddylists{$screenname};
				close BUDDYLIST;
			}
		}
		if($saveprofiles) {
			mkdir("$directory/profiles", 0700) if not -d "$directory/profiles";
			unlink "$directory/profiles/$screenname";
			if($profiles{$screenname}) {
				open(PROFILE, ">$directory/profiles/$screenname");
				print PROFILE $profiles{$screenname};
				close PROFILE;
			}
		}
		if($savepounces) {
			mkdir("$directory/pounces", 0700) if not -d "$directory/pounces";
			unlink "$directory/pounces/$screenname";
			if(ref $pounces{$screenname} eq "ARRAY" and scalar @{$pounces{$screenname}}) {
				open(POUNCES, ">$directory/pounces/$screenname");
				foreach $pounce(@{$pounces{$screenname}}) {
					print POUNCES "$pounce->{who} $pounce->{what}\n";
				}
				close POUNCES;
			}
		}
	} else {
		print STDERR "Warning!  $directory is unwritable - not saving data.\n";
		Toc::debug_print("Warning!  $directory is unwritable - not saving data.", "errors", 1);
	}
}

#The base64 functions are for the P10 IRC protocol
sub num2base64($) {
	my $number = shift;
	my (@table, $char, $ret, $num, $currdig);

	$ret = "";
	foreach $char("A".."Z") { push @table, $char; }
	foreach $char("a".."z") { push @table, $char; }
	foreach $char("0".."9") { push @table, $char; }
	push @table, "[", "]";
	for($num = 2; $num >= 0; $num--) {
		next unless $number >= 64**$num;
		$currdig = ($number - 64**$num) % 64;
		$ret .= $table[$currdig];
		$number -= $currdig;
	}
	return $ret;
}

sub base642num($) {
	my $number = shift;
	my (%table, $char, $num, $currdig, $ret);

	$num = 0;
	foreach $char("A".."Z") { $table{$char} = $num++; }
	foreach $char("a".."z") { $table{$char} = $num++; }
	foreach $char("0".."9") { $table{$char} = $num++; }
	$table{"["} = $num++;
	$table{"]"} = $num++;

	$num = $ret = 0;
	while($currdig = substr($number, -1, 1, "")) {
		$ret += $table{$currdig}*64**$num++;
	}
	return $ret;
}

sub got_im($$$$) {
		my($from, $to, $message, $autoflag, $nick, $multinick, $notice, $screenname, $connection, $ar, $sndata, $config, $socket, $inick, $nnick) = @_;

		$inick = $from; $inick =~ tr/ //d;
		$nnick = lc($inick);

		$screenname = $to;
		$config = deref get_config($to);
		$connection = $aim_connections{$irc_connections{$to}};
		$sndata = $connection->{screennames}{$to};
		$socket = $sndata->{socket};

		$multinick = "";
		$multinick = "{$to} " if $to ne $connection->{aimnick} and not $sndata->{inchan};

		($message =~ /<!-- NOTICE -->/) ? ($notice = 1) : ($notice = 0);
		$message = chr(01) . $message . chr(01) if $message =~ /<!-- CTCP -->/;
		unless($nicks{noprefix $nnick}) {
			irc_send(irc_newnick($prefix . $inick));
		}
		manglewarn($connection->{nick}, $inick) unless $nicks{$nnick}{$screenname};
		irc_send(irc_join("$prefix$inick", "#aimirc-$screenname")) if $sndata->{inchan} and not $nicks{ircify($inick)}{$screenname};

		($autoflag eq "T") ? ($ar = "[automatic response] ") : ($ar = "");
		$message = join("\n", html2txt($message, $nick));

		irc_send(irc_privmsg("$prefix$inick", $connection->{nick}, $message, "$multinick$ar", $notice));

		if(($ar eq "") and $connection->{away} and (time - $sndata->{away_buddies}{$nnick} > $time)) {
			my $tmp;
			my %config = deref(get_config($screenname));
			my $class = $config{Buddies}{$nnick}{class} if exists $config{Buddies}{$nnick};
			if(substr($class, 0, 1) eq "A") {
				$tmp = "[automated reply] " . $connection->{away};
			} else {
				$tmp = $connection->{away};
			}
			message($socket, $nnick, $tmp, 1);
			$sndata->{away_buddies}{$nnick} = time;
		}
		$screenname = normalize($screenname);
		irc_send(irc_privmsg($usnick, "matthewg", "Setting \$nicks{".noprefix($nnick)."}{$screenname} to time"));
		$nicks{noprefix $nnick}{$screenname} = time if $nicks{noprefix $nnick}{$screenname} != -1;
}


# Sanitize a screenname for IRC
sub ircify($) {
	my $screenname = shift;

	#Yes, I am aware that the RFC mandates a max of 9 characters.
	$screenname = substr($screenname, 0, $ircservers{$servermode}{nicklen});

	#Enforce RFC1459 compliance.
	#Note that this does the wrong thing in the pathological case of nicks which don't match /[a-zA-Z]/
	#But there's really no right thing to do in that case I suppose.
	#That's why it deserves the adjective "pathological".
	#
	$screenname =~ s/^[^a-zA-Z]+//; #Nicks must start with [a-ZA-Z]
	$screenname =~ tr/-a-zA-Z0-9[]\\`^{}//dc; #Anything except those characters is invalid

	return $screenname;
}

sub bounce_join($$) {
	my($nick, $chan) = @_;
	irc_send(irc_join($usnick, $chan));
	irc_send(irc_mode($us, $chan, "+isntob $usnick *!*@*"));
	irc_send(irc_kick($usnick, $chan, $nick, "This channel is reserved for aimirc usage."));
	$chantimer{$chan} = time;
}

#!/usr/bin/perl

$license = <<EOF
Copyright (c) 1999-2000 Matthew Sachs.  All Rights Reserved.

   This program is free software; you can redistribute it and/or
   modify it under the terms of version 2 of the GNU General Public License
   as published by the Free Software Foundation.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

   The GNU General Public License is included with the aimirc distribution
   under the filename COPYING.

 AOL Instant Messenger, AOL, and America Online are trademarks of America Online, Inc.
EOF
;

sub BEGIN {
	require FindBin;
	use lib $FindBin::Bin;

	undef $@;
	eval {
		require HTML::FormatText;
		require HTML::Parse;
	};

	if($@) {
		print STDERR "Couldn't require HTML::FormatText and/or HTML::Parse.  Here's why:\n";
		print STDERR "$@\n";
		print STDERR "\n\n";
		print STDERR "And here's what that probably means...\n\n";
		print STDERR "You do not have the HTML::FormatText and HTML::Parse modules installed.\n";
		print STDERR "There are at least three possible ways to install these modules:\n";
		print STDERR "1) [preferred] Get them as a package from your OS vendor or Linux distributor.\n";
		print STDERR "        In Debian, you can install the libhtml-tree-perl package.\n";
		print STDERR "        Note that Debian no longer provides a package for HTML::FormatText,\n";
		print STDERR "        you will need to get it manually.   I'm not sure about other\n";
		print STDERR "        operating systems or distributions.\n";
		print STDERR "2) Use the CPAN module to install it.  Run perl -MCPAN -e shell and \n";
		print STDERR "        type install HTML::Tree when you get to the CPAN prompt, and\n";
		print STDERR "        then install HTML::FormatText .\n";
		print STDERR "3) Download the source from CPAN and install it.  The source is located\n";
		print STDERR "        at http://www.perl.com/CPAN/modules/by-module/HTML/ in a file\n";
		print STDERR "        called HTML-Tree-VERSION.tar.gz where VERSION is the latest version\n";
		print STDERR "        of HTML-Tree.  You will also need the HTML-Format-VERSION.tar.gz\n";
		print STDERR "        package.\n";
		die "\n";
	}

	package HTML::FormatAIMIRC;
	
		@ISA = qw(HTML::FormatText);
		
		sub hr_start {
			my $self = shift;
			$self->vspace(1);
			$self->out("=" x 30);
			$self->vspace(1);
		}

		#We can't get at the HREF inside of sub out, so set it here.
		sub a_start {
			my ($self, $elem) = @_;
		
			$self->{anchor}++;
			push @{$self->{output}}, " " x $self->{hspace} . "{";
			$self->{hspace} = 0;
			1;
		}
		
		sub a_end {
			my($self, $elem) = @_;

			$self->{anchor}--;
			push @{$self->{output}}, "} {" . $elem->attr('href') . "}";
		}

		#Mostly ripped straight from HTML::FormatText, with a few critical additions.
		sub out {
			my($self, $text) = @_;
			my($bold, $italic, $underline, $color) = (chr(2), chr(oct(26)), chr(oct(37)), chr(3));
			
			if ($text =~ /^\s*$/) { 
				$self->{hspace} = 1;
				return;
			}
			
			#open(TMP, ">>/tmp/aimirc.html.txt");
			#print TMP "out $text:\n" . Data::Dumper::Dumper($self);
			#close TMP;

			#Translate HTML formatting to IRC formatting
			$text = "$bold$text$bold" if $self->{bold};
			$text = "$italic$text$italic" if $self->{italic};
			$text = "$underline$text$underline" if $self->{underline};
			#$text = "{$text" if $self->{anchstart} and $self->{anchor};
			#$text = "$text} {$self->{href}}" if $self->{anchstart} and not $self->{anchor}; #So we can see link addresses...
			
			if (defined $self->{vspace}) {
				if ($self->{out}) {
					$self->nl while $self->{vspace}-- >= 0;
				}
				$self->goto_lm;
				$self->{vspace} = undef;
				$self->{hspace} = 0;
			}
			
			if ($self->{hspace}) {
				if ($self->{curpos} + length($text) > $self->{rm}) {
					# word will not fit on line; do a line break
					$self->nl;
					$self->goto_lm;
				} else {
					# word fits on line; use a space
					$self->collect(' ');
					++$self->{curpos};
				}
				$self->{hspace} = 0;
			}
			
			$self->collect($text);
			my $pos = $self->{curpos} += length $text;
			$self->{maxpos} = $pos if $self->{maxpos} < $pos;
		
			$self->{'out'}++;
		}
	
		1;

	package main;
}

use FindBin;
use lib $FindBin::Bin;

use IO::Handle;
use IO::Socket;
use IO::Select;
use POSIX;
use Carp;
use Getopt::Long;
use LWP::Simple;
$Carp::Verbose = 1;

eval { require Data::Dumper; };

use Toc qw(:all);

$SIG{__DIE__}  = sub { croak $_[0] };

$home = (getpwuid($>))[7];
$version = $VERSION = "0.90";

@args = @ARGV;


#Defaults
$prefix = "AIM-";
$usnick = "AIMServ";
$us = "aimserv.your.irc.net"; #IRC server name to claim to be
$them = "127.0.0.1"; #Hostname of IRC server to connect to
$themport = 6667;
$ourpass = "foo";
$theirpass = "bar";
$servermode = "dal2";  #Should be either dal2 or dragonfire.
			#You can try something else, but I don't think the
			#default method works.
$time = 60*5; #Five minutes.
$ssl = 1;
@default_conffiles = qw(/etc/aimirc.conf $home/.aimirc);
$fork = 1;
$connectmode = 0;
$verbose = 0;
*debuglevel = *debug;	#We can now reference debuglevels as %debuglevel or %debug

Getopt::Long::Configure("no_ignore_case");
Getopt::Long::Configure("pass_through");

$errors = &GetOptions(
	"version|V" => \&dispver,
	"license" => \&license,
	"config|C=s\@" => \@conffiles,
	"help|h" => \&help,
);

@conffiles = @default_conffiles unless $conffiles[0];

if(!$errors) {
	print STDERR "Try $0 --help if you need help.\n";
	exit 1;
}

$foundconfig = 0;
foreach $conffile(@conffiles) {
	$conffile =~ s/~/$home/;
	if(-r $conffile) {
		print STDERR "Reading config file $conffile\n" if $verbose;
		undef $@;
		do $conffile;
		die $@ if $@;
		$foundconfig = 1;
	} else {
		print STDERR "Couldn't read config file $conffile\n" if $verbose;
	}
}

unless($foundconfig) {
	print STDERR "We couldn't find a config file.\n";
	print STDERR "You must edit aimirc.conf and copy it to either /etc/aimirc.conf or\n";
	print STDERR "   $home/.aimirc.  If you have already done this, make sure the aimirc\n";
	print STDERR "   user has permission to read it.\n";
	print STDERR "Or, perhaps you specified a config file with the --config (-C) option.\n";
	print STDERR "If you want to specify everything on the command-line and not use a config\n";
	print STDERR "   file (why?) then just give it a blank config file to make it happy.\n";
	exit 1;
}

Getopt::Long::Configure("no_pass_through");

$errors = &GetOptions(
	"us=s" => \$us,
	"them=s" => \$them,
	"themport=i" => \$themport,
	"ourpass=s" => \$ourpass,
	"theirpass=s" => \$theirpass,
	"servermode=s" => \$servermode,
	"connectmode=i" => \$connectmode,
	"prefix=s" => \$prefix,
	"usnick=s" => \$usnick,
	"time=i" => \$time,
	"ssl:i" => \$ssl,
	"fork=i" => \$fork,
	"verbose|v" => \$verbose,
	"debug:i" => \$debug,
	"debuglevel=s\%" => \%debuglevel,
);

if(!$errors) {
	print STDERR "Try $0 --help if you need help.\n";
	exit 1;
}

%temp = %ircservers; #Preserve custom ircservers

%ircservers = (
	dal2 => {
		nick => "NICK _NICK_ 1 _TIME_ _USER_ $us $us 0 :AOL Instant Messenger client via aimirc\r\n",
		server => "SERVER $us 1 :AOL Instant Messenger services\r\n",
		uspass => 1,
		theirpass => 1,
		nicklen => 30,
		pass => "PASS $ourpass :1\r\n",
		EBURST => 1,
	},
	dragonfire => {
		nick => "NICK _NICK_ 1 _TIME_ _USER_ $us $us :AOL Instant Messenger client via aimirc\r\n",
		server => "SERVER $us 1 :AOL Instant Messenger services\r\n",
		uspass => 1,
		theirpass => 1,
		nicklen => 10,
		pass => "PASS $ourpass :1\r\n"
	},
	ircu => {
		nick => ":$us NICK _NICK_ _UID_ _TIME_ _USER_ $us $us :AOL Instant Messenger services\r\n",
		server => "SERVER $us 1 _TIME_ _TIME_ P09 AIM Services\r\n",
		uspass => 1,
		theirpass => 1,
		nicklen => 9,
		pass => "PASS :$ourpass\r\n"
	},
	rfc => {
		nick => ":$us NICK _NICK_ 1\r\n:_NICK_ USER _USER_ $us $us :AOL Instant Messenger client via aimirc\r\n",
		server => "SERVER $us 1 :AOL Instant Messenger serices\r\n",
		uspass => 1,
		theirpass => 1,
		nicklen => 9,
		pass => "PASS :$ourpass\r\n"
	},
	ts => {
		nick => "NICK _NICK_ 1 _TIME_ +i _USER_ $us $us :AOL Instant Messenger client via aimirc\r\n",
		server => "SERVER $us 1 :AOL Instant Messenger serices\r\nSVINFO 1 1 0 :_TIME_\r\n",
		uspass => 1,
		theirpass => 1,
		nicklen => 9,
		pass => "PASS $ourpass TS\r\n",
	},
);

foreach $server(keys %temp) { #Preserve custom ircservers
	$ircservers{$server} = $temp{$server};
}

$connectmode_fork = 0;

if($connectmode == 0 or $connectmode == 2) {
	print STDERR "Testing fork mode support (IPC::Shareable)...\n" if $verbose;
	undef $@;
	eval { require IPC::Shareable; };
	if($@) {
		print STDERR "Can't use fork mode: $@\n" if $verbose;
	} else {
		print STDERR "Using fork mode\n";
		$connectmode_fork = 1;
	}
} else {
	print STDERR "Not forking.\n" if $verbose;
}

$uid = "101";


unless($reload) {
	if($fork) {
		#We don't need no stinking ampersands!
		$pid = fork;
		exit if $pid;
		die "Couldn't fork: $!" unless defined($pid);

		POSIX::setsid() or die "Can't start a new session: $!";
	}
	sub kill_handler {
		$upstream->close;
		foreach $connections(keys %$aim_connections) {
			$connections->{socket}->close;
		}
		exit 1;
	}
}

$SIG{INT} = $SIG{TERM} = \&kill_handler;
$SIG{CHLD} = 'IGNORE';

#Restart on SIGHUP
sub phoenix {
	$upstream->close;
	foreach $key(keys %aim_connections) {
		$aim_connections{$key}{socket}->close if $aim_connections{$key}{socket};
	}
	exec($0, @args);
}
$SIG{HUP} = \&rehash;


#Hello Mort!
sub REAPER {
	1 until (-1 == waitpid(-1, WNOHANG));
	$SIG{CHLD} = \&REAPER;
}
$SIG{CHLD} = \&REAPER;

#Connect

#enc: `sflap encode buflen (1 iff TYPE_SIGNON else 0) seqno`
#dec: `sflap decode`

$| = 1;

unless($reload) {
	$upstream = IO::Socket::INET->new(PeerAddr => "$them:$themport", Timeout => 60) or die "Couldn't connect to IRC server $them:$themport ($!)\n";
	do { irc_send($ircservers{$servermode}{pass}) if $ourpass and $ircservers{$servermode}{uspass}; } or die "Couldn't send PASS: $!\n";
	irc_send(irc_subparms($ircservers{$servermode}{server})) or die "Couldn't send PASS: $!\n";

	$in = "...";

	if($theirpass and $ircservers{$servermode}{theirpass}) {
		while($in and ($in !~ /PASS :?(.+)/)) {
			$in = $upstream->getline or die "Couldn't read from IRC server: $!\n";
			chomp $in;
			Toc::debug_print($in, "irc_connect", 1) if $in;
			if($in =~ /^ERROR :(.+)/) {
				print STDERR "IRC connection error: $1\n";
				exit 1;
			}
		}

		Toc::debug_print($in, "irc_connect", 1) if $in;
		$in =~ s/ :1// if $in;
		$in =~ s/ :TS// if $in;
		$in =~ /^PASS :?(.+)/ if $in;
		$pass = $1;
		$pass =~ s/\s*//g if $pass;	#Remove spaces from crypted password
		if($pass and $theirpass and ($pass ne $theirpass and $pass ne crypt($theirpass, substr($pass, 0, 2)))) { die("Upstream server gave the wrong password!\n"); }
	}

	if($ircservers{$servermode}{EBURST}) {
		while($in and ($in !~ /EBURST/)) {
			$in = $upstream->getline or die "Couldn't read from IRC server: $!\n";
			chomp $in;
			Toc::debug_print($in, "irc_connect", 1) if $in;
			if($in =~ /^ERROR :(.+)/) {
				print STDERR "IRC connection error: $1\n";
				exit 1;
			}
		}
	}

	$aimircdebug = 0;

	irc_send(irc_newnick($usnick)) or die "Couldn't make aimserv: $!\n";
	irc_send(":$usnick MODE $usnick -i\r\n");
	irc_send(":$us MODE $usnick +o\r\n");

	$aimselect = IO::Select->new();
	$ircselect = IO::Select->new();
	$ircselect->add($upstream);

	irc_send(":$usnick JOIN #aimirc-debug\r\n");
	irc_send(":$us MODE #aimirc-debug +nk $ourpass\r\n");
	$aimircdebug = 1;
	$longnicks{'#aimirc-debug'} = '#aimirc-debug';

	while(1 == 1) {
		exit(255) unless $upstream;
		@aims = $aimselect->can_read(.01);
		foreach $aim(@aims) {
			$connection = $aim_connections{$filenos[$aim->fileno]};
			process_aim_message($connection);
		}
		@aims = $aimselect->has_error(.01);
		foreach $aim(@aims) {
			$connection = $aim_connections{$filenos[$aim->fileno]};
			do_signoff($connection->{nick}, $connection);
		}

		@upstream = $ircselect->can_read(.01);
		if($upstream[0]) {
			$_ = $upstream->getline;
			chomp; s/[\r\n]$//;
			Toc::debug_print("From IRC: $_", "irc", 2);
			process_irc_message($_);
		}

		@upstream = $ircselect->has_error(.01);
		if($upstream[0]) {
			print STDERR "IRC connection closed.\n";
			exit 1;
		}

		if((time % 100) == 0) { #Cleanup nicks
			ANICK: foreach $anick(keys %nicks) {
				next if $anick = $usnick;
				$kill = 1;
				foreach $bnick(keys %{$nicks{$anick}}) {
					next ANICK if $kill == 0;
					$kill = 0 if $nicks{normalize($anick)}{$bnick} == -1;
					$kill = 0 if (time - $nicks{normalize($anick)}{$bnick}) < 3600;
				}
				if($kill == 1) {
					delete $nicks{$anick};
					irc_send(":$prefix$anick QUIT :$prefix$anick\r\n");
				}
			}
		}
	}
}

sub irc_subparms($;$$) {
	my($input, $user, $nick, $time) = @_;
	$time = time;
	$input =~ s/_TIME_/$time/g;
	$input =~ s/_USER_/$user/g;
	$input =~ s/_NICK_/$nick/g;
	$input =~ s/_UID_/$uid/g and $uid++;
	return $input;
}

sub irc_privmsg {
	my($from, $to, $msg, $prefix, $line, $ret) = @_;

	$from = substr($from, 0, $ircservers{$servermode}{nicklen});
	if($from ne $usnick and not $nicks{normalize($from)}) {
		irc_send(irc_newnick($from));
		$nicks{normalize($from)} = 1;
	}

	foreach $line(split(/[\r\n]+/, $msg)) {
		$ret .= ":$from PRIVMSG $to :$prefix$line\r\n";
	}
	return $ret or $msg;
}

sub irc_newnick {
	my($nick, $user, $string, $shortnick) = shift;
	$nick =~ tr/ //d;
	$user = $nick;
	$user =~ s/^$prefix//;
	$nicks{$nick} = 1;
	$shortnick = substr($nick, 0, $ircservers{$servermode}{nicklen});

	$longnicks{normalize($shortnick)} = $nick;
	$string = irc_subparms($ircservers{$servermode}{nick}, $user, $shortnick);
	$string .= ":$nick MODE $shortnick +i\r\n";
	return $string;
}

sub process_irc_message {
	my $nick;
	if(/^ERROR :(.+)/) {
		print STDERR "IRC server error: $1\n";
		exit 1;
	} elsif(/:([^ ]+) PRIVMSG $usnick :(.+)/i) { #$1 sent $2 to $usnick
		$nick = $1; $msg = $2;
		$cmd = undef; $extra = undef; $param = undef;
		$msg =~ /(\S+) (\S+)( ?.*)/ or $cmd = $msg;
		$cmd = $1 unless $cmd; $param = $2 if $2; $extra = substr($3, 1) || "" if $3;
		$cmd ||= $msg; #For cmds w/o param
		#warn "Cmd: $cmd\nParam: $param: Extra: $extra\n\n";
		$nick = lc($nick);
		unless($aim_connections{$nick} or ($cmd eq "signon") or ($cmd eq "help")) {
			irc_send(irc_privmsg($usnick, $nick, "You must use the signon command to sign on to AOL Instant Messenger before using this service."));
		} elsif($cmd eq "signon") {
			irc_send(irc_privmsg($usnick, $nick, "Usage: signon screenname password")) unless $param and $extra;
			if($aim_connections{$nick} and $aim_connections{$nick}{aimnick}) {
				irc_send(irc_privmsg($usnick, $nick, "You are already signed onto AOL instant messenger as $aim_connections{$nick}{aimnick} - please sign off first if you wish to sign on under a different screename, or use a different IRC connection."));
			} else {
				local @temp = ($param, $extra, $usnick, $nick);
				if($connectmode_fork) {
					my $pid = fork;
					if (not defined $pid) {
						irc_send(irc_privmsg($usnick, $nick, "Couldn't fork: $!"));
						Toc::debug_print("Couldn't fork: $!", "critical_errors", 1);
					} elsif($pid == 0) {
						got_signon(@temp);
						if($aim_connections{$tnick}{socket}) {
							while(1 == 1) {
								if($aim_connections{$tnick}{socket}->error) {
									do_signoff($tnick, $aim_connections{$tnick}{socket});
									exit;
								}
								process_aim_message($aim_connections{$tnick}{socket});
							}
						} else {
							exit;
						}
					} else {
						$aim_connections{$nick}{pid} = $pid;
					}
				} else {
					got_signon(@temp);
				}
			}
		} elsif ($cmd eq "buddylist") {
			my(%groups, $buddy, $group);
			%temp = deref(get_config($aim_connections{$nick}{aimnick}));
			foreach $buddy(sort keys %{$temp{Buddies}}) {
				push @{$groups{$temp{Buddies}{$buddy}{group}}}, $buddy;
			}
			foreach $group(sort keys %groups) {
				foreach $buddy(sort @{$groups{$group}}) {
					irc_send(irc_privmsg($usnick, $nick, "$buddy ($group)"));
				}
			}
		} elsif ($cmd eq "onbuddies") {
			my(%groups, $buddy, $group);
			%temp = deref(get_config($aim_connections{$nick}{aimnick}));
			foreach $buddy(sort keys %{$temp{Buddies}}) {
				push @{$groups{$temp{Buddies}{$buddy}{group}}}, $buddy if $temp{Buddies}{$buddy}{online};
			}
			foreach $group(sort keys %groups) {
				foreach $buddy(sort @{$groups{$group}}) {
					irc_send(irc_privmsg($usnick, $nick, "$buddy ($group)"));
				}
			}
		} elsif ($cmd eq "permitlist") {
			%temp = deref(get_config($aim_connections{$nick}{aimnick}));
			irc_send(irc_privmsg($usnick, $nick, join(" ", sort keys(%{$temp{permit}}))));
		} elsif ($cmd eq "denylist") {
			%temp = deref(get_config($aim_connections{$nick}{aimnick}));
			irc_send(irc_privmsg($usnick, $nick, join(" ", sort keys(%{$temp{deny}}))));
		} elsif ($cmd eq "signoff") {
			do_signoff($nick, $aim_connections{$nick}{socket}) if $aim_connections{$nick};
		} elsif ($cmd eq "buddyinfo") {
			irc_send(irc_privmsg($usnick, $nick, "Usage: buddyinfo screenname")) unless $param;
			%temp = deref(get_config($aim_connections{$nick}{aimnick}));
			$param = lc($param);
			$group = $temp{Buddies}{$param}{group};
			if($temp{Buddies}{$param}) {
				local $^W = 0;
				$msg = ":$usnick PRIVMSG $nick :";
				$msg .= "Group: $group\t" if $group and $group ne "Buddies";
				$msg .= "Signon time: " . localtime($temp{Buddies}{$param}{signon}) . "\tIdle time: $temp{Buddies}{$param}{idle} minutes\tUser class: ";
				$msg .= parseclass($temp{Buddies}{$param}{class}) . "\r\n";
				irc_send($msg);
			} else {
				irc_send(irc_privmsg($usnick, $nick,  "That persion is either not on your buddy list or not signed on."));
			}
		} elsif ($cmd eq "add_buddy") {
			irc_send(irc_privmsg($usnick, $nick, "Usage: add_buddy screenname [group]")) unless $param;
			$param = lc($param);
			$group = $extra || "Buddies";
			add_buddy($aim_connections{$nick}{socket}, $param, $group);
		} elsif ($cmd eq "remove_buddy") {
			irc_send(irc_privmsg($usnick, $nick, "Usage: remove_buddy screenname")) unless $param;
			$param = lc($param);
			remove_buddy($aim_connections{$nick}{socket}, $param);
			irc_send(irc_privmsg($usnick, $nick, "$param has departed"));
		} elsif ($cmd eq "evil" or $cmd eq "warn") {
			irc_send(irc_privmsg($usnick, $nick, "Usage: $cmd screenname [anon]")) unless $param;
			$param = lc($param);
			if($extra ne "anon") {
				$extra = 0;
			} else {
				$extra = 1;
			}
			evil($aim_connections{$nick}{socket}, $param, $extra);
		} elsif ($cmd eq "add_permit") {
			irc_send(irc_privmsg($usnick, $nick, "Usage: add_permit screenname")) unless $param;
			$param = lc($param);
			add_permit($aim_connections{$nick}{socket}, $param);
		} elsif ($cmd eq "add_deny") {
			irc_send(irc_privmsg($usnick, $nick, "Usage: add_deny screenname")) unless $param;
			$param = lc($param);
			add_deny($aim_connections{$nick}{socket}, $param);
		} elsif ($cmd eq "remove_deny") {
			irc_send(irc_privmsg($usnick, $nick, "Usage: remove_deny screenname")) unless $param;
			$param = lc($param);
			remove_deny($aim_connections{$nick}{socket}, $param);
		} elsif ($cmd eq "remove_permit") {
			irc_send(irc_privmsg($usnick, $nick, "Usage: remove_permit screenname")) unless $param;
			$param = lc($param);
			remove_permit($aim_connections{$nick}{socket}, $param);
		} elsif ($cmd eq "join") {
			irc_send(irc_privmsg($usnick, $nick, "Usage: join chat_id OR join chat_name")) unless $param;
			if($aim_connections{$nick}{chats}{$param} == 1) { #We're invited
				chat_accept($aim_connections{$nick}{socket}, $param);
			} else {
				$extra ? chat_join($aim_connections{$nick}{socket}, "$param $extra") : chat_join($aim_connections{$nick}{socket}, $param);
			}
		} elsif ($cmd eq "get_permit_mode") {
			irc_send(irc_privmsg($usnick, $nick, $aim_connections{$nick}{permtype}));
		} elsif ($cmd eq "set_permit_mode") {
			irc_send(irc_privmsg($usnick, $nick, "Usage: set_permit_mode newmode")) unless $param;
			$aim_connections{$nick}{permtype} = $param;
			permtype($aim_connections{$nick}{socket}, $param);
		} elsif ($cmd eq "list_permit_modes") {
			irc_send(irc_privmsg($usnick, $nick, "1=Permit All, 2=Deny All, 3=Permit if and only if on permitlist, 4=Deny if and only if on denylist"));
		} elsif ($cmd eq "chat") {
			irc_send(irc_privmsg($usnick, $nick, "Usage: chat chat_id text")) unless $param and $extra;
			chat_send($aim_connections{$nick}{socket}, $param, $extra);
		} elsif ($cmd eq "whisper") {
			$extra =~ /(\S+) (.*)/;
			irc_send(irc_privmsg($usnick, $nick, "Usage: whisper chat_id screenname text")) unless $param and $1 and $2;
			chat_whisper($aim_connections{$nick}{socket}, $param, $1, $2);
		} elsif ($cmd eq "chat_evil" or $cmd eq "chat_warn") {
			$extra =~ /(\S+) ?(.*)/;
			irc_send(irc_privmsg($usnick, $nick, "Usage: $cmd chat_id screenname [anon]")) unless $param and $extra;
			$foo = undef;
			$foo = "norm" if $2 ne "anon";
			$foo ne "norm" ? $foo = 1 : $foo = 0;
			chat_evil($aim_connections{$nick}{socket}, $param, $1, $foo);
		} elsif ($cmd eq "invite") {
			$param = lc($param);
			$extra =~ /(\S+) (.+)/;
			irc_send(irc_privmsg($usnick, $nick, "Usage: invite buddy1,buddy2,...,buddyN chat_id message")) unless $param and $1 and $2;
			@temp = split(/,/, $param);
			chat_invite($aim_connections{$nick}{socket}, $1, $2, @temp);
		} elsif ($cmd eq "part") {
			irc_send(irc_privmsg($usnick, $nick, "Usage: part chat_id")) unless $param;
			delete $aim_connections{$nick}{chat}{$param};
			chat_leave($aim_connections{$nick}{socket}, $param);
		} elsif ($cmd eq "info" or $cmd eq "get_info") {
			$param = lc($param);
			irc_send(irc_privmsg($usnick, $nick, "Usage: info screenname")) unless $param;
			get_info($aim_connections{$nick}{socket}, $param);
		} elsif ($cmd eq "set_info") {
			my $text;
			irc_send(irc_privmsg($usnick, $nick, "Usage: set_info info")) unless $param;
			$extra ? ($text = "$param $extra") : ($text = $param);
			set_info($aim_connections{$nick}{socket}, $text);
		} elsif ($cmd eq "get_dir") {
			irc_send(irc_privmsg($usnick, $nick, "Usage: get_dir screenname")) unless $param;
			get_directory($aim_connections{$nick}{socket}, $param);
		} elsif ($cmd eq "set_dir") {
			$param = "$param $extra" if $extra;
			if($param and $param ne "set_dir") {
				@temp = split(/:/, $param);
					%temp = (
					first_name => shift @temp,
					middle_name => shift @temp,
					last_name => shift @temp,
					maiden_name => shift @temp,
					city => shift @temp,
					state => shift @temp,
					country => shift @temp,
					allow_web_searches => shift @temp
				);
				set_directory($aim_connections{$nick}{socket}, %temp);
			} else {
				irc_send(irc_privmsg($usnick, $nick, "first name:middle name:last name:maiden name:city:state:country:websearch.  Don't put any colons in any of these.  If you put anything in the websearch field, people can find your directory info using web searches."));
			}
		} elsif ($cmd eq "dir_search") {
			$param = "$param $extra" if $extra;
			if($param and $param ne "dir_search") {
				@temp = split(/:/, $param);
				%temp = (
					first_name => shift @temp,
					middle_name => shift @temp,
					last_name => shift @temp,
					maiden_name => shift @temp,
					city => shift @temp,
					state => shift @temp,
					country => shift @temp,
					allow_web_searches => shift @temp
				);
				directory_search($aim_connections{$nick}{socket}, %temp);
			} else {
				irc_send(irc_privmsg($usnick, $nick, "first name:middle name:last name:maiden name:city:state:country:websearch.  Don't put any colons in any of these.  If you put anything in the websearch field, people can find your directory info using web searches."));
			}
		} elsif ($cmd eq "add") {
			irc_send(irc_privmsg($usnick, $nick, "Usage: add screenname")) unless $param;
			$param =~ tr/ //d; $inick = lc($param);
			unless($nicks{$inick}) {
				irc_send(irc_newnick($prefix . $param));
			}
			$nicks{$inick}{$nick} = time;
		} elsif ($cmd eq "help") {
			$foo = ":$usnick PRIVMSG $nick";
			if($param eq "basics") {
				$upstream->print("$foo :help - Show this screen.\r\n");
				$upstream->print("$foo :signon nick pass - Sign on to AOL Instant Messenger (AIM).  You must do this before any of the other commands.\r\n");
				$upstream->print("$foo :signoff - Sign off of AIM\.r\n");
				$upstream->print("$foo :add nick - Create an IRC nickname for nick.  Use this to talk to someone who's not on your buddylist.\r\n");
				$upstream->print("$foo :get_permit_mode - See your current permit mode.\r\n");
				$upstream->print("$foo :set_permit_mode newmode - Set your permit mode.\r\n");
				$upstream->print("$foo :list_permit_modes - List the valid permit modes and their definitions.\r\n");
			} elsif($param eq "buddies") {
				$upstream->print("$foo :add_permit nick - Add nick to your permit list, removing from deny list.\r\n");
				$upstream->print("$foo :add_deny nick - Add nick to your deny list, removing from permit list.\r\n");
				$upstream->print("$foo :buddyinfo name - Get signon time, idle time, evil level, and user class for a buddy.\r\n");
				$upstream->print("$foo :add_buddy nick [group] - Add nick to your buddy list.  If you give a group, buddy will be added to that group.\r\n");
				$upstream->print("$foo :remove_buddy nick - Remove nick from your buddy list.\r\n");
				$upstream->print("$foo :evil nick [anon] (or warn nick [anon]) - Warn nick, optionally anonymously.\r\n");
				$upstream->print("$foo :remove_permit nick - Remove nick from permit list.\r\n");
				$upstream->print("$foo :remove_deny nick - Remove nick from deny list.\r\n");
				$upstream->print("$foo :onbuddies - List buddies who are currently signed on (and who don't have you on block.)\r\n");
				$upstream->print("$foo :buddylist - List everyone on your buddylist.\r\n");
				$upstream->print("$foo :permitlist - See who is on your permit list.\r\n");
				$upstream->print("$foo :denylist - See who is on your deny list.\r\n");
			} elsif($param eq "chat") {
				$upstream->print("$foo :join topic - Create and join a new chatroom with topic set to topic.\r\n");
				$upstream->print("$foo :chat chat_id message - Send message to chat chat_id.\r\n");
				$upstream->print("$foo :whisper chat_id user message - Whisper to user in chat chat_id.\r\n");
				$upstream->print("$foo :accept chat_id - Accept an invitation to chat chat_id.\r\n");
				$upstream->print("$foo :invite buddy1,buddy2,...,buddyn chat_id message - Invite buddies into a chat.\r\n");
				$upstream->print("$foo :chat_evil chat_id nick [anon] (or chat_warn chat_id nick [anon]) - Warn nick inside chat_id, optionally anonymously.\r\n");
				$upstream->print("$foo :part chat_id - Leave chatroom chat_id.\r\n");
			} elsif($param eq "misc") {
				$upstream->print("$foo :get_info nick - Get info for nick.\r\n");
				$upstream->print("$foo :set_info new info - Set your info.\r\n");
				$upstream->print("$foo :get_dir nick - Get directory info for nick.\r\n");
				$upstream->print("$foo :set_dir [info] - Without info, gives you the syntax that info must be in.  With info, sets your directory info.\r\n");
				$upstream->print("$foo :dir_search [info] - Without info, gets the syntax that info must be in (the same as that of set_dir).  With info, searches the AOL Instant Messenger directory.\r\n");
			} elsif($param eq "debug") {
				if($debug) {
					$upstream->print("$foo :restart - Restart aimirc.  This will close the IRC connection and all AIM connections and launch a new aimirc process.\r\n");
					$upstream->print("$foo :newnick nick - Create a new nickname on irc.\r\n");
					$upstream->print("$foo :setlevel debug_channel level - Set debugging channel debug_channel to level (higher is more verbose, 0 to disable).  The special channel \"all\" will set the level of all channels at once.\r\n");
					$upstream->print("$foo :showlevels - List all debugging channels and their levels.\r\n");
					$upstream->print("$foo :rehash - Reload /etc/aimirc.conf and $home/.aimirc .\r\n");
					$upstream->print("$foo :reload - Evaluates $0.  This should let you make almost any change to Toc.pm or aimirc without having to do a full restart.\r\n");
					$upstream->print("$foo :raw who text - Send a raw IRC or AIM command (AIM commands are SFLAP-encoded but not quoted.) If who is irc, it will be sent as an IRC command.  If who is the IRC nickname or AIM nickname of someone connected to this aimirc server, text will be sent over that AIM connection.\r\n");
					$upstream->print("$foo :inject text - Act as though we got text from the IRC server.\r\n");
					$upstream->print("$foo :eval text - Evaluate text as Perl code.  All exceptions will be trapped and displayed.\r\n");
				} else {
					$upstream->print("$foo :Debugging support is not enabled.  Edit /etc/aimirc.conf or $home/.aimirc and send SIGHUP to PID $$.\r\n");
				}
			} else {
				$upstream->print("$foo :aimirc $version, (c)2000 Matthew Sachs.\r\n");
				$upstream->print("$foo :This program is licensed under Version 2 the GNU Public License.\r\n");
				$upstream->print("$foo :A copy of the license is available at http://www.gnu.org/copyleft/gpl.txt\r\n");
				$upstream->print("$foo :To see the commands available for a specific topic, use the command help topic.  The following topics are available:\r\n");
				$upstream->print("$foo :basics buddies chat misc\r\n");
				$upstream->print("$foo :NOTE: Remove all spaces from screennames (also referred to as nicknames or nicks) before using in any AIMIRC command or operation.  nick is the AIM nick, not the IRC one created by prepending $prefix.\r\n");
				$upstream->print("$foo :AIM stands for AOL Instant Messenger, which is a trademark of America Online, Inc.\r\n");
				$upstream->print("$foo :To send an IM to someone whose screenname is SomeDude, send an IRC message to ${prefix}SomeDude.\r\n");
				$upstream->print("$foo :That person must be on your buddylist, have sent you an IM recentely, or be added to IRC via the add command.\r\n");
			}
		} elsif($cmd eq "webpage") {
			irc_send(irc_privmsg($usnick, $connection->{nick}, html2txt(get($param), $connection->{nick})));
		} else {
			irc_send(irc_privmsg($usnick, $nick, "Unknown command - /msg $usnick help for help."));
		}
	} elsif(/:(\S+) PRIVMSG (\S+) :(.+)/i) { #$1 sent $3 to $2 (where $2 ne $usnick)
		$nick = $1; $target = normalize(aimnick($longnicks{normalize($2)})); $msg = $3;

		if($2 eq "#aimirc-debug" and $debug) {
			$msg =~ s/^(aimserv)\S*\s+//;
			if($msg eq "restart" and $1) {
				phoenix;
			} elsif($msg =~ /^newnick (.+)/ and $1) {
				irc_send(irc_newnick($1));
			} elsif($msg =~ /^setlevel (\S+) (\S+)/) {
				if($1 eq "all") {
					foreach $level(keys %debug) { $debug{$level} = $2; }
				} else {
					$debug{$1} = $2;
				}
			} elsif($msg =~ /^rehash/) {
				&rehash;
			} elsif($msg =~ /^reload/) {
				&reload;
			} elsif($msg =~ /^showlevels/) {
				foreach $level(keys %debug) { irc_send(irc_privmsg($usnick, "#aimirc-debug", "$level: $debug{$level}")); }
			} elsif($msg =~ /^inject (.+)/ and $1) {
				process_irc_message($1);
			} elsif($msg =~ /^raw (\S+) (.+)/ and $1 and $2) {
				if($1 eq "irc") {
					irc_send("$2\r\n");
				} elsif($aim_connections{$1}) {
					sflap_put($aim_connections{$1}{socket}, sflap_encode($2, 0, 1));
				} else {
					$success = 0;
					AIMNICK: foreach $nick(keys %aim_connections) {
						if(normalize($aim_connections{$nick}{aimnick}) eq normalize($1)) {
							$success = 1;
							sflap_put($aim_connections{$nick}{socket}, sflap_encode($2, 0, 1));
							last AIMNICK;
						}
					}
					irc_send(irc_privmsg($usnick, "#aimirc-debug", "Couldn't find that person.")) unless $success;
				}
			} elsif($msg =~ /^eval (.+)/ and $1) {
				undef $@;
				eval $1;
				irc_send(irc_privmsg($usnick, "#aimirc-debug", $@, "EVAL: "));
			} else {
				irc_send(irc_privmsg($usnick, "#aimirc-debug", "Invalid debug command - /msg aimserv help debug for help)"));
			}
		} else {
			$target = normalize($target);
			message($aim_connections{$nick}{socket}, $target, $msg);
			$nicks{$target}{$nick} = time if $nicks{$target}{$nick}!= -1;
		}
	} elsif(/^:(\S+) AWAY(.*)/) {
		$nick = $1;
		if($2 =~ /:(.*)/) {
			$aim_connections{$nick}{away} = $1;
			set_away($aim_connections{$nick}{socket}, $1);
		} else {
			delete $aim_connections{$nick}{away};
			delete $aim_connections{$nick}{away_buddies};
			set_away($aim_connections{$nick}{socket});
		}
	} elsif(/^:(\S+) NICK (\S+)/) { #Nick change
		$aim_connections{$2} = $aim_connections{$1};
		$aim_connections{$1}{nick} = $2;
		delete $aim_connections{$1};
		$filenos[$aim_connections{$2}{socket}->fileno] = $2 if $aim_connections{$2}{socket};
	} elsif(/^:(\S+) QUIT/) {
		delete $aim_connections{$aim_connections{$1}{socket}->fileno} if $aim_connections{$1}{socket};
		$aimselect->remove($aim_connections{$1}{socket}) if $aim_connections{$1}{socket};
		signoff($aim_connections{$1}{socket}) if $aim_connections{$1}{socket};
		delete $aim_connections{$1};
	} elsif(/^PING/) {
		irc_send("PONG $us\r\n");
	}
}

sub process_aim_message {
	my ($connection) = shift;
	my($msg, $cmd, $val, $inick, $ar);

	$msg = sflap_get($connection->{socket});
	if($msg eq "-1") {
		irc_send(irc_privmsg($usnick, $connection->{nick}, "Error reading: $err"));
		return;
	}
	#warn "AIM got $msg for $connection->{nick}\n";
	$msg =~ /^([^:]+):(.+)/;
	$cmd = $1; $val = $2;
	if($cmd eq "ERROR") {
		$val =~ /([^:]+):?(.*)/;
		Toc::debug_print("Error $1: " . aim_strerror($1, $2), "errors", 1);
		irc_send(irc_privmsg($usnick, $connection->{nick}, "Error $1: " . aim_strerror($1, $2)));
	} elsif($cmd eq "CONFIG") {
		update_config($connection->{socket}, $msg);
	} elsif($cmd eq "IM_IN") {
		my $nick;
		$val =~ /([^:]+):(.):(.*)/;
		my $autoflag = $2;
		my $message = $3;
		$inick = $1; $inick =~ tr/ //d;
		$nnick = lc($inick);

		unless($nicks{$nnick}) {
			irc_send(irc_newnick($prefix . $inick));
		}
		($autoflag eq "T") ? ($ar = "[automatic response] ") : ($ar = "");
		@lines = html2txt($message, $nick);
		irc_send(irc_privmsg($prefix . $inick, $connection->{nick}, $ar . $lines[0]));
		shift @lines;
		foreach $line(@lines) {
			irc_send(irc_privmsg($prefix . $inick, $connection->{nick}, "[continued]\t\t$line"));
		}

		if(($ar eq "") and $connection->{away} and (time - $connection->{away_buddies}{$nnick} > $time)) {
			my $tmp;
			my %config = deref(get_config($connection->{aimnick}));
			my $class = $config{Buddies}{$nnick}{class};
			if(substr($class, 0, 1) eq "A") {
				$tmp = "[automated reply] " . $connection->{away};
			} else {
				$tmp = $connection->{away};
			}
			message($connection->{socket}, $nnick, $tmp, 1);
		}
		$connection->{away_buddies}{$nnick} = time;
		$nicks{$nnick}{$connection->{nick}} = time if $nicks{$nnick}{$connection->{nick}} != -1;
	} elsif($cmd eq "UPDATE_BUDDY") {
		$val =~ /([^:]+):(.):([^:]+):([^:]+):([^:]+):(.+)/;
		$inick = $1; $inick =~ tr/ //d;
		$nnick = lc($inick);
		Toc::debug_print("$connection->{nick} UPDATE_BUDDY: $val", "buddies", 1);
		if($2 eq "T") {
			%temp = deref(get_config($connection->{aimnick}));
			irc_send(irc_privmsg($usnick, $connection->{nick}, "$inick has arrived")) unless $temp{Buddies}{$nnick}{online};
			{
				local $^W = 0;
				irc_send(irc_privmsg($usnick, $connection->{nick}, "$inick has gone away")) if substr($temp{Buddies}{$nnick}{class}, 2, 1) ne "U" and substr($6, 2, 1) eq "U";
				irc_send(irc_privmsg($usnick, $connection->{nick}, "$inick is no longer away")) if substr($temp{Buddies}{$nnick}{class}, 2, 1) eq "U" and substr($6, 2, 1) ne "U";
			}
			update_buddy($connection->{aimnick}, $nnick, $6, $3, $4, $5, 1);

			irc_send(irc_newnick($prefix . $inick)) unless scalar keys %{$nicks{$nnick}};;
			$nicks{$nnick}{$connection->{nick}} = -1;
		} else {
			update_buddy($connection->{aimnick}, $nnick, $6, $3, $4, $5, 0);
			irc_send(irc_privmsg($usnick, $connection->{nick}, "$inick has departed"));
			delete $nicks{$nnick}{$connection->{nick}};
			delete $nicks{$nnick} unless keys %{$nicks{$nnick}};
			irc_send(":$prefix$inick QUIT :$prefix$inick\r\n") unless scalar keys %{$nicks{$nnick}};
		}
	} elsif($cmd eq "EVILED") {
		$val =~ /([^:]+):(.*)/;
		$connection->{evil} = $1;
		irc_send(irc_privmsg($usnick, $connection->{nick}, ($2 || "Anonymous") . " has just evilled you.  Your new evil level is $1%."));
	} elsif($cmd eq "CHAT_JOIN") {
		$val =~ /([^:]+):(.*)/;
		$connection->{chats}{$1} = $2;
		Toc::debug_print("$connection->{nick} has joined chat $2 (ID $1)", "chat", 2);
		irc_send(irc_privmsg($usnick, $connection->{nick}, "You have joined chat $2.  Chat id is $1."));
	} elsif($cmd eq "CHAT_IN") {
		my $nick;
		$val =~ /([^:]+):([^:]+):(.):(.*)/;
		Toc::debug_print("$2 said to $connection->{nick} in chat $1: $lines[0]", "chat", 2);
		$msg = ":$usnick PRIVMSG $connection->{nick} :$2 ";
		($3 eq "T" or $3 eq "t") ? ($msg .= "whispered ") : ($msg .= "said ");
		@lines = html2txt($4, $nick);
		$msg .= "in chat $1: $lines[0]\r\n";
		shift @lines;
		foreach $line(@lines) {
			Toc::debug_print("[continued] $line", "chat", 2);
			$msg .= irc_privmsg($usnick, $connection->{nick}, "[continued]\t\t$line");
		}
		irc_send($msg);
	} elsif($cmd eq "CHAT_UPDATE_BUDDY") {
		$val =~ /([^:]+):(.):(.+)/;
		my $msg;
		$msg = ":$usnick PRIVMSG $connection->{nick} :The following users have ";
		($2 eq "T") ? ($msg .= "joined") : ($msg .= "left");
		irc_send("$msg chat $connection->{chats}{$1}: $3\r\n");
	} elsif($cmd eq "CHAT_INVITE") {
		$val =~ /([^:]+):([^:]+):([^:]+):(.*)/;
		Toc::debug_print("$connection->{nick} has been invited to chat $1 ($4) [$2] by $3", "chat", 2);
		$connection->{chats}{$2} = 1;
		irc_send(irc_privmsg($usnick, $connection->{nick}, "$3 has invited us to chatroom $1 ($4).  To accept, /msg $usnick join $2"));
	} elsif($cmd eq "CHAT_LEFT") {
		irc_send(irc_privmsg($usnick, $connection->{nick}, "Chat $connection->{chats}{$val} has been dropped."));
		delete $connection->{chats}{$val};
	} elsif($cmd eq "GOTO_URL") {
		$val =~ /[^:]+:(.+)/;
		my $html = get("http://toc-d01.blue.aol.com/$1");
		$html =~ s/<I>Legend:.*//m;
		Toc::debug_print($html, "html", 2);
		irc_send(irc_privmsg($usnick, $connection->{nick}, html2txt($html, $connection->{nick})));
	}
}

sub html2txt {
	my ($msg, $nick, $parsetree, @lines) = @_;
	my($linkct, $link, $elem, $node) = 0;

	$parsetree = HTML::TreeBuilder->new->parse($msg);
	$parsetree->eof;

	$msg = new HTML::FormatAIMIRC (leftmargin => 0, rightmargin => 4096)->format($parsetree);
	$parsetree->delete;
	return $msg;
}

sub aimnick {
	my($nick) = shift;
	$nick = lc($nick);
	$nick =~ s/^$prefix//i;
	return $nick;
}


sub Toc::debug_print($$$) {
	my($text, $type, $level) = @_;
	my($line, @lines);

	return unless $debug;
	return if defined($debug{$type}) and $level > $debug{$type};

	if($aimircdebug and $debug < 2) {
		@lines = split(/[\r\n]+/, $text);

		foreach $line(@lines) {
			$upstream->print(":$usnick PRIVMSG #aimirc-debug :($type, $level) $line\r\n");
		}
	} else {
		chomp $text;
		print STDERR "$text\n";
	}
}

sub irc_send {
	lock $upstream;
	Toc::debug_print("To IRC  : $_[0]", "irc", 2);
	$upstream->print($_[0]);
}

sub deref($) {
	my $href = shift;
	return %$href;
}

sub rehash {
	irc_send(irc_privmsg($usnick, "#aimirc-debug", "Rehashing..."));
	if(-r "/etc/aimirc.conf") {
		undef $@;
		do "/etc/aimirc.conf";
		$@ =~ tr/\r//d;
		irc_send(irc_privmsg($usnick, "#aimirc-debug", $@, "EVAL: "));
		if($@) {
			irc_send(irc_privmsg($usnick, "#aimirc-debug", "Couldn't reload /etc/aimirc.conf - there were errors."));
		} else {
			irc_send(irc_privmsg($usnick, "#aimirc-debug", "Reloaded /etc/aimirc.conf"))
		}
	} else {
		irc_send(irc_privmsg($usnick, "#aimirc-debug", "Not loading /etc/aimirc.conf - couldn't read"));
	}
	if(-r "$home/.aimirc") {
		undef $@;
		do "$home/.aimirc" if -r "$home/.aimirc";
		irc_send(irc_privmsg($usnick, "#aimirc-debug", $@, "EVAL: "));
		if($@) {
			irc_send(irc_privmsg($usnick, "#aimirc-debug", "Couldn't reload $home/.aimirc - there were errors."));
		} else {
			irc_send(irc_privmsg($usnick, "#aimirc-debug", "Reloaded $home/.aimirc"))
		}
	} else {
		irc_send(irc_privmsg($usnick, "#aimirc-debug", "Not loading $home/.aimirc - couldn't read"));
	}
	irc_send(irc_privmsg($usnick, "#aimirc-debug", "Rehash complete!"));
}

sub reload {
	irc_send(irc_privmsg($usnick, "#aimirc-debug", "Reloading $0..."));
	$reload = 1;
	undef $@;
	local $SIG{__DIE__} = sub { $@ = shift; };
	do $0;
	irc_send(irc_privmsg($usnick, "#aimirc-debug", $@, "EVAL: "));
	if($@) {
		irc_send(irc_privmsg($usnick, "#aimirc-debug", "Couldn't reload $0 - there were errors."));
	} else {
		irc_send(irc_privmsg($usnick, "#aimirc-debug", "Reload complete!"));
	}
}

sub dispver {
	print "aimirc: IRC <-> AOL Instant Messenger gateway.\n";
	print "AOL Instant Messenger, AOL, and America Online are trademarks of America Online, Inc.\n";
	print "Version: $VERSION\n";
	print "Use $0 --help for command-line options.\n";
	print "Use $0 --license to see the license (GPL v2)\n";
	exit 0;
}

sub license { print $license; exit 0; }

sub help {
	print <<EOF
aimirc - IRC <-> AOL Instant Messenger gateway
AOL Instant Messenger, AOL, and America Online are trademarks of America Online, Inc.
Version $VERSION

Usage: $0 [--version] [--license] [--help] [--config conffile] [--config conffile] ...

You can use either the short or long forms with one or two dashes in
whatever combination you want.  However, you can't combine options as in
$0 -VC.

	--version, -V:			Display version information and exit

	--license:			Display license information and exit

	--help, -h:			Print this message and exit

	--config, -C:			Specify configuration files to use.
					This option overrides the default
					configuration file locations.
					You may specify this option multiple
					times to use multiple configuration
					files.

This is also an option for every directive in the configuration file.
The options have the same names as the directives, but prefix them with
two dashes (--) instead of the Perl variable type identifies (\$\@\%).

See the included README file for more information.
EOF
;
	exit 0;
}


sub got_signon {
	my($tparam, $textra, $tusnick, $tnick, $nparam, %temp, @ret) = @_;

	$nparam = normalize($tparam);

	# lock $aim_connections{$tnick};
	@ret = signon $nparam, $textra, sub { irc_send(irc_privmsg($tusnick, $tnick, $_[0])) };
	if($ret[0] == 0) {
		{
			$aim_connections{$tnick}{nick} = $tnick;
			$aim_connections{$tnick}{aimnick} = $nparam;
			$aim_connections{$tnick}{socket} = $ret[1];
			$aim_connections{$tnick}{permtype} = $ret[2]->{permtype};
		}
		%temp = %{$ret[2]};

		{
			lock @filenos;
			$filenos[$aim_connections{$tnick}{socket}->fileno] = $tnick;
		}
		{
			lock $aimselect;
			$aimselect->add($aim_connections{$tnick}{socket});
		}

		irc_send(irc_privmsg($tusnick, $tnick, "You are now connected to AOL Instant Messenger."));
		{
			lock $nicks{$nparam};
			unless($nicks{$nparam}) {
				irc_send(irc_newnick($prefix . $tparam));
				$nicks{$nparam}{$tnick} = -1;
			}
		}
	} else {
		lock $err;
		irc_send(irc_privmsg($tusnick, $tnick, $err));
	}
}

sub do_signoff {
	my ($nick, $connection) = @_;

	if(UNIVERSAL::isa($connection, "IO::Socket::INET")) {
		delete $aim_connections{$connection->fileno};
		$aimselect->remove($connection) if UNIVERSAL::isa($aimselect, "IO::Select");
		signoff($connection);
	}
	delete $aim_connections{$nick};
	irc_send(irc_privmsg($usnick, $nick, "You have been signed off of AOL Instant Messenger."));
}

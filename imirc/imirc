#!/usr/bin/perl

$license = <<EOF
Copyright (c) 1999-2000 Matthew Sachs.  All Rights Reserved.

   This program is free software; you can redistribute it and/or
   modify it under the terms of version 2 of the GNU General Public License
   as published by the Free Software Foundation.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

   The GNU General Public License is included with the aimirc distribution
   under the filename COPYING.

 AOL Instant Messenger, AOL, and America Online are trademarks of America Online, Inc.
EOF
;

sub BEGIN {
	require FindBin;
	use lib $FindBin::Bin;

	eval {
		require HTML::FormatText;
		require HTML::Parse;
	};

	if($@) {
		print STDERR "Couldn't require HTML::FormatText and/or HTML::Parse.  Here's why:\n";
		print STDERR "$@\n";
		print STDERR "\n\n";
		print STDERR "And here's what that probably means...\n\n";
		print STDERR "You do not have the HTML::FormatText and HTML::Parse modules installed.\n";
		print STDERR "There are at least three possible ways to install these modules:\n";
		print STDERR "1) [preferred] Get them as a package from your OS vendor or Linux distributor.\n";
		print STDERR "        In Debian, you can install the libhtml-tree-perl and \n";
		print STDERR "        libhtml-format-perl packages.  I'm not sure about\n";
		print STDERR "        other operating systems or distributions.\n";
		print STDERR "2) Use the CPAN module to install it.  Run perl -MCPAN -e shell and \n";
		print STDERR "        type install HTML::Tree when you get to the CPAN prompt, and\n";
		print STDERR "        then install HTML::FormatText .\n";
		print STDERR "3) Download the source from CPAN and install it.  The source is located\n";
		print STDERR "        at http://www.perl.com/CPAN/modules/by-module/HTML/ in a file\n";
		print STDERR "        called HTML-Tree-VERSION.tar.gz where VERSION is the latest version\n";
		print STDERR "        of HTML-Tree.  You will also need the HTML-Format-VERSION.tar.gz\n";
		print STDERR "        package.\n";
		die "\n";
	}

	package HTML::FormatAIMIRC;

		@ISA = qw(HTML::FormatText);

		#Since we want to be able to trap all tags, we define a custom AUTOLOAD and format
		sub AUTOLOAD {
			my $sub = $AUTOLOAD;
			my $elem = shift;
			my $attr;
			my $output;

			$sub =~ s/^.+::(.+)_(start|end)$/$1/ or return 0;

			if($2 eq "end") {
				if($elem->{_original_html} =~ m!/$sub!) {
					#Ooh, now this is a fun hack.
					#It's not smart enough to know whether to make unknown tags containers.
					#So, if someone grins at you: <g> you'll still get a g_end call.
					#Which normally would do produce <g></g>
					#
					#But what about those times when you really want the closing tags?
					#Well we store the original HTML in the FormatAIMIRC object and use that to check.
	
					push @{$elem->{output}}, "</$sub>";
				}
			} else {
				#Get all attributes (<tag attr=val attr2=val2>)
				foreach $attr(keys %{$_[0]}) {
					next if $attr =~ /^_/;
					$output .= " $attr=$_[0]->{$attr}";
				}
				push @{$elem->{output}}, "<$sub$output>";
			}
			return $elem;
		}

		sub format {
			my($self, $html) = @_;
			$self->begin();
			$html->traverse(sub {
				my($node, $start, $depth) = @_;
				if (ref $node) {
					my $tag = $node->tag;
					my $func = $tag . '_' . ($start ? "start" : "end");
					return $self->$func($node);
				} else {  
					$self->textflow($node);
				}
				1;
			});
			$self->end();
			join('', @{$self->{output}});
		}

		sub hr_start {
			my $self = shift;
			$self->vspace(1);
			$self->out("=" x 30);
			$self->vspace(1);
		}

		sub img_start {
			my($self, $elem) = @_;

			$self->out("[IMAGE " . ($elem->attr('alt') || $elem->attr('src')) . "]");
		}

		#We can't get at the HREF inside of sub out, so set it here.
		sub a_start {
			my ($self, $elem) = @_;
		
			$self->{anchor}++;
			push @{$self->{output}}, " " x $self->{hspace} . "{";
			$self->{hspace} = 0;
			1;
		}
		
		sub a_end {
			my($self, $elem) = @_;

			$self->{anchor}--;
			push @{$self->{output}}, "} {" . $elem->attr('href') . "}";
		}

		#Mostly ripped straight from HTML::FormatText, with a few critical additions.
		sub out {
			my($self, $text) = @_;
			my($bold, $italic, $underline, $color) = (chr(2), chr(oct(26)), chr(oct(37)), chr(3));
			
			if ($text =~ /^\s*$/) { 
				$self->{hspace} = 1;
				return;
			}
			
			#open(TMP, ">>/tmp/aimirc.html.txt");
			#print TMP "out $text:\n" . Data::Dumper::Dumper($self);
			#close TMP;

			#Translate HTML formatting to IRC formatting
			$text = "$bold$text$bold" if $self->{bold};
			$text = "$italic$text$italic" if $self->{italic};
			$text = "$underline$text$underline" if $self->{underline};
			#$text = "{$text" if $self->{anchstart} and $self->{anchor};
			#$text = "$text} {$self->{href}}" if $self->{anchstart} and not $self->{anchor}; #So we can see link addresses...
			
			if (defined $self->{vspace}) {
				if ($self->{out}) {
					$self->nl while $self->{vspace}-- >= 0;
				}
				$self->goto_lm;
				$self->{vspace} = undef;
				$self->{hspace} = 0;
			}
			
			if ($self->{hspace}) {
				if ($self->{curpos} + length($text) > $self->{rm}) {
					# word will not fit on line; do a line break
					$self->nl;
					$self->goto_lm;
				} else {
					# word fits on line; use a space
					$self->collect(' ');
					++$self->{curpos};
				}
				$self->{hspace} = 0;
			}
			
			$self->collect($text);
			my $pos = $self->{curpos} += length $text;
			$self->{maxpos} = $pos if $self->{maxpos} < $pos;
		
			$self->{'out'}++;
		}
	
		1;

	package main;
}

use FindBin;
use lib $FindBin::Bin;

use IO::Handle;
use IO::Socket;
use POSIX;
use Carp;
use Getopt::Long;
use LWP::Simple;
use ScandanavianCase qw(lc uc);

$Carp::Verbose = 1;

eval { require Data::Dumper; };

use Toc qw(:all);

$SIG{__DIE__}  = sub { croak $_[0] };

$home = (getpwuid($>))[7];
$version = $VERSION = "0.90";

@args = @ARGV;

# setpriority(0, $$, 19);


#Defaults
$prefix = "AIM-";
$usnick = "AIMServ";
$us = "aimserv.your.irc.net"; #IRC server name to claim to be
$them = "127.0.0.1"; #Hostname of IRC server to connect to
$themport = 6667;
$ourpass = "foo";
$theirpass = "bar";
$servermode = "dal2";  #Should be either dal2 or dragonfire.
			#You can try something else, but I don't think the
			#default method works.
$time = 60*5; #Five minutes.
$verbose_signon = 0;
$ssl = 1;
@default_conffiles = ("/etc/aimirc.conf", "$home/.aimirc");
$fork = 1;
$verbose = 0;
$sendidle = 1;
$tocserver = 'toc.oscar.aol.com';
$tocport = 80;
*debuglevel = *debug;	#We can now reference debuglevels as %debuglevel or %debug

Getopt::Long::Configure("no_ignore_case");
Getopt::Long::Configure("pass_through");

$errors = &GetOptions(
	"version|V" => \&dispver,
	"license" => \&license,
	"config|C=s\@" => \@conffiles,
	"help|h" => \&help,
);

@conffiles = @default_conffiles unless $conffiles[0];

if(!$errors) {
	print STDERR "Try $0 --help if you need help.\n";
	exit 1;
}

$foundconfig = 0;
foreach $conffile(@conffiles) {
	$conffile =~ s/~/$home/;
	if(-r $conffile) {
		print STDERR "Reading config file $conffile\n" if $verbose;
		do $conffile;
		die $@ if $@;
		$foundconfig = 1;
	} else {
		print STDERR "Couldn't read config file $conffile\n" if $verbose;
	}
}

unless($foundconfig) {
	print STDERR "We couldn't find a config file.\n";
	print STDERR "You must edit aimirc.conf and copy it to either /etc/aimirc.conf or\n";
	print STDERR "   $home/.aimirc.  If you have already done this, make sure the aimirc\n";
	print STDERR "   user has permission to read it.\n";
	print STDERR "Or, perhaps you specified a config file with the --config (-C) option.\n";
	print STDERR "If you want to specify everything on the command-line and not use a config\n";
	print STDERR "   file (why?) then just give it a blank config file to make it happy.\n";
	exit 1;
}

Getopt::Long::Configure("no_pass_through");

$errors = &GetOptions(
	"us=s" => \$us,
	"them=s" => \$them,
	"themport=i" => \$themport,
	"ourpass=s" => \$ourpass,
	"theirpass=s" => \$theirpass,
	"servermode=s" => \$servermode,
	"prefix=s" => \$prefix,
	"usnick=s" => \$usnick,
	"time=i" => \$time,
	"ssl:i" => \$ssl,
	"fork=i" => \$fork,
	"verbose|v" => \$verbose,
	"debug:i" => \$debug,
	"debuglevel=s\%" => \%debuglevel,
	"verbose_signon:i" => \$verbose_signon,
	"sendidle:i" => \$sendidle,
	"tocserver=s" => \$tocserver,
	"tocport=i" => \$tocport,
);

if(!$errors) {
	print STDERR "Try $0 --help if you need help.\n";
	exit 1;
}

%temp = %ircservers; #Preserve custom ircservers

%ircservers = (
	dal2 => {
		nick => "NICK _NICK_ 1 _TIME_ _USER_ $us $us 0 :AOL Instant Messenger client via aimirc\r\n",
		server => "SERVER $us 1 :AOL Instant Messenger services\r\n",
		uspass => 1,
		theirpass => 1,
		nicklen => 30,
		pass => "PASS $ourpass :1\r\n",
		EBURST => 1,
	},
	dragonfire => {
		nick => "NICK _NICK_ 1 _TIME_ _USER_ $us $us :AOL Instant Messenger client via aimirc\r\n",
		server => "SERVER $us 1 :AOL Instant Messenger services\r\n",
		uspass => 1,
		theirpass => 1,
		nicklen => 10,
		pass => "PASS $ourpass :1\r\n"
	},
	ircu => {
		nick => "NICK _NICK_ 1 _TIME_ _USER_ $us +i :AOL Instant Messenger services\r\n",
		server => "SERVER $us 1 _TIME_ _TIME_ P09 :AIM Services\r\n",
		uspass => 1,
		theirpass => 1,
		nicklen => 9,
		pass => "PASS :$ourpass\r\n"
	},
	rfc => {
		nick => "NICK _NICK_ 1\r\n:_NICK_ USER _USER_ $us $us :AOL Instant Messenger client via aimirc\r\n",
		server => "SERVER $us 1 :AOL Instant Messenger serices\r\n",
		uspass => 1,
		theirpass => 1,
		nicklen => 9,
		pass => "PASS :$ourpass\r\n"
	},
	ts => {
		nick => "NICK _NICK_ 1 _TIME_ +i _USER_ $us $us :AOL Instant Messenger client via aimirc\r\n",
		server => "SERVER $us 1 :AOL Instant Messenger serices\r\nSVINFO 3 1 0 :_TIME_\r\n",
		uspass => 1,
		theirpass => 1,
		nicklen => 9,
		pass => "PASS $ourpass :TS\r\n",
	},
);

foreach $server(keys %temp) { #Preserve custom ircservers
	$ircservers{$server} = $temp{$server};
}

if($ssl) {
	eval {
		require SSLv3;
	};

	if($@) {
		print STDERR "Couldn't require SSLv3.\n";
		print STDERR "Probably due to a problem with IO::Socket::SSL.  Here's what Perl thinks:\n";
		print STDERR "$@\n";
		print STDERR "\n\n";
		print STDERR "And here's what that probably means...\n\n";
		print STDERR "You do not have the IO::Socket::SSL module installed.\n";
		print STDERR "There are at least two possible ways to install these modules:\n";
		print STDERR "1) [preferred] Get them as a package from your OS vendor or Linux distributor.\n";
		print STDERR "2) Use the CPAN module to install it.  Run perl -MCPAN -e shell and \n";
		print STDERR "        type install IO::Socket::SSL when you get to the CPAN prompt.\n";
		print STDERR "3) Download the source from CPAN and install it.  The source is located\n";
		print STDERR "        at http://www.perl.com/CPAN/modules/by-module/IO/ in a file\n";
		print STDERR "        called IO-Socket-SSL-VERSION.tar.gz where VERSION is the latest version\n";
		print STDERR "        of IO::Socket::SSL.\n";
		print STDERR "Note that IO::Socket::SSL has a couple of dependencies.\n";
		print STDERR "It requires the Net::SSLeay perl module and the OpenSSL library.\n";
		print STDERR "\n";
		print STDERR "IO::Socket::SSL is only required if you want to use SSL to communicate with TOC.\n";
		print STDERR "SSL is a type of encryption.\n";
		print STDERR "If you don't want SSL, set $ssl to 0 in your aimirc.conf (or .aimirc)\n";
		print STDERR "Alternatively, you can use the --ssl 0 command-line option.\n";
		die "\n";
	}

	SSLv3->context_init(SSL_verify_mode => 0x00, SSL_server => 0);
}

unless($reload) {
	if($fork) {
		#We don't need no stinking ampersands!
		$pid = fork;
		exit if $pid;
		die "Couldn't fork: $!" unless defined($pid);

		POSIX::setsid() or die "Can't start a new session: $!";
	}
	sub kill_handler {
		$upstream->close;
		foreach $connections(keys %$aim_connections) {
			$connections->{socket}->close;
		}
		exit 1;
	}
}

$SIG{INT} = $SIG{TERM} = \&kill_handler;
$SIG{CHLD} = 'IGNORE';

#Restart on SIGHUP
sub phoenix {
	$upstream->close;
	foreach $key(keys %aim_connections) {
		$aim_connections{$key}{socket}->close if $aim_connections{$key}{socket};
	}
	exec($0, @args);
}
$SIG{HUP} = \&rehash;


#Hello Mort!
sub REAPER {
	1 until (-1 == waitpid(-1, WNOHANG));
	$SIG{CHLD} = \&REAPER;
}
$SIG{CHLD} = \&REAPER;

#Connect

#enc: `sflap encode buflen (1 iff TYPE_SIGNON else 0) seqno`
#dec: `sflap decode`

$| = 1;

unless($reload) {
	$upstream = IO::Socket::INET->new(PeerAddr => "$them:$themport", Timeout => 60) or die "Couldn't connect to IRC server $them:$themport ($!)\n";

	$flags = '';
	fcntl($upstream, F_GETFL, $flags) or die "Couldn't get flags for upstream: $!";
	$flags |= O_NONBLOCK;
	fcntl($upstream, F_SETFL, $flags) or die "Couldn't set flags for upstream: $!";

	do { irc_send($ircservers{$servermode}{pass}) if $ourpass and $ircservers{$servermode}{uspass}; } or die "Couldn't send PASS: $!\n";
	irc_send(irc_subparms($ircservers{$servermode}{server})) or die "Couldn't send PASS: $!\n";

	$in = "...";

	$lasttime = time;
	$keepalive = 0;

	if($theirpass and $ircservers{$servermode}{theirpass}) {
		while($in and ($in !~ /PASS :?(.+)/)) {
			$in = irc_recv();
			chomp $in;
			if($in =~ /^ERROR :(.+)/) {
				print STDERR "IRC connection error: $1\n";
				exit 1;
			} elsif($in =~ /^SERVER (\S+)/) {
				$themname = $1;
			}
		}

		$in =~ s/ :1// if $in;
		$in =~ s/ :TS// if $in;
		$in =~ /^PASS :?(.+)/ if $in;
		$pass = $1;
		$pass =~ s/\s*//g if $pass;	#Remove spaces from crypted password
		if($pass and $theirpass and ($pass ne $theirpass and $pass ne crypt($theirpass, substr($pass, 0, 2)))) { die("Upstream server gave the wrong password!\n"); }
	}

	if($ircservers{$servermode}{EBURST}) {
		while($in and ($in !~ /EBURST/)) {
			$in = irc_recv();
			chomp $in;
			if($in =~ /^ERROR :(.+)/) {
				print STDERR "IRC connection error: $1\n";
				exit 1;
			} elsif($in =~ /^SERVER (\S+)/) {
				$themname = $1;
			}
		}
	}

	$aimircdebug = 0;

	irc_send(irc_newnick($usnick)) or die "Couldn't make aimserv: $!\n";
	irc_send(":$usnick MODE $usnick -i\r\n");
	irc_send(":$usnick MODE $usnick +oa\r\n");

	irc_send(send_join($usnick, "#aimirc-debug"));
	send_server_mode("#aimirc-debug +o $usnick");
	irc_send(":$usnick MODE #aimirc-debug +nk $ourpass\r\n");
	$aimircdebug = 1;
	$longnicks{'#aimirc-debug'} = '#aimirc-debug';

	while(1 == 1) {

		exit(255) unless $upstream;
		@aims = keys %aim_connections;
		foreach $aim(@aims) {
			$connection = $aim_connections{$aim};
			do_signoff($connection->{nick}, undef) unless $connection->{socket};
			$msg = sflap_get($connection->{socket});
			if($msg == -1) {
				irc_send(irc_privmsg($usnick, $connection->{nick}, "There was an error with your AOL Instant Messenger connection: $err"));
				do_signoff($connection->{nick}, $connection->{socket});
			} elsif($msg) {
				process_aim_message($msg);
			}
		}

		select(undef, undef, undef, .01);
		$_ = irc_recv(1);
		process_irc_message($_) if $_;

		#if($upstream->error or $upstream->eof) {
		#	print STDERR "IRC connection closed: " . $upstream->error . "\n";
		#	exit 1;
		#}

		$currtime = time;

		if((($currtime % 100) == 0) and ($currtime - $lasttime) >= 100) { #Cleanup nicks
			$lasttime = $currtime;
			Toc::debug_print("Reaping nicks...", "nicks", 3);
			ANICK: foreach $anick(keys %nicks) {
				next if normalize($anick) eq normalize($usnick);
				next if $anick =~ /^chat-\d+/;
				$kill = 1;
				Toc::debug_print("\tSO WE MEET AGAIN, $anick.", "nicks", 3);
				foreach $bnick(keys %{$nicks{$anick}}) {
					Toc::debug_print("\t\t$bnick was using $anick...", "nicks", 3);
					next ANICK if $kill == 0;
					if($nicks{$anick}{$bnick} == -1) {
						$kill = 0;
						Toc::debug_print("\t\t\tpermenantly.", "nicks", 3);
					} elsif (($currtime - $nicks{$anick}{$bnick}) < 3600) {
						$kill = 0;
						Toc::debug_print("\t\t\tsince " . $currtime - $nicks{$anick}{$bnick} . " seconds ago.", "nicks", 3);
					}
				}
				if($kill == 1) {
					delete $nicks{$anick};
					irc_send(":$prefix$anick QUIT :Waah, nobody wants me (reaped)\r\n");
					Toc::debug_print("\t$anick, HAVE A NICE AFTERLIFE. ($anick reaped)", "nicks", 1);
				} else {
					Toc::debug_print("\t$anick, YOU LIVE FOR NOW.", "nicks", 3);
				}
			}

			foreach $chattimer(keys %chattimer) {
				if(($currtime - $chattimer{$chattimer}) >= 60) {
					irc_send(":$usnick PART #aimchat-$chattimer\r\n");
				}
			}

			
			if($keepalive) {
				foreach $connection(keys %aim_connections) {
					if($aim_connections{$connection}{socket}) {
						if(sflap_keepalive($aim_connections{$connection}{socket}) == -1) {
							irc_send(irc_privmsg($usnick, $aim_connections{$connection}{nick}, "There was an error with your AOL Instant Messenger connection: $err"));
							do_signoff($aim_connections{$connection}{nick}, $aim_connections{$connection}{socket});
						} else {
							if($aim_connections{$connection}{report_idle} and not $aim_connections{$connection}{is_idle} and ($currtime - $aim_connections{$connection}{idletime}) >= 360) {
								if(set_idle($aim_connections{$connection}{socket}, $currtime - $aim_connections{$connection}{idletime}) == -1) {
									irc_send(irc_privmsg($usnick, $aim_connections{$connection}{nick}, "There was an error with your AOL Instant Messenger connection: $err"));
									do_signoff($aim_connections{$connection}{nick}, $aim_connections{$connection}{socket});
								} else {
									$aim_connections{$connection}{is_idle} = 1;
								}
							}
						}
					} else {
						irc_send(irc_privmsg($usnick, $aim_connections{$connection}{nick}, "There was an error with your AOL Instant Messenger connection: $err"));
						do_signoff($aim_connections{$connection}{nick}, undef);
					}
				}
				$keepalive = 0;
			} else {
				$keepalive = 1;
			}
		}
	}
}

sub noprefix($) {
	my $nick = shift;
	$nick =~ s/^$prefix//i;
	return normalize $nick;
}

sub haskeys($) {
	my $hashref = shift;
	return scalar keys %$hashref;
}

sub irc_subparms($;$$) {
	my($input, $user, $nick, $time) = @_;
	$time = time;
	$input =~ s/_TIME_/$time/g;
	$input =~ s/_USER_/$user/g;
	$input =~ s/_NICK_/$nick/g;
	return $input;
}

sub irc_privmsg($$$;$) {
	my($from, $to, $msg, $prefix, $line, $ret, $text, $temp) = @_;

	return unless $from and $to and $msg;

	$from = substr($from, 0, $ircservers{$servermode}{nicklen});
	if($from ne $usnick and not haskeys($nicks{noprefix($from)})) {
		irc_send(irc_newnick($from));
	}

	foreach $line(split(/[\r\n]+/, $msg)) {
		$text = "$prefix$line";
		while($text) {
			$temp = substr($text, 0, 498 - length $from - length $to, "");
			$ret .= ":$from PRIVMSG $to :$temp\r\n";
		}
	}
	return $ret or $msg;
}

sub irc_newnick {
	my($nick, $user, $string, $shortnick) = shift;
	$nick =~ tr/ //d;
	$user = $nick;
	$user =~ s/^$prefix//;

	Toc::debug_print("Shall we create $nick?", "nicks", 2);
	return if haskeys($nicks{noprefix $nick});
	$shortnick = substr($nick, 0, $ircservers{$servermode}{nicklen});
	$nicks{noprefix($shortnick)}{$usnick} = time;
	Toc::debug_print("\tCreating $nick (normalized " . normalize($nick) . ", shortnick $shortnick)", "nicks", 1);
	$longnicks{normalize($shortnick)} = $nick;
	$shortnicks{noprefix($nick)} = $shortnick;
	$string = irc_subparms($ircservers{$servermode}{nick}, $user, $shortnick);
	$string .= ":$shortnick MODE $shortnick +i\r\n";
	return $string;
}

sub process_irc_message {
	if(s/^:(\S+)(!\S+@\S+)?\s+//) {
		$nick = $1;
	} else {
		$nick = $themname;
	}
	my $nnick = normalize($nick);

	if($aim_connections{$nnick}) {
		$aim_connections{$nnick}{idletime} = time;
		if($aim_connections{$nnick}{is_idle}) {
			$aim_connections{$nnick}{is_idle} = 0;
			if(set_idle($aim_connections{$nnick}{socket}, 0) == -1) {
				irc_send(irc_privmsg($usnick, $nick, "There was an error with your AOL Instant Messenger connection: $err"));
				do_signoff($nnick, $aim_connections{$nnick}{socket});
			}
		}
	}

	if(/^ERROR +:(.+)/) {
		print STDERR "IRC server error: $1\n";
		exit 1;
	} elsif(/^KILL +(\S+)/i) {
		delete $nicks{noprefix $1};
	} elsif(/^VERSION/i) {
		irc_send("351 $nick aimirc-$VERSION. $us :aimirc\r\n");
	} elsif(/^JOIN +.?#aimchat-(\d+)/i or /^SJOIN +\d+ +#aimchat-(\d+) +\S+ +:(\S+)/i) {
		my $chat = $1;
		$nick = $2 if $2;
		$nnick = normalize($nick);

		if((not $chatinvites{$chat} and not $chattopics{$chat}) or ($chatinvites{$chat} and $nnick ne normalize($chatinvites{$chat}))) {
			irc_send(send_join($usnick, "#aimchat-$chat"));
			send_server_mode("#aimchat-$chat +isnto $usnick");
			irc_send(":$usnick KICK #aimchat-$chat $nick :This channel is reserved for aimirc usage.\r\n");
			$chattimer{$chat} = time;
		} elsif($aim_connections{$nnick}) {
			$chatjoined{$chat} = 1;
			if($chatinvites{$chat}) {
				chat_accept($aim_connections{$nnick}{socket}, $chat);
			} else {
				irc_send($chatqueue{$chat});
				delete $chatqueue{$chat};
			}
			irc_send(":$usnick MODE #aimchat-$chat +o $nnick\r\n");
		}
	} elsif(/^INVITE +(\S+) +:?#aimchat-(\d+)/i) {
		my $recipient = noprefix($1);
		my $chat = $2;

		chat_invite($aim_connections{$nnick}{socket}, $chat, "Please come to $chattopics{$chat}.", $recipient) if $aim_connections{$nnick};
	} elsif(/^MODE +#aimchat-(\d+) +:?(.+)/i) {
		my $chat = $1;
		my $modes = $2;
		my ($mode, $parms, @matches, @modes, @params, @tparams, $params, $modestring, $modechar, $modeparm, $modetype, $status);

		irc_send("504 $nick :You cannot change modes in AIM chat channels.\r\n") if $aim_connections{$nnick};

		$modes =~ tr/+-/-+/;
		$modes =~ s/\s*\d+[\r\n]*$// unless $aim_connections{$nnick};
		#Toc::debug_print("Modes: $modes", "errors", 3);
		@matches = $modes =~ m/([-+][a-zA-Z]+)\s*/g or Toc::debug_print("Mode parse failed.", "errors", 3);
		foreach $modestring(@matches) {
			#Toc::debug_print("Mode parse suceeded: $modestring", "errors", 3);
			$modetype = substr($modestring, 0, 1, "");
			#Toc::debug_print("modetype is $modetype", "errors", 3);
			MODE: while($modechar = substr($modestring, 0, 1, "")) {
				#Toc::debug_print("Got modechar $modechar", "errors", 3);
				if($modechar =~ /[vbokl]/) { #Mode takes a parm
					$modes =~ s/(?:\s|\A)([^-+]\S*)(?:\s|\Z)/ / or next MODE;
					$modeparm = $1;
					#Toc::debug_print("Mode takes parm, parm is $modeparm", "errors", 3);
				} else {
					$modeparm = "";
				}
				if($modechar eq "o" and normalize($modeparm) eq normalize($usnick)) {
					if($modetype eq "+") {
						if($servermode eq "ts") {
							irc_send("MODE #aimchat-$chat +o $usnick\r\n");
						} else {
							irc_send(":$usnick MODE #aimchat-$chat +o $usnick\r\n");
						}
					}
				} elsif($modechar eq "o" and $aim_connections{normalize($modeparm)} and $modetype eq "-") {
					#Do nothing
				} elsif(($modechar eq "t" or $modechar eq "s" or $modechar eq "n" or $modechar eq "i") and $modetype eq "-") {
					#Do nothing
				} else {
					#Toc::debug_print("Adding to \@modes: (char => $modechar, type => $modetype, parm => $modeparm)", "errors", 3);
					push @modes, { char => $modechar, type => $modetype, parm => $modeparm };
				}
			}
		}
		#foreach $mode(@modes) {
		#	Toc::debug_print("Got mode: " . $mode->{type} . $mode->{char} . " " . $mode->{parm}, "irc", 3);
		#}

		$modestring = "";
		$parms = "";
		foreach $mode(sort { $a->{type} cmp $b->{type} } @modes) {
			if($mode->{type} eq "-" and not $status & 1) { #We have a -, modestring doesn't
				$modestring .= "-";
				$status |= 1;
			} elsif($mode->{type} eq "+" and not $status & 2) { #We have a +, modestring doesn't
				$modestring .= "+";
				$status |= 2;
			}
			$modestring .= $mode->{char};
			$parms .= " $mode->{parm}" if $mode->{parm};
		}

		$modestring .= $parms;

		#Toc::debug_print("Mode parse final: $modestring", "errors", 3);

		irc_send(":$usnick MODE #aimchat-$chat $modestring\r\n") if $modestring;
	} elsif(/^TOPIC +#aimchat-(\d+)/i) {
		irc_send("505 $nick :Cannot change topic in AIM chat channels.\r\n");
		irc_send("TOPIC #aimchat-$chat :$chattopics{$chat}\r\n");
	} elsif(/^KICK +#aimchat-(\d+) +(\S+)/i) {
		irc_send("503 $nick :Cannot kick users from AIM chat channels.\r\n");
		irc_send(send_join($2, "#aimchat-$1"));
		if(normalize($2) eq normalize($usnick)) {
			if($servernmode eq "ts") {
				irc_send("MODE #aimchat-$1 +o $usnick\r\n");
			} else {
				irc_send(":$usnick MODE #aimchat-$1 +o $usnick\r\n");
			}
		}
	} elsif(/^PART +#aimchat-(\d+)/i) {
		Toc::debug_print("$nick left aimchat $1 ($chattopics{$1}).", "chat", 1);
		if($aim_connections{$nnick} and $chattopics{$1}) {
			chat_leave($aim_connections{$nnick}{socket}, $1) if $aim_connections{$nnick};
			irc_send(":$usnick PART #aimchat-$1\r\n");
			foreach $who(keys %{$chats{$1}}) {
				delete $chats{$1}{$who};
				irc_send(":$prefix$who PART #aimchat-$1\r\n");
			}
			delete $chattopics{$1};
			delete $chatjoined{$1};
		}
	} elsif(/^PRIVMSG +$usnick +:?(.+)/i) { #$1 sent $2 to $usnick
		$msg = $1;
		$cmd = undef; $extra = undef; $param = undef;
		$msg =~ /(\S+) (\S+)( ?.*)/ or $cmd = $msg;
		$cmd = $1 unless $cmd; $param = $2 if $2; $extra = substr($3, 1) || "" if $3;
		$cmd ||= $msg; #For cmds w/o param
		#warn "Cmd: $cmd\nParam: $param: Extra: $extra\n\n";
		$nick = lc($nick);
		unless($aim_connections{$nnick} or ($cmd eq "signon") or ($cmd eq "help")) {
			irc_send(irc_privmsg($usnick, $nick, "You must use the signon command to sign on to AOL Instant Messenger before using this service."));
		} elsif($cmd eq "signon") {
			irc_send(irc_privmsg($usnick, $nick, "Usage: signon screenname password")) unless $param and $extra;
			if($aim_connections{$nnick} and $aim_connections{$nnick}{aimnick}) {
				irc_send(irc_privmsg($usnick, $nick, "You are already signed onto AOL instant messenger as $aim_connections{$nnick}{aimnick} - please sign off first if you wish to sign on under a different screename, or use a different IRC connection."));
			} else {
				local @temp = ($param, $extra, $usnick, $nick);
				do_signon(@temp);
			}
		} elsif ($cmd eq "buddylist") {
			my(%groups, $buddy, $group);
			%temp = deref(get_config($aim_connections{$nnick}{aimnick}));
			foreach $buddy(sort keys %{$temp{Buddies}}) {
				push @{$groups{$temp{Buddies}{$buddy}{group}}}, $buddy;
			}
			foreach $group(sort keys %groups) {
				foreach $buddy(sort @{$groups{$group}}) {
					irc_send(irc_privmsg($usnick, $nick, "$buddy ($group)"));
				}
			}
		} elsif ($cmd eq "onbuddies") {
			my(%groups, $buddy, $group);
			%temp = deref(get_config($aim_connections{$nnick}{aimnick}));
			foreach $buddy(sort keys %{$temp{Buddies}}) {
				push @{$groups{$temp{Buddies}{$buddy}{group}}}, $buddy if $temp{Buddies}{$buddy}{online};
			}
			foreach $group(sort keys %groups) {
				foreach $buddy(sort @{$groups{$group}}) {
					irc_send(irc_privmsg($usnick, $nick, "$buddy ($group)"));
				}
			}
		} elsif ($cmd eq "permitlist") {
			%temp = deref(get_config($aim_connections{$nnick}{aimnick}));
			irc_send(irc_privmsg($usnick, $nick, join(" ", sort keys(%{$temp{permit}}))));
		} elsif ($cmd eq "denylist") {
			%temp = deref(get_config($aim_connections{$nnick}{aimnick}));
			irc_send(irc_privmsg($usnick, $nick, join(" ", sort keys(%{$temp{deny}}))));
		} elsif ($cmd eq "signoff") {
			do_signoff($nnick, $aim_connections{$nnick}{socket}) if $aim_connections{$nnick};
		} elsif ($cmd eq "buddyinfo") {
			irc_send(irc_privmsg($usnick, $nick, "Usage: buddyinfo screenname")) unless $param;
			%temp = deref(get_config($aim_connections{$nnick}{aimnick}));
			$param = lc($param);
			$group = $temp{Buddies}{$param}{group};
			if($temp{Buddies}{$param}) {
				local $^W = 0;
				$msg = ":$usnick PRIVMSG $nick :";
				$msg .= "Group: $group\t" if $group and $group ne "Buddies";
				$msg .= "Signon time: " . localtime($temp{Buddies}{$param}{signon}) . "\tIdle time: $temp{Buddies}{$param}{idle} minutes\tUser class: ";
				$msg .= parseclass($temp{Buddies}{$param}{class}) . "\r\n";
				irc_send($msg);
			} else {
				irc_send(irc_privmsg($usnick, $nick,  "That persion is either not on your buddy list or not signed on."));
			}
		} elsif ($cmd eq "add_buddy") {
			irc_send(irc_privmsg($usnick, $nick, "Usage: add_buddy screenname [group]")) unless $param;
			$param = lc($param);
			$group = $extra || "Buddies";
			add_buddy($aim_connections{$nnick}{socket}, $param, $group);
		} elsif ($cmd eq "remove_buddy") {
			irc_send(irc_privmsg($usnick, $nick, "Usage: remove_buddy screenname")) unless $param;
			$param = lc($param);
			remove_buddy($aim_connections{$nnick}{socket}, $param);
			irc_send(irc_privmsg($usnick, $nick, "$param has departed"));
		} elsif ($cmd eq "evil" or $cmd eq "warn") {
			irc_send(irc_privmsg($usnick, $nick, "Usage: $cmd screenname [anon]")) unless $param;
			$param = lc($param);
			if($extra ne "anon") {
				$extra = 0;
			} else {
				$extra = 1;
			}
			evil($aim_connections{$nnick}{socket}, $param, $extra);
		} elsif ($cmd eq "add_permit") {
			irc_send(irc_privmsg($usnick, $nick, "Usage: add_permit screenname")) unless $param;
			$param = lc($param);
			add_permit($aim_connections{$nnick}{socket}, $param);
		} elsif ($cmd eq "add_deny") {
			irc_send(irc_privmsg($usnick, $nick, "Usage: add_deny screenname")) unless $param;
			$param = lc($param);
			add_deny($aim_connections{$nnick}{socket}, $param);
		} elsif ($cmd eq "remove_deny") {
			irc_send(irc_privmsg($usnick, $nick, "Usage: remove_deny screenname")) unless $param;
			$param = lc($param);
			remove_deny($aim_connections{$nnick}{socket}, $param);
		} elsif ($cmd eq "remove_permit") {
			irc_send(irc_privmsg($usnick, $nick, "Usage: remove_permit screenname")) unless $param;
			$param = lc($param);
			remove_permit($aim_connections{$nnick}{socket}, $param);
		} elsif ($cmd eq "join") {
			irc_send(irc_privmsg($usnick, $nick, "Usage: join chat_id OR join chat_name")) unless $param;
			$extra ? chat_join($aim_connections{$nnick}{socket}, "$param $extra") : chat_join($aim_connections{$nnick}{socket}, $param);
		} elsif ($cmd eq "get_permit_mode") {
			irc_send(irc_privmsg($usnick, $nick, $aim_connections{$nnick}{permtype}));
		} elsif ($cmd eq "set_permit_mode") {
			irc_send(irc_privmsg($usnick, $nick, "Usage: set_permit_mode newmode")) unless $param;
			$aim_connections{$nnick}{permtype} = $param;
			permtype($aim_connections{$nnick}{socket}, $param);
		} elsif ($cmd eq "list_permit_modes") {
			irc_send(irc_privmsg($usnick, $nick, "1=Permit All, 2=Deny All, 3=Permit if and only if on permitlist, 4=Deny if and only if on denylist"));
		} elsif ($cmd eq "whisper") {
			$extra =~ /(\S+) (.*)/;
			irc_send(irc_privmsg($usnick, $nick, "Usage: whisper chat_id screenname text")) unless $param and $1 and $2;
			chat_whisper($aim_connections{$nnick}{socket}, $param, $1, $2);
		} elsif ($cmd eq "chat_evil" or $cmd eq "chat_warn") {
			$extra =~ /(\S+) ?(.*)/;
			irc_send(irc_privmsg($usnick, $nick, "Usage: $cmd chat_id screenname [anon]")) unless $param and $extra;
			$foo = undef;
			$foo = "norm" if $2 ne "anon";
			$foo ne "norm" ? $foo = 1 : $foo = 0;
			chat_evil($aim_connections{$nnick}{socket}, $param, $1, $foo);
		} elsif ($cmd eq "info" or $cmd eq "get_info") {
			$param = lc($param);
			irc_send(irc_privmsg($usnick, $nick, "Usage: info screenname")) unless $param;
			get_info($aim_connections{$nnick}{socket}, $param);
		} elsif ($cmd eq "set_info") {
			my $text;
			irc_send(irc_privmsg($usnick, $nick, "Usage: set_info info")) unless $param;
			$extra ? ($text = "$param $extra") : ($text = $param);
			set_info($aim_connections{$nnick}{socket}, $text);
		} elsif ($cmd eq "get_dir") {
			irc_send(irc_privmsg($usnick, $nick, "Usage: get_dir screenname")) unless $param;
			get_directory($aim_connections{$nnick}{socket}, $param);
		} elsif ($cmd eq "set_dir") {
			$param = "$param $extra" if $extra;
			if($param and $param ne "set_dir") {
				@temp = split(/:/, $param);
					%temp = (
					first_name => shift @temp,
					middle_name => shift @temp,
					last_name => shift @temp,
					maiden_name => shift @temp,
					city => shift @temp,
					state => shift @temp,
					country => shift @temp,
					allow_web_searches => shift @temp
				);
				set_directory($aim_connections{$nnick}{socket}, %temp);
			} else {
				irc_send(irc_privmsg($usnick, $nick, "first name:middle name:last name:maiden name:city:state:country:websearch.  Don't put any colons in any of these.  If you put anything in the websearch field, people can find your directory info using web searches."));
			}
		} elsif ($cmd eq "dir_search") {
			$param = "$param $extra" if $extra;
			if($param and $param ne "dir_search") {
				@temp = split(/:/, $param);
				%temp = (
					first_name => shift @temp,
					middle_name => shift @temp,
					last_name => shift @temp,
					maiden_name => shift @temp,
					city => shift @temp,
					state => shift @temp,
					country => shift @temp,
					allow_web_searches => shift @temp
				);
				directory_search($aim_connections{$nnick}{socket}, %temp);
			} else {
				irc_send(irc_privmsg($usnick, $nick, "first name:middle name:last name:maiden name:city:state:country:websearch.  Don't put any colons in any of these.  If you put anything in the websearch field, people can find your directory info using web searches."));
			}
		} elsif ($cmd eq "add") {
			irc_send(irc_privmsg($usnick, $nick, "Usage: add screenname")) unless $param;
			unless($nicks{noprefix $param}) {
				irc_send(irc_newnick($prefix . normalize $param));
			}
			truncwarn($nick, $param);
			$nicks{noprefix $param}{$nnick} = time;
		} elsif ($cmd eq "sendidle") {
			unless($param == 0 or $param == 1) {
				irc_send(irc_privmsg($usnick, $nick, "Usage: sendidle (0|1)"));
			} else {
				$aim_connections{$nnick}{report_idle} = $param;
			}
		} elsif ($cmd eq "help") {
			$foo = ":$usnick PRIVMSG $nick";
			if($param eq "basics") {
				irc_send("$foo :help - Show this screen.\r\n", 1);
				irc_send("$foo :signon nick pass - Sign on to AOL Instant Messenger (AIM).  You must do this before any of the other commands.\r\n", 1);
				irc_send("$foo :signoff - Sign off of AIM\.r\n", 1);
				irc_send("$foo :add nick - Create an IRC nickname for nick.  Use this to talk to someone who's not on your buddylist.\r\n", 1);
				irc_send("$foo :get_permit_mode - See your current permit mode.\r\n", 1);
				irc_send("$foo :set_permit_mode newmode - Set your permit mode.\r\n", 1);
				irc_send("$foo :list_permit_modes - List the valid permit modes and their definitions.\r\n", 1);
			} elsif($param eq "buddies") {
				irc_send("$foo :add_permit nick - Add nick to your permit list, removing from deny list.\r\n", 1);
				irc_send("$foo :add_deny nick - Add nick to your deny list, removing from permit list.\r\n", 1);
				irc_send("$foo :buddyinfo name - Get signon time, idle time, evil level, and user class for a buddy.\r\n", 1);
				irc_send("$foo :add_buddy nick [group] - Add nick to your buddy list.  If you give a group, buddy will be added to that group.\r\n", 1);
				irc_send("$foo :remove_buddy nick - Remove nick from your buddy list.\r\n", 1);
				irc_send("$foo :evil nick [anon] (or warn nick [anon]) - Warn nick, optionally anonymously.\r\n", 1);
				irc_send("$foo :remove_permit nick - Remove nick from permit list.\r\n", 1);
				irc_send("$foo :remove_deny nick - Remove nick from deny list.\r\n", 1);
				irc_send("$foo :onbuddies - List buddies who are currently signed on (and who don't have you on block.)\r\n", 1);
				irc_send("$foo :buddylist - List everyone on your buddylist.\r\n", 1);
				irc_send("$foo :permitlist - See who is on your permit list.\r\n", 1);
				irc_send("$foo :denylist - See who is on your deny list.\r\n", 1);
			} elsif($param eq "chat") {
				irc_send("$foo :join topic - Create and join a new chatroom with topic set to topic.\r\n", 1);
				irc_send("$foo :whisper chat_id user message - Whisper to user in chat chat_id.\r\n", 1);
				irc_send("$foo :chat_evil chat_id nick [anon] (or chat_warn chat_id nick [anon]) - Warn nick inside chat_id, optionally anonymously.\r\n", 1);
			} elsif($param eq "misc") {
				irc_send("$foo :get_info nick - Get info for nick.\r\n", 1);
				irc_send("$foo :set_info new info - Set your info.\r\n", 1);
				irc_send("$foo :get_dir nick - Get directory info for nick.\r\n", 1);
				irc_send("$foo :set_dir [info] - Without info, gives you the syntax that info must be in.  With info, sets your directory info.\r\n", 1);
				irc_send("$foo :dir_search [info] - Without info, gets the syntax that info must be in (the same as that of set_dir).  With info, searches the AOL Instant Messenger directory.\r\n", 1);
				irc_send("$foo :sendidle (0|1) - Send the TOC server your idle information?\r\n", 1);
			} elsif($param eq "debug") {
				if($debug) {
					irc_send("$foo :restart - Restart aimirc.  This will close the IRC connection and all AIM connections and launch a new aimirc process.\r\n", 1);
					irc_send("$foo :newnick nick - Create a new nickname on irc.\r\n", 1);
					irc_send("$foo :setlevel debug_channel level - Set debugging channel debug_channel to level (higher is more verbose, 1 to disable).  The special channel \"all\" will set the level of all channels at once.\r\n", 1);
					irc_send("$foo :showlevels - List all debugging channels and their levels.\r\n", 1);
					irc_send("$foo :rehash - Reload /etc/aimirc.conf and $home/.aimirc .\r\n", 1);
					irc_send("$foo :reload - Evaluates $0.  This should let you make almost any change to Toc.pm or aimirc without having to do a full restart.\r\n", 1);
					irc_send("$foo :raw who text - Send a raw IRC or AIM command (AIM commands are SFLAP-encoded but not quoted.) If who is irc, it will be sent as an IRC command.  If who is the IRC nickname or AIM nickname of someone connected to this aimirc server, text will be sent over that AIM connection.\r\n", 1);
					irc_send("$foo :inject text - Act as though we got text from the IRC server.\r\n", 1);
					irc_send("$foo :eval text - Evaluate text as Perl code.  All exceptions will be trapped and displayed.\r\n", 1);
				} else {
					irc_send("$foo :Debugging support is not enabled.  Edit /etc/aimirc.conf or $home/.aimirc and send SIGHUP to PID $$.\r\n", 1);
				}
			} else {
				irc_send("$foo :aimirc $version, (c)2000 Matthew Sachs.\r\n", 1);
				irc_send("$foo :aimirc homepage: http://www.zevils.com/linux/aimirc/\r\n", 1);
				irc_send("$foo :This program is licensed under Version 2 the GNU Public License.\r\n", 1);
				irc_send("$foo :A copy of the license is available at http://www.gnu.org/copyleft/gpl.txt\r\n", 1);
				irc_send("$foo :To see the commands available for a specific topic, use the command help topic.  The following topics are available:\r\n", 1);
				irc_send("$foo :basics buddies chat misc\r\n", 1);
				irc_send("$foo :NOTE: Remove all spaces from screennames (also referred to as nicknames or nicks) before using in any AIMIRC command or operation.  nick is the AIM nick, not the IRC one created by prepending $prefix.\r\n", 1);
				irc_send("$foo :AIM stands for AOL Instant Messenger, which is a trademark of America Online, Inc.\r\n", 1);
				irc_send("$foo :To send an IM to someone whose screenname is SomeDude, send an IRC message to ${prefix}SomeDude.\r\n", 1);
				irc_send("$foo :That person must be on your buddylist, have sent you an IM recentely, or be added to IRC via the add command.\r\n", 1);
			}
		} elsif($cmd eq "webpage") {
			irc_send(irc_privmsg($usnick, $nnick, html2txt(get($param), $nnick)));
		} else {
			irc_send(irc_privmsg($usnick, $nick, "Unknown command - /msg $usnick help for help."));
		}
	} elsif(/^PRIVMSG +(\S+) +:?(.+)/i) { #$1 sent $3 to $2 (where $2 ne $usnick)
		$target = normalize(aimnick($longnicks{normalize($1)})); $msg = $2;
		$recipient = normalize($1);

		if($recipient eq "#aimirc-debug" and $debug) {
			$msg =~ s/^(aimserv)\S*\s+//;
			if($msg eq "restart" and $1) {
				phoenix;
			} elsif($msg =~ /^newnick (.+)/ and $1) {
				irc_send(irc_newnick($1));
			} elsif($msg =~ /^setlevel (\S+) (\S+)/) {
				if($1 eq "all") {
					foreach $level(keys %debug) { $debug{$level} = $2; }
				} else {
					$debug{$1} = $2;
				}
			} elsif($msg =~ /^rehash/) {
				&rehash;
			} elsif($msg =~ /^reload/) {
				&reload;
			} elsif($msg =~ /^showlevels/) {
				foreach $level(keys %debug) { irc_send(irc_privmsg($usnick, "#aimirc-debug", "$level: $debug{$level}")); }
			} elsif($msg =~ /^inject (.+)/ and $1) {
				process_irc_message($1);
			} elsif($msg =~ /^raw (\S+) (.+)/ and $1 and $2) {
				if($1 eq "irc") {
					irc_send("$2\r\n");
				} elsif($aim_connections{$1}) {
					sflap_put($aim_connections{normalize($1)}{socket}, sflap_encode($2, 0, 1));
				} else {
					$success = 0;
					AIMNICK: foreach $nick(keys %aim_connections) {
						$nnick = normalize($nick);
						if(normalize($aim_connections{$nnick}{aimnick}) eq normalize($1)) {
							$success = 1;
							sflap_put($aim_connections{$nnick}{socket}, sflap_encode($2, 0, 1));
							last AIMNICK;
						}
					}
					irc_send(irc_privmsg($usnick, "#aimirc-debug", "Couldn't find that person.")) unless $success;
				}
			} elsif($msg =~ /^eval (.+)/ and $1) {
				eval $1;
				irc_send(irc_privmsg($usnick, "#aimirc-debug", $@, "EVAL: "));
			} else {
				irc_send(irc_privmsg($usnick, "#aimirc-debug", "Invalid debug command - /msg aimserv help debug for help)"));
			}
		} elsif ($recipient =~ /^#aimchat-(\d+)$/) {
			chat_send($aim_connections{$nnick}{socket}, $1, $msg) if $aim_connections{$nnick};
		} elsif ($recipient !~ /^#/) {
			if($aim_connections{$nnick}) {
				$target = $longnicks{normalize($target)};
				message($aim_connections{$nnick}{socket}, $target, $msg);
				$nicks{noprefix $target}{$nnick} = time if $nicks{noprefix $target}{$nnick} != -1;
			} else {
				irc_send(irc_privmsg($usnick, $nick, "You must be signed onto AOL Instant Messenger via aimirc to send messages to AIM users.  /msg AIMServ help for details."));
			}
		}
	} elsif(/^AWAY *(.*)/) {
		if($aim_connections{$nnick}) {
			if($1 =~ /:?(.*)/) {
				$aim_connections{$nnick}{away} = $1;
				set_away($aim_connections{$nnick}{socket}, $1);
			} else {
				delete $aim_connections{$nnick}{away};
				delete $aim_connections{$nnick}{away_buddies};
				set_away($aim_connections{$nnick}{socket});
			}
		}
	} elsif(/^NICK +(\S+)/) { #Nick change
		if($aim_connections{$nnick}) {
			$newnick = normalize($1);
			$aim_connections{$newnick} = $aim_connections{$nnick};
			$aim_connections{$newnick}{nick} = $newnick;
			delete $aim_connections{$nnick};
		}
	} elsif(/^QUIT/) {
		do_signoff($nnick, $aim_connections{$nnick}{socket}, 1);
	} elsif(/^PING/) {
		irc_send("PONG $us\r\n");
	}
}

sub process_aim_message {
	my ($msg) = shift;
	my($cmd, $val, $inick, $ar);
	my($nnick) = normalize($connection->{nick});

	#warn "AIM got $msg for $connection->{nick}\n";
	$msg =~ /^([^:]+):(.+)/;
	$cmd = $1; $val = $2;
	if($cmd eq "ERROR") {
		$val =~ /([^:]+):?(.*)/;
		Toc::debug_print("Error $1: " . aim_strerror($1, $2), "errors", 1);
		irc_send(irc_privmsg($usnick, $connection->{nick}, "Error $1: " . aim_strerror($1, $2)));
	} elsif($cmd eq "CONFIG") {
		update_config($connection->{socket}, $msg);
	} elsif($cmd eq "IM_IN") {
		my $nick;
		$val =~ /([^:]+):(.):(.*)/;
		my $autoflag = $2;
		my $message = $3;
		$inick = $1; $inick =~ tr/ //d;
		$nnick = lc($inick);

		unless($nicks{noprefix $nnick}) {
			irc_send(irc_newnick($prefix . $inick));
		}
		truncwarn($connection->{nick}, $inick) unless $nicks{$nnick}{normalize $connection->{nick}};

		($autoflag eq "T") ? ($ar = "[automatic response] ") : ($ar = "");
		@lines = html2txt($message, $nick);
		irc_send(irc_privmsg($prefix . $inick, $connection->{nick}, $ar . $lines[0]));
		shift @lines;
		foreach $line(@lines) {
			irc_send(irc_privmsg($prefix . $inick, $connection->{nick}, "[continued]\t\t$line"));
		}

		if(($ar eq "") and $connection->{away} and (time - $connection->{away_buddies}{$nnick} > $time)) {
			my $tmp;
			my %config = deref(get_config($connection->{aimnick}));
			my $class = $config{Buddies}{$nnick}{class};
			if(substr($class, 0, 1) eq "A") {
				$tmp = "[automated reply] " . $connection->{away};
			} else {
				$tmp = $connection->{away};
			}
			message($connection->{socket}, $nnick, $tmp, 1);
		}
		$connection->{away_buddies}{$nnick} = time;
		$nicks{noprefix $nnick}{$connection->{nick}} = time if $nicks{noprefix $nnick}{$connection->{nick}} != -1;
	} elsif($cmd eq "UPDATE_BUDDY") {
		$val =~ /([^:]+):(.):([^:]+):([^:]+):([^:]+):(.+)/;
		$inick = $1; $inick =~ tr/ //d;
		$nnick = lc($inick);
		$ircnick = lc($prefix) . $nnick;
		Toc::debug_print("$connection->{nick} UPDATE_BUDDY: $val", "buddies", 1);
		if($2 eq "T") {
			%temp = deref(get_config($connection->{aimnick}));
			{
				local $^W = 0;
				irc_send(irc_privmsg($usnick, $connection->{nick}, "$inick has gone away")) if substr($temp{Buddies}{$nnick}{class}, 2, 1) ne "U" and substr($6, 2, 1) eq "U";
				irc_send(irc_privmsg($usnick, $connection->{nick}, "$inick is no longer away")) if substr($temp{Buddies}{$nnick}{class}, 2, 1) eq "U" and substr($6, 2, 1) ne "U";
			}

			irc_send(irc_newnick($prefix . $inick)) unless haskeys($nicks{noprefix $nnick});
			unless($temp{Buddies}{$nnick}{online}) {
				truncwarn($connection->{nick}, $inick);
				irc_send(irc_privmsg($usnick, $connection->{nick}, "$inick has arrived"));
			}
			update_buddy($connection->{aimnick}, $nnick, $6, $3, $4, $5, 1);
			$nicks{noprefix $nnick}{$connection->{nick}} = -1;
		} else {
			update_buddy($connection->{aimnick}, $nnick, $6, $3, $4, $5, 0);
			irc_send(irc_privmsg($usnick, $connection->{nick}, "$inick has departed"));
			delete $nicks{noprefix $nnick}{$connection->{nick}};
			unless(haskeys($nicks{noprefix $nnick})) {
				irc_send(":$prefix$inick QUIT :I signed off of AIM (UPDATE_BUDDY)\r\n");
				delete $nicks{noprefix $nnick};
			}
		}
	} elsif($cmd eq "EVILED") {
		$val =~ /([^:]+):(.*)/;
		$connection->{evil} = $1;
		irc_send(irc_privmsg($usnick, $connection->{nick}, ($2 || "Anonymous") . " has just evilled you.  Your new evil level is $1%."));
	} elsif($cmd eq "CHAT_JOIN") {
		$val =~ /([^:]+):(.*)/;
		$topic = $2;
		chomp $topic;

		$chattopics{$1} = $topic;
		irc_send(send_join($usnick, "#aimchat-$1"));
		send_server_mode("#aimchat-$1 +o $usnick");
		irc_send(":$usnick MODE #aimchat-$1 +sint\r\n");
		irc_send(":$usnick TOPIC #aimchat-$1 :$topic\r\n");
		irc_send(":$usnick INVITE $connection->{nick} :#aimchat-$1\r\n");
		irc_send(irc_privmsg($usnick, $connection->{nick}, "Join IRC channel #aimchat-$1 to join AIM chat $topic.")) unless $chatinvites{$1};
		delete $chatinvites{$1};
		$longnicks{"#aimchat-$1"} = "#aimchat-$1";
	} elsif($cmd eq "CHAT_IN") {
		my $nick;
		my ($sender, $nsender, $msg, $line, @lines);

		$val =~ /([^:]+):([^:]+):(.):(.*)/;

		$sender = $2;
		$sender =~ tr/ //d;
		$nsender = normalize($sender);

		if(normalize($connection->{aimnick}) ne $nsender) {
			$msg = html2txt($4, $nick);
			if(lc($3) eq "t") {
				Toc::debug_print("$sender whispered to $connection->{nick} in chat $1 ($2): $msg", "chat", 2);
				irc_send(irc_privmsg("$prefix$sender", $connection->{nick}, "(whispered in #aimchat-$1): $msg"));
			} else {
				Toc::debug_print("$sender said to $connection->{nick} in chat $1 ($2): $msg", "chat", 2);
				unless($chatjoined{$1}) {
					$chatqueue{$1} .= irc_privmsg("$prefix$sender", "#aimchat-$1", $msg);
				} else {
					irc_send(irc_privmsg("$prefix$sender", "#aimchat-$1", $msg));
				}
			}
		}
	} elsif($cmd eq "CHAT_UPDATE_BUDDY") {
		my($who, @who);

		$val =~ /([^:]+):(.):(.+)/;
		$who = $3;
		$who =~ tr/ //d;

		@who = split(/:/, $who);
		if(lc($2) eq "t") {
			foreach $who(@who) {
				next if normalize($who) eq normalize($connection->{aimnick});
				$chats{$1}{$who} = 1;
				irc_send(send_join("$prefix$who", "#aimchat-$1"));

				$nicks{normalize($who)}{chat-$1} = 1;
				irc_newnick($who);
				truncwarn($connection->{nick}, $who);
			}
		} else {
			foreach $who(@who) {
				next if normalize($who) eq normalize($connection->{aimnick});
				delete $chats{$1}{$who};
				irc_send(":" . substr("$prefix$who", 0, $ircservers{$servermode}{nicklen}) . " PART #aimchat-$1\r\n");
				delete $nicks{normalize($who)}{chat-$1};
			}
		}
	} elsif($cmd eq "CHAT_INVITE") {
		$val =~ /([^:]+):([^:]+):([^:]+):(.*)/;
		Toc::debug_print("$connection->{nick} has been invited to chat $1 ($4) [$2] by $3", "chat", 2);
		$chatinvites{$2} = $connection->{nick};
		irc_send(irc_privmsg($usnick, $connection->{nick}, "$3 has invited us to chatroom $1 for the following reason: " . html2txt($4) . ".  To accept, join #aimchat-$2"));
	} elsif($cmd eq "GOTO_URL") {
		$val =~ /[^:]+:(.+)/;
		my $html = get("http://toc-d01.blue.aol.com/$1");
		$html =~ s/<I>Legend:.*//m;
		Toc::debug_print($html, "html", 2);
		irc_send(irc_privmsg($usnick, $connection->{nick}, html2txt($html, $connection->{nick})));
	}
}

sub html2txt {
	my ($msg, $nick, $parsetree, @lines, $formatter) = @_;
	my($linkct, $link, $elem, $node) = 0;

	$parsetree = HTML::TreeBuilder->new;
	$parsetree->{_ignore_unknown} = 0;
	$parsetree->parse($msg);
	$parsetree->eof;

	$formatter = new HTML::FormatAIMIRC (leftmargin => 0, rightmargin => 4096);
	$formatter->{_original_html} = $msg; #We use this to determine whether to add a closing tag for "unknown tags"
	$msg = $formatter->format($parsetree);
	$parsetree->delete;
	return $msg;
}

sub aimnick {
	my($nick) = shift;
	$nick = lc($nick);
	$nick =~ s/^$prefix//i;
	return $nick;
}


sub Toc::debug_print($$$) {
	my($text, $type, $level) = @_;
	my($line, @lines);

	return unless $debug;
	return if defined($debug{$type}) and $level > $debug{$type};

	if($aimircdebug and $debug < 2) {
		@lines = split(/[\r\n]+/, $text);

		foreach $line(@lines) {
			irc_send(":$usnick PRIVMSG #aimirc-debug :($type, $level) $line\r\n", 1);
		}
	} else {
		chomp $text;
		print STDERR "$text\n";
	}
}

sub irc_send {
	lock $upstream;
	my ($msg, $nodbg) = @_;

	return unless $msg;

	Toc::debug_print("To IRC  : $msg", "irc", 2) unless $nodbg;
	undef $rv;
	$! = EAGAIN;
	while(!defined($rv) && $! == EAGAIN) {
		$rv = $upstream->syswrite($msg, length $msg);
		if($rv != length $msg) {
			substr($msg, 0, $rv) = "";
			undef $rv;
			$! = EAGAIN;
		} elsif(!defined($rv) && $! != EAGAIN) {
			die "Couldn't write to IRC: $!";
		}
	}
	return 1;
}

sub deref($) {
	my $href = shift;
	return %$href;
}

sub rehash {
	irc_send(irc_privmsg($usnick, "#aimirc-debug", "Rehashing..."));
	if(-r "/etc/aimirc.conf") {
		do "/etc/aimirc.conf";
		$@ =~ tr/\r//d;
		irc_send(irc_privmsg($usnick, "#aimirc-debug", $@, "EVAL: "));
		if($@) {
			irc_send(irc_privmsg($usnick, "#aimirc-debug", "Couldn't reload /etc/aimirc.conf - there were errors."));
		} else {
			irc_send(irc_privmsg($usnick, "#aimirc-debug", "Reloaded /etc/aimirc.conf"))
		}
	} else {
		irc_send(irc_privmsg($usnick, "#aimirc-debug", "Not loading /etc/aimirc.conf - couldn't read"));
	}
	if(-r "$home/.aimirc") {
		do "$home/.aimirc" if -r "$home/.aimirc";
		irc_send(irc_privmsg($usnick, "#aimirc-debug", $@, "EVAL: "));
		if($@) {
			irc_send(irc_privmsg($usnick, "#aimirc-debug", "Couldn't reload $home/.aimirc - there were errors."));
		} else {
			irc_send(irc_privmsg($usnick, "#aimirc-debug", "Reloaded $home/.aimirc"))
		}
	} else {
		irc_send(irc_privmsg($usnick, "#aimirc-debug", "Not loading $home/.aimirc - couldn't read"));
	}
	irc_send(irc_privmsg($usnick, "#aimirc-debug", "Rehash complete!"));
}

sub reload {
	irc_send(irc_privmsg($usnick, "#aimirc-debug", "Reloading $0..."));
	$reload = 1;
	local $SIG{__DIE__} = sub { $@ = shift; };
	do $0;
	irc_send(irc_privmsg($usnick, "#aimirc-debug", $@, "EVAL: "));
	if($@) {
		irc_send(irc_privmsg($usnick, "#aimirc-debug", "Couldn't reload $0 - there were errors."));
	} else {
		irc_send(irc_privmsg($usnick, "#aimirc-debug", "Reload complete!"));
	}
}

sub dispver {
	print "aimirc: IRC <-> AOL Instant Messenger gateway.\n";
	print "AOL Instant Messenger, AOL, and America Online are trademarks of America Online, Inc.\n";
	print "Version: $VERSION\n";
	print "Use $0 --help for command-line options.\n";
	print "Use $0 --license to see the license (GPL v2)\n";
	exit 0;
}

sub license { print $license; exit 0; }

sub help {
	print <<EOF
aimirc - IRC <-> AOL Instant Messenger gateway
AOL Instant Messenger, AOL, and America Online are trademarks of America Online, Inc.
Version $VERSION

Usage: $0 [--version] [--license] [--help] [--config conffile] [--config conffile] ...

You can use either the short or long forms with one or two dashes in
whatever combination you want.  However, you can't combine options as in
$0 -VC.

	--version, -V:			Display version information and exit

	--license:			Display license information and exit

	--help, -h:			Print this message and exit

	--config, -C:			Specify configuration files to use.
					This option overrides the default
					configuration file locations.
					You may specify this option multiple
					times to use multiple configuration
					files.

This is also an option for every directive in the configuration file.
The options have the same names as the directives, but prefix them with
two dashes (--) instead of the Perl variable type identifies (\$\@\%).

See the included README file for more information.
EOF
;
	exit 0;
}


sub do_signon {
	my($tparam, $textra, $tusnick, $tnick, $nparam, %temp, @ret, $flags, $nnick) = @_;

	$nparam = normalize($tparam);
	$nnick = normalize($tnick);

	if($verbose_signon) {
		@ret = signon $nparam, $textra, \&socksub, sub { irc_send(irc_privmsg($tusnick, $tnick, $_[0])) };
	} else {
		@ret = signon $nparam, $textra, \&socksub;
	}
	if($ret[0] == 0) {
		$aim_connections{$nnick}{nick} = $nnick;
		$aim_connections{$nnick}{aimnick} = $nparam;
		$aim_connections{$nnick}{socket} = $ret[1];
		$aim_connections{$nnick}{permtype} = $ret[2]->{permtype};
		$aim_connections{$nnick}{report_idle} = $sendidle;
		$aim_connections{$nnick}{idletime} = time;
		$aim_connections{$nnick}{is_idle} = 0;
		%temp = %{$ret[2]};

		irc_send(irc_privmsg($tusnick, $nnick, "You are now connected to AOL Instant Messenger."));
		unless($nicks{$nparam}) {
			irc_send(irc_newnick($prefix . $tparam));
		}
		$nicks{$nparam}{$nnick} = -1;
	} else {
		irc_send(irc_privmsg($tusnick, $nnick, $err));
	}
}

sub do_signoff {
	my ($nick, $connection, $already_off, $xnick) = @_;

	foreach $xnick(keys %nicks) {
		delete $nicks{$xnick}{$nick};
		irc_send(":$xnick QUIT :I signed off of AIM (do_signoff)\r\n") unless haskeys($nicks{$xnick});
	}

	if(UNIVERSAL::isa($connection, "IO::Socket::INET")) {
		delete $aim_connections{$connection->fileno};
		signoff($connection);
	}
	if($aim_connections{$nick}) {
		irc_send(irc_privmsg($usnick, $nick, "You have been signed off of AOL Instant Messenger.")) unless $already_off;
		delete $aim_connections{$nick};
	}
}

sub socksub {
	if($ssl) {
		SSLv3->new(
			PeerAddr => $tocserver,
			PeerPort => $tocport,
			SSL_verify_mode => 0x00,
			Timeout => 60,
		);
	} else {
		IO::Socket::INET->new(
			PeerAddr => $tocserver,
			PeerPort => $tocport,
			Timeout => 60,
		);
	}
}

sub send_server_mode($) {
	my $mode = shift;

	$mode = "MODE $mode";
	$mode .= " " . time if $servermode ne "ts";
	$mode .= "\r\n";
	irc_send($mode);
}

sub send_join($$) {
	my($user, $channel, $ret) = @_;

	irc_newnick($user);
	$user = substr($user, 0, $ircservers{$servermode}{nicklen});

	if($servermode eq "ts") {
		$user = "\@$user" if normalize($user) eq normalize($usnick);
		$ret = "SJOIN " . time . " $channel + :$user\r\n";
	} else {
		$ret = ":$user JOIN $channel\r\n";
	}

	return $ret;
}

sub irc_recv() {
	$noblock = $_[0];

	undef $rv;
	$! = EAGAIN;

	while(not $getbuff[0] and $! == EAGAIN and !defined($rv)) {
		$buff = ' ' x 512;
		$rv = $upstream->sysread($buff, 512);
		die "Couldn't read from IRC: $!" if !defined($rv) && $! != EAGAIN;
		if($! != EAGAIN) {
			#print STDERR "Reading from IRC...\n";
			if($incbuff) {
				$buff = "$incbuff$buff";
				undef $incbuff;
			}
			unless($buff =~ /\n$/) {
				$incbuf = substr($buff, rindex($buff, "\n") + 1, length $buff, "");
				#print STDERR "incbuf is $incbuff\n";
			}
			push @getbuff, split(/[\r\n]+/, $buff);
			#print STDERR "Getbuff is " . join("\n", @getbuff);
			#print STDERR "\n";
		}
		last if $noblock;
	}
	$ret = shift @getbuff;
	Toc::debug_print("From IRC: $ret", "irc", 2) if $ret;
	#print STDERR "Returning $ret\n";

	return $ret;
}

sub truncwarn($$) {
	my($who, $what) = @_;

	Carp::cluck "truncwarn $who $what\n";

	irc_send(irc_privmsg($usnick, $who,
		"\02WARNING\02: Screenname $what has been truncated to IRC nickname " . $shortnicks{noprefix $what}))

		if noprefix($shortnicks{noprefix($what)}) ne normalize($what);
}

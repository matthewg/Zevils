#!/usr/bin/perl

#NNTB - Network News Transport for 'Blogs

use strict;
use warnings;
use vars qw($version @args %config %blogs $client_ip);
use NNTB::Common;

$version = "0.01";

sub BEGIN {
	require File::Basename;
	File::Basename->import;
	unshift @INC, dirname($0)."/lib";
}

sub do_log(@) { _log("NNTB: ", @_); }
sub _log(@) {
	return unless $config{loglevel} >= pop;
	print LOG scalar(localtime), " $$  ", @_, "\n";
}


sub dispver() {
	print "NNTB: Network News Transport for 'Blogs.\n";
	print "Version: $version\n";
	exit 0;
}

sub help() {  # If called with -h or --help
	# Get absolute path to $0
	my($dir, $file) = fileparse($0);
	chdir $dir;
	my $dirpath = cwd();
	my $path = File::Spec->catfile($dirpath, $file);

	print <<EOF;
NNTB: Network News Transport for 'Blogs, version $version

Written by Matthew Sachs <matthewg\@zevils.com>

Use -p to specify a port, -i if running from inetd, -v to show version
and exit, -h to get this message.  Default port is whatever nntp is listed
on in /etc/services (119).

Usage: $0 [-v] [-i] [-p port] [-c conffile] [-l loglevel]

You can use either the short or long forms with one or two dashes in
whatever combination you want.  However, you can't combine options, as in
$0 -ip 120

	-h,  --help:			Print this message and exit

	-v, --version:			Shows version and exits

	-i, --inetd:			Use if starting from inetd
					The line in /etc/inetd.conf used to
					start NNTB should look like: 

	nntp	stream	tcp	nowait	user	$path	nntb -i

					Starting from inetd means that perl
					must recompile nntb every time a
					client connects, which can be a large 
					slowdown.

	-p, --port port:		Listen on an alternate port instead of
					nntp.  Meaningless in inetd mode.

	-c, --conf conffile:		Use an alternate configuration file.
					This option may be specified multiple
					times.	By default, NNTB will look first
					in /etc/nntb.conf and then in ~/.nntb .

	-d, --debug:			Don't fork and log to STDERR with the most
					verbose logging level.
EOF
	exit 0;
}

use Getopt::Long;
use Time::Local;
use Sys::Hostname;
use HTML::FormatText;
use HTML::Parse;
use IO::Handle;
use File::Basename;
use File::Spec;
use Cwd;

sub init() {
	%config = (
		debug => 0,
		loglevel => LOG_NOTICE,
		inetd => 0,
		port => (getservbyname("nntp", "tcp"))[2],
	);

	open(LOG, ">&STDERR");
	autoflush LOG 1;
}

sub loadconf() {
	#First we check to see what config files to use.
	#Then we use the config files.
	#Then we process command-line options.
	#We do it this way so that command-line options can override config files, and
	#  you can still specify config files on the command-line.

	@args = @ARGV; #Used for SIGHUP

	Getopt::Long::Configure("no_ignore_case");
	Getopt::Long::Configure("pass_through");

	my $home = (getpwuid($>))[7];
	my(@default_conffiles) = ("/etc/nntb.conf", File::Spec->catfile($home, ".nntb"));
	my @conffiles;

	my $okay = &GetOptions(
		"version|v" => \&dispver, 
		"help|h" => \&help,
		"config|c=s\@" => \@conffiles,
		"debug|d" => \$config{debug},
	);

	if(@ARGV) {  # We shouldn't have any arguments left over
		warn "Unknown options: ", join(" ", @ARGV), "\n";
		$okay = 0;
	}
	if(!$okay) {
		warn "Try $0 --help if you need help.\n";
		exit 1;
	}

	@conffiles = @default_conffiles unless @conffiles;


	#Okay, try loading the config files

	my $foundconfig = 0;

	foreach my $conffile(@conffiles) {
		my $confversion = 0;
		$conffile =~ s/~/$home/;
		do_log("Trying to read config file $conffile", LOG_INFO);

		if(-d $conffile) {
			warn "$conffile is a directory!\n";
		} elsif(-r $conffile) {
			do_log("Reading config file $conffile", LOG_INFO);
			$confversion = 0;
			do $conffile;
			die $@ if $@;
			if($confversion < 1) {
				warn "Not using config file $conffile - it is too old (\$confversion must be >= 1)\n";
				$foundconfig = -1 unless $foundconfig;
			} else {
				$foundconfig = 1;
			}
		} elsif(-e $conffile) {
			warn "Couldn't read config file $conffile\n";
		} else {
			do_log("$conffile does not exist", LOG_INFO);
		}
	}

	unless($foundconfig) {
		warn <<EOF;
We couldn't find a config file.
You must edit nntb.conf and copy it to either /etc/nntb.conf or
$home/.nntb .  If you have already done this, make sure the NNTB
user has permission to read it.  Or, perhaps you specified an
invalid config file with the --config (-c) command-line option.
EOF
		exit 1;
	}

	if($foundconfig == -1) {
		warn <<EOF;
Your configuration is too old.
Please copy the nntb.conf file distributed with NNTB to either
/etc/nntb.conf or $home/.nntb and modify it as needed for your site.
EOF
		exit 1;
	}

	#Now process additional command-line options

	Getopt::Long::Configure("no_pass_through");

	$okay = &GetOptions(
		"inetd|i" => \$config{inetd}, 
		"port|p=i" => \$config{port}, 
	);

	if(!$okay) {
		warn "Try $0 --help if you need help.\n";
		exit 1;
	}

	foreach my $blog (@{$config{blogs}}) {
		my $package = "NNTB::Weblog::$blog->{type}";
		eval "require $package";
		if(!$@) {
			do_log("Couldn't load $package: $@", LOG_ERROR);
			next;
		}

		# Figuring out the syntax for this was fun ;)
		my $method = $package . "->new";
		my $blog_obj = eval "$method(\%config)";
		if(!$blog_obj) {
			do_log("Couldn't create new $package object: $@", LOG_ERROR);
			exit 1;
		} else {
			if(!$blog_obj->root) {
				do_log("$package gave us empty root - not using", LOG_ERROR);
				exit 1;
			} elsif(exists($blogs{lc($blog_obj->root)})) {
				do_log("Duplicate root ", $obj->root, " for $package", LOG_ERROR);
				exit 1;
			} elsif(my(@dups) = grep {
				  index(lc($blog_obj->root), lc($_->root)) != -1 or
				  index(lc($_->root), lc($blog_obj->root)) != -1
				} values %blogs
			) {
				do_log("Root ", $obj->root, " is a substring of the following roots: ", (map { $_->root } @dups), LOG_ERROR);
				exit 1;
			} else {
				$blogs{lc($blog_obj->root)} = $blog_obj;
			}
		}
	}
}

sub main() {

	init();
	loadconf();

	if (!$config{inetd}) {  #We're not using inetd
		use Socket;
		use POSIX;

		if(!$config{debug}) {
			my $pid = fork;
			exit if $pid;
			die "Couldn't fork: $!" unless defined($pid);
	
			POSIX::setsid() or die "Can't start a new session: $!";
			sub signal_handler {
				close SERVER; 
				exit 1;
			}
			$SIG{INT} = $SIG{TERM} = $SIG{HUP} = \&signal_handler; #trap fatal sigs
		}

		#Code to restart on SIGHUP
		sub phoenix { 
			close CLIENT; close SERVER;	exec($0, @args);
		}
		$SIG{HUP} = \&phoenix;

		#Without this code, we get lots of fresh victims for the ever-growing army of the undead (in other words, zombies)
		sub REAPER {
			1 until (-1 == waitpid(-1, WNOHANG));
			$SIG{CHLD} = \&REAPER;
		}
		$SIG{CHLD} = \&REAPER;

		#Code to handle incoming connections
		socket(SERVER, PF_INET, SOCK_STREAM, getprotobyname('tcp'));

		setsockopt(SERVER, SOL_SOCKET, SO_REUSEADDR, 1);

		my $my_addr = sockaddr_in($config{port}, INADDR_ANY);
		bind(SERVER, $my_addr) or die "Couldn't bind: $!\n";

		listen(SERVER, SOMAXCONN) or die "Couldn't listen: $!\n";

		while(accept(CLIENT, SERVER)) {
			next if my $pid = fork; # parent
			die "fork: $!" unless defined $pid;
			# we are the world, we are the children
			close SERVER;

			got_client();

			exit;
		} continue { close CLIENT; }

		close SERVER;  #buh-bye
	} else { #inetd == 1
		*CLIENT = *STDIN; # 'cuz that's what inetd does
		got_client();
	}
}

sub nntp_put(@) {
	do_log("To NNTP  : ", @_, LOG_DEBUG);
	print @_, "\r\n";
}

# (group|ID) -> blog
sub findblog($) {
	my $group = lc(shift);

	$group =~ s/^<(.+)>/$1/;

	my($blog) = grep {
		my $pos = index($group, lc($_->root));
		$pos != -1 and # It is in the string...
		  $pos + length($_->root) == length($group); # At the end
	} values %blogs;
	return $blog;
}

sub got_client() {
	my($currmsg, $currgroup);

	(undef, $client_ip) = sockaddr_in(getpeername(CLIENT));
	$client_ip = inet_ntoa(gethotbyaddr($client_ip, AF_INET));

	select CLIENT;
	$| = 1; # Auto-flush the output.
	print "200 " . hostname() . " NNTB server $version ready\n";

	do_log("Got a client\n", LOG_INFO);
	map { $_->got_client() } values %blogs;

	GETLINE: while(<CLIENT>) {
		s/[\r\n]{1,2}$/;
		do_log("From NNTP: $_", LOG_DEBUG);
		my $text = $_;
		my @params = split;
		my $command = lc(shift @params);
		$_ = $command;

		my $blog;
		$blog = findblog($currgroup) if $currgroup;

		SWITCH: {
			if (/^article$/ || /^body$/ || /^head$/ || /^stat$/) {
				my ($msgnum, $msgid);

				if ($params[0] and $params[0] !~ /\<.+\>/) {
					if(!$currgroup) { #Client tried to use a message number while no group was selected
						nntp_put("412 Not in a newsgroup");
						last SWITCH;
					} else {
						$currmsg = $params[0];
						$msgid = $blog->num2id($group, $currmsg) if $blog;
						if(!$msgid) {
							nntp_put(ERR_NOARTICLE);
							next;
						}
					}
				} else {
					if(!($blog = findblog($msgid))) {
						nntp_put(ERR_NOARTICLE);
						next;
					}
					$msgnum = 0; # We can't map ID -> num - what 'bout crossposts?
				}

				do_log("Msg-ID is $msgid, number is $msgnum\n", LOG_DEBUG);

				my($response, $resptext);
				if($command eq "article") {
					($response, $resptext) = (220, "head and body follow");
				} elsif($command eq "head") {
					($response, $resptext) = (221, "head follows");
				} elsif($command eq "body") {
					($response, $resptext) = (222, "body follows");
				} elsif($command eq "stat") {
					($response, $resptext) = (223, "request text seperately");
					next;
				}

				my($result, $body, %headers) = $blog->article($command, $msgid);

				if($result) {
					nntp_put("$response $msgnum $msgid article retrieved - $resptext\n");
					if($command eq "head" or $command eq "article") {
						map { nntp_put("$_: $headers{$_}") } keys %headers;
						nntp_put("") if $command eq "article";
					}
					if($command eq "body" or $command eq "article") {
						$body =~ s/^\.$/../m;
						$body =~ s/(?!\r)\n/\r\n/g;
						nntp_put($body);
						nntp_put(".");
					}
				} else {
					nntp_put($blog->{errstr});
				}
				next;
			} elsif (/^group$/) {
				unless (@params == 1) {
					print "501 Syntax error - group groupname\n";
					last SWITCH;
				}
				my $group = shift @params;
				my $blog = findblog($group);
				if(!$blog or !$blog->is_group($group)) {
					nntp_put("411 no such group");
				} else {
					$currgroup = $group;
					my($first, $last, $num) = $blog->groupstats($group);
					nntp_put("211 $num $first $last $group group selected");
					do_log("Okay, current group is now $params[0]\n", LOG_DEBUG);
				}
				next;
			} elsif (/^help$/) {
				nntp_put("Legal commands");
				map { nntp_put($_); }
					qw(article head body stat group help ihave last),
					qw(next list newgroups newnews post quit slave),
					qw(mode date listgroup authinfo xover);
				next;
			} elsif (/^ihave$/) { #This command is only for inter-server post transfers
				nntp_put("435 article not wanted - do not send it");
				next;
			} elsif (/^last$/ || /^next$/) {
				if(!$currgroup) {
					nntp_put("412 no newsgroup selected");
				} elsif(!$currmsg) {
					nntp_put("420 no current article has been selected");
				} else {
					my $newmsg = ($params[0] eq "next") ? ($currmsg + 1) : ($currmsg - 1);
					my $msgid = $blog->num2id($currgroup, $newmsg);
					if(!$msgid) {
						if($params[0] eq "next") {
							nntp_put("421 no next article in this group");
						} else {
							nntp_put("422 no previous article in this group");
						}
					} else {
						nntp_put("223 $currmsg <$msgid> article retrieved - request text separately");
						$currmsg = $newmsg;
					}
				}
				next;
			} elsif (/^list$/) {
				if (lc($params[0]) eq "overview.fmt") {
					print "215 Order of fields in overview database.\n";
					print "Subject:\nFrom:\nDate:\nMessage-ID:\nReferences:\nBytes:\nLines:\nXref:full\n.\n";
				} elsif (lc($params[0]) eq "newsgroups") {
					print "215 Newsgroups follow\n";
					my @groups = getgroups("00000000000000");
					my $group;
					foreach $group (@groups) {
						$group =~ s/^([^ ]+).+/$1/;
						print "$group   A slashsite group\n";
					}
					print ".\n";
				} else {
					print "215 list of newsgroups follows\n";
					newgroups("00000000000000");
				}
				last SWITCH;
			} elsif (/^newgroups$/) {
				print "231 list of new newsgroups follows\n";
				newgroups(params2time(@params));
				last SWITCH;
			} elsif (/^newnews$/) {
				print "230 list of new articles by message-id follows\n";
				getarticles($1, params2time(@params));
				last SWITCH;
			} elsif (/^post$/) {
				my (@message);
				print "340 send article to be posted. End with <CR-LF>.<CR-LF>\n";
				GETHEAD: while (<CLIENT>) {
					last GETHEAD if ($_ eq ".\r\n");
					push @message, $_;
				}
				post(@message);
				last SWITCH;
			} elsif (/^quit$/) {
				print "205 closing connection - goodbye!\n";
				last GETLINE;
			} elsif (/^slave$/) {
				print "202 slave status noted\n";
				last SWITCH;
			} elsif (/^mode$/) {
				print "200 OK\n";
				last SWITCH;
			} elsif (/^date$/) {
				my @gmtime = gmtime(time); $gmtime[5] += 1900; $gmtime[4]++;
				my @time = reverse @gmtime[0..5];
				print "111 " . sprintf("%4u%2u%2u%2u%2u%2u", @time) . "\n";
				last SWITCH;
			} elsif (/^listgroup$/) {
				my $group = $params[0] || $currgroup;
				unless (isgroup($group)) {
					print "411 No such group $group\n";
					last SWITCH;
				}
				changegroup($group, "Article list follows");
				getarticles($group, "00000000000000");
				last SWITCH;
			} elsif (/^authinfo$/) {
				if (lc($params[0]) eq "pass" and !"user") {
					print "482 USER required\n";
				} elsif (lc($params[0]) eq "user") {
					#$user = $params[1];
					print "381 PASS required\n";
				} elsif (lc($params[0]) eq "pass") {
					#if ((sqlSelect("uid", "users", "nickname=" . $dbh->quote($user) ." and passwd=" . $dbh->quote($2)))[0]) {
						#do_log("Client is now authenticated as $user\n", LOG_INFO); 
						print "281 Ok\n";
					#} else {
						print "503 Authentication error\n";
						last GETLINE;
					#}
				}
			} elsif (/^xover$/) {
				xover($params[0]);
			} else {
				print "501 Command syntax error\n";
			}
			last SWITCH;
		}
	} #No more input from client
	return;
}

sub params2time(@) {
	my($date, $time, $gmt) = @_;

	my($year, $month, $day, $hour, $minute, $second);
	$year = substr($date, 0, 2);
	$month = substr($date, 2, 2);
	$day = substr($date, 4, 2);
	$hour = substr($time, 0, 2);
	$minute = substr($time, 2, 2);
	$second = substr($time, 4, 2);

	($second, $minute, $hour, $day, $month, $year) = localtime(timegm($second, $minute, $hour, $day, $month, $year)) if($gmt and $gmt eq "GMT");
	$year += 1900;
	return sprintf("%04d%02d%02d%02d%02d%02d", $year, $month, $day, $hour, $minute, $second);
}



main();


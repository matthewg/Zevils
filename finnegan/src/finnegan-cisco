#!/usr/bin/perl

use strict;
use warnings;
no warnings 'once';
use POSIX;
use DBI;

our $db_connected = 0;
our %kidmap = (); # PID -> log_id

sub log_debug($);
sub activate_wake($$);

sub load_settings {
	open(SETTINGS, "../etc/settings.inc") or die "Couldn't open settings: $!\n";
	my $settings = join("", <SETTINGS>);
	close SETTINGS;
	open(SETTINGS, "../etc/cisco-settings.inc") or die "Couldn't open Cisco settings: $!\n";
	$settings .= join("", <SETTINGS>);
	close SETTINGS;
	$settings =~ s/#__PHPONLY_START__.*?#__PHPONLY_END__//gs;
	eval $settings;
	die "Couldn't load settings: $@\n" if $@;
}
$SIG{HUP} = \&load_settings;

my $brancal_timestamp = 0;
load_settings;
log_debug("Finnegan starting");

# Daemonize
if(!$Finnegan::Config::testmode) {
	my $pid = fork;
	exit if $pid;
	die "Couldn't fork: $!" unless defined($pid);
	POSIX::setsid() or die "Can't start a new session: $!";
}

$SIG{CHLD} = sub { wait; };

our $dbh = DBI->connect(
	sprintf("DBI:mysql:database=%s;host=%s", $Finnegan::Config::db->{database}, $Finnegan::Config::db->{host}),
	$Finnegan::Config::db->{user}, $Finnegan::Config::db->{password}
);
die "Couldn't connect to database.\n" unless $dbh;
$db_connected = 1;

sub END { log_error("Finnegan going down!") if $db_connected; }

my $get_newwakes = $dbh->prepare("SELECT * FROM wakes WHERE ISNULL(next_trigger)");
my $get_wakes = $dbh->prepare("SELECT *, UNIX_TIMESTAMP(next_trigger) AS 'unix_trigger' FROM wakes WHERE next_trigger <= NOW() + INTERVAL 60 SECOND AND ((ISNULL(trigger_snooze) OR trigger_snooze < snooze_count) OR trigger_date != CURDATE()) ORDER BY unix_trigger");
my $delete_wake = $dbh->prepare("DELETE FROM wakes WHERE wake_id=?");
my $activate_wake = $dbh->prepare("UPDATE wakes SET trigger_date=CURDATE(), trigger_snooze=snooze_count WHERE wake_id=?");
my $update_wake = $dbh->prepare("UPDATE wakes SET snooze_count=0, trigger_snooze=NULL, trigger_date=NULL, next_trigger=CONCAT(CURDATE() + INTERVAL 1 DAY, ' ', time) WHERE wake_id=?");
my $snooze_wake = $dbh->prepare("UPDATE wakes SET snooze_count=snooze_count+1, next_trigger=NOW() + INTERVAL 9 MINUTE WHERE wake_id=?");
my $update_nexttime = $dbh->prepare("UPDATE wakes SET next_trigger=FROM_UNIXTIME(?) WHERE wake_id=?");
my $log_error = $dbh->prepare("INSERT INTO log_daemon (time, data) VALUES (NOW(), ?)");
my $log_wake_start = $dbh->prepare("INSERT INTO log_wake (wake_id, extension, event, start_time) VALUES (?, ?, 'activate', NOW())");
my $log_wake_end = $dbh->prepare("UPDATE log_wake SET end_time=NOW(), result=?, data=? WHERE log_id=?");
my $get_insertid = $dbh->prepare("SELECT LAST_INSERT_ID()");

my %daymap = ("Sun" => 1, "Mon" => 2, "Tue" => 3, "Wed" => 4, "Thu" => 5, "Fri" => 6, "Sat" => 7);
my @daymap_inv = ("", sort { $daymap{$a} <=> $daymap{$b} } keys %daymap);

sub log_wake_start($$) {
	my($wake_id, $extension) = @_;
	if($Finnegan::Config::testmode) {
		warn "$$: Starting wake $wake_id for extension $extension\n";
	}
	$log_wake_start->execute($wake_id, $extension);
        ($log_wake_id) = @{$dbh->selectcol_arrayref($get_insertid)};
	$log_wake_start->finish;
	return $log_wake_id;
}
sub log_wake_end($$$) {
	my($result, $data, $log_id) = @_;
	if($Finnegan::Config::testmode) {
		warn "$$: Ending wake, log $log_wake_id\n";
	}
	$log_wake_end->execute($result, $data, $log_id);
	$log_wake_end->finish;
}
sub log_debug($) {
	my $str = shift;
	if($Finnegan::Config::testmode) {
		warn "$$ - " . time() . ": $str\n";
	}
}
sub log_error($) {
	my $errstr = shift;
	if($Finnegan::Config::testmode) {
		warn "$$ - " . time() . ": $errstr\n";
	} else {
		$log_error->execute($errstr);
	}
}
sub db_error($$) {
	my $str = shift;
	my $sth = shift;
	my $errstr = "Database error: $str - " . $sth->errstr;
	log_error($errstr);
}

# -1. Reload Brandeis calendar data, if necessary.
# 0. Update next_trigger.  Note that we don't attempt to figure out the correct date for recurring wakes, we do that ad-hoc.
# 1. Get wakes
# 2. Check to see if we should call any now
# 3. If so, call them
# 4. Reap the TFTP directory
# 5. Sleep 10 seconds
while(1) {
	log_debug("Checking brancal time");
	my $bctime = (stat "../etc/brancal.inc")[9];
	if($bctime > $brancal_timestamp) {
		log_debug("Loading brancal");
		$brancal_timestamp = $bctime;
		my $ret = do "../etc/brancal.inc";
		if(!$ret) {
			my $reason = "";
			$reason = "Couldn't parse brancal.inc: $@" if $@;
			$reason = "Couldn't load brancal.inc: $!" unless defined($ret);
			$reason = "Couldn't run brancal.inc" unless $ret;
			log_error($reason);
		}

		# Make sure it gets included again next time
		delete $INC{"../etc/brancal.inc"};
		delete $INC{"brancal.inc"};
	}


	log_debug("Getting new wakes");
	my $newwakes = $get_newwakes->execute();
	if(!$newwakes) {
		db_error("Couldn't get new wakes", $get_newwakes);
	} else {
		while(my $row = $get_newwakes->fetchrow_hashref) {
			$row->{time} =~ /(\d+):(\d+)/;
			my @waketime = (0, $2, $1, 0, 0, 0);
			my $waketime;
			if($row->{date}) {
				my @dateparts = split(/-/, $row->{date});
				@waketime[3, 4, 5] = @dateparts[2, 1, 0];
				$waketime[4]--;
				$waketime[5] -= 1900;
				log_debug("mktime " . join(", ", @waketime));
				$waketime = mktime(@waketime);
			} else {
				my @currtime = localtime(time());
				@waketime[3, 4, 5] = @currtime[3, 4, 5];

				my $currsecs = $currtime[2]*60+$currtime[1];
				my $wakesecs = $waketime[2]*60+$waketime[1];

				$waketime = mktime(@waketime);
				$waketime += 60*60*24 if $currsecs > $wakesecs; # Not today - tomorrow
			}
			log_debug("Setting trigger_time on " . $row->{wake_id} . " to $waketime");

			if(!$update_nexttime->execute($waketime, $row->{wake_id})) {
				db_error("Couldn't update trigger_time", $update_nexttime);
			}
		}
		$get_newwakes->finish;
	}


	log_debug("Getting wakes");
	my $wakes = $get_wakes->execute();
	if(!$wakes) {
		db_error("Couldn't get wakes", $get_wakes);
		next;
	}

	my @rows;
	push @rows, $_ foreach $get_wakes->fetchrow_hashref;
	$get_wakes->finish;

	foreach my $row (@rows) {
		next unless $row;

		log_debug("Got " . $row->{wake_id});
		next if $row->{unix_trigger} > time();

		# If it's a non-snoozed recurring wait, we have to make sure that it should get tapped today
		if(!$row->{date} and !$row->{snooze_count}) {
			log_debug("Checking recurring wake weekday");
			my $go_today = 1;

			my($weekday, $hour, $date) = split(/:/, strftime("%w:%H:%Y-%m-%d", localtime(time())));
			my $yesterday_date = strftime("%Y-%m-%d", localtime(time() - 60*60*24));
			my @today = split(/-/, strftime("%d-%m-%Y", localtime(time())));
			my @tomorrow = split(/-/, strftime("%d-%m-%Y", localtime(time() + 60*60*24)));
			$weekday++; # Make Sunday 1, not 0
			my $yesterday = ($weekday - 1) % 8;

			if($row->{cal_type} eq "Brandeis") {
				$weekday = $Finnegan::Calendar::BRANDEIS_DAYS->{$date} if $Finnegan::Calendar::BRANDEIS_DAYS->{$date};
				$yesterday = $Finnegan::Calendar::BRANDEIS_DAYS->{$yesterday_date} if $Finnegan::Calendar::BRANDEIS_DAYS->{$yesterday_date};
			}

			my %wake_days = map { $daymap{$_} => 1 } split(/,/, $row->{weekdays});
			$row->{time} =~ /^(\d+):/;
			my $wake_hour = $1;

			# Should the wake be activated on this day of the week?
			# Or, if wake is for 11PM, and it's midnight, also check yesterday.
			log_debug("wake_days={".join(",", keys %wake_days)."}, weekday=$weekday");
			if($wake_days{$weekday}) {
				# Everything's groovy
				log_debug("Okay");
			} elsif($wake_hour == 23 and $hour == 0 and $wake_days{$yesterday}) {
				log_debug("Okay yesterday");
				$weekday = $yesterday;
				$date = $yesterday_date;
				@tomorrow = @today;
			} else {
				log_debug("Not today");
				$go_today = 0;
			}

			$go_today = 0 if $row->{cal_type} eq "Brandeis" and $Finnegan::Calendar::NO_CLASSES->{$date};
			$go_today = 0 if $row->{cal_type} eq "holidays" and $Finnegan::Calendar::HOLIDAYS->{$date};
			log_debug("After date check (date=$date), status: $go_today");

			if(!$go_today) {
				$row->{time} =~ /(\d+):(\d+)/;
				
				$tomorrow[1]--;
				$tomorrow[2] -= 1900;
				my $waketime = mktime(0, $2, $1, @tomorrow);
				if(!$update_nexttime->execute($waketime, $row->{wake_id})) {
					db_error("Couldn't update trigger_time", $update_nexttime);
				}

				next;
			}
		}

		if(!$activate_wake->execute($row->{wake_id})) {
			db_error("Couldn't update trigger_date", $call_wake);
		}

		# Yay, make a call
		activate_wake($row);
	}


	log_debug("Done with wakes");
	# REAP TFTP DIR

	log_debug("Waiting...");
	sleep 10;
}

sub activate_wake($) {
	my($row) = @_;
	log_debug("Doing wake for x".$row->{extension});

	my $log_id = log_wake_start($row->{wake_id}, $row->{extension});

	my $pid = fork();
	if(!defined($pid)) {
		log_error("Couldn't fork: $!");
		log_wake_end("failure", "Couldn't fork: $!", $log_id);
		$snooze_wake->execute($row->{wake_id}) || db_error("Couldn't snooze wake " . $row->{wake_id}, $snooze_wake);
		return 1;
	} elsif($pid) {
		$kidmap{$pid} = $log_id;
		log_debug("Kid is $pid (log ID $log_id)");
		return 0;
	} else {
		$db_connected = 0; # Don't log "Finnegan going down!" when we exit.

		my @samples = ();
		my($hour, $minute, $ampm) = split(/:/, strftime("%I:%M:%p", localtime(time())));
		$hour =~ s/^0//;
		$minute =~ s/^0//;
		$ampm = lc($ampm);

		my $message;
		if($row->{message} == -1) { # Random message
			my @messages = map { $_->{id} } @$Finnegan::Config::messages;
			$message = $messages[int(rand(@messages))];
		} else {
			$message = $row->{message};
		}

		@samples = (
			"../g77-mulaw/messages/$message.ul",
			"../g77-mulaw/wake/timeis.ul",
			"../g77-mulaw/wake/hours/$hour.ul"
		);

		if($minute > 0) {
			if($minute > 0 and $minute < 20) {
				push @samples, "../g77-mulaw/wake/ten-minutes/0.ul" if $minute < 10;
				push @samples, "../g77-mulaw/wake/one-minutes/$minute.ul";
			} else {
				$minute =~ /(.)(.)/;
				push @samples, "../g77-mulaw/wake/ten-minutes/".($1*10).".ul";
				push @samples, "../g77-mulaw/wake/one-minutes/$2.ul" if $2;
			}
		}

		push @samples, "../g77-mulaw/wake/$ampm.ul";

		push @samples, "../g77-mulaw/wake/snooze.ul";
		push @samples, "../g77-mulaw/wake/edit.ul";

		if(!open(OUTSAMPLE, ">", $Finnegan::Config::Cisco::tftp_base . $Finnegan::Config::Cisco::tftp_path . "/fin-$$.ul")) {
			log_wake_end("failure", "Couldn't open output sample fin-$$.ul: $!", $log_id);
			$snooze_wake->execute($row->{wake_id}) || db_error("Couldn't snooze wake " . $row->{wake_id}, $snooze_wake);
			exit 1;
		}

		local $/ = undef;

		log_debug("Reading samples...");
		foreach(@samples) {
			log_debug("Reading sample $_");
			if(!open(SAMPLE, $_)) {
				log_wake_end("failure", "Couldn't open input sample $_: $!", $log_id);
				$snooze_wake->execute($row->{wake_id}) || db_error("Couldn't snooze wake " . $row->{wake_id}, $snooze_wake);
				exit 1;
			}
			print OUTSAMPLE <SAMPLE>;
			close SAMPLE;
		}

		close OUTSAMPLE;
		log_debug("Done with samples.");


		my $failuretext = undef;
		if($Finnegan::Config::nocalls) {
			log_debug("Output sample is in fin-$$.ul");
		} else {
			if(system("./finnegan-call-cisco", $type, $row->{extension}, 10, $Finnegan::Config::Cisco::tftp_base . $Finnegan::Config::Cisco::tftp_path . "/fin-$$.ul") != 0) {
				my $status = $? >> 8;

				if($? == -1) {
					$failuretext = "Failed to execute wake script: $!";
				} elsif($? & 127) {
					$failuretext = "Wake script died with signal " . ($? & 127);
				} else {
					$failuretext = "";
				}
			}
		}


		if(!defined($failuretext)) {
			exit 0;
		} else {
			$snooze_wake->execute($row->{wake_id}) || db_error("Couldn't snooze wake " . $row->{wake_id}, $snooze_wake);
			exit 1;
		}
	}
}

#!/usr/bin/perl

use strict;
use warnings;
use Socket;
use lib "./blib/lib";
use Net::OSCAR qw(:all);
use Net::OSCAR::XML;
use Net::OSCAR::Utility qw(hexdump);
use Net::Pcap;

our $session = Net::OSCAR->new();

sub BEGIN {
	eval {
		require "net/bpf.ph";
	};
	die "Couldn't find net/bpf.ph.\nPlease create it by doing cd /usr/include ; h2ph net/bpf.h\n" if $@;
}

my $file = shift or die "Usage: snacsnatcher pcapfile [verbose]\n";

# Quick and dirty protocol analyzer

use vars qw($packet $verbose %buffer %bufflen  %snacbuff %seqnos $datalink @blarray);
$packet = 0;
$verbose = shift;

$| = 1;

sub ssdump_scalar($$);
sub ssdump_list($$);
sub ssdump_hash($$);

sub ssdump_scalar($$) {
	my($val, $depth) = @_;

	my $hex = hexdump($val);
	if($hex and $hex ne $val) {
		print join("\n",
			map {
				("\t" x $depth) . $_
			} split(/\n/,
				$hex
			)
		), "\n";
	} else {
		$val ||= "";
		print "$val\n";
	}
}

sub ssdump_list($$) {
	my($val, $depth) = @_;

	print "\t" x $depth;
	foreach (@$val) {
		print "[\n";

		if(!ref($_)) {
			ssdump_scalar($_, $depth);
		} elsif(ref($_) eq "HASH") {
			ssdump_hash($_, $depth+1);
		} elsif(ref($_) eq "ARRAY") {
			ssdump_list($_, $depth+1);
		} elsif(ref($_) eq "SCALAR") {
			ssdump_scalar($$_, $depth);
		} else {
			die "Unknown reftype: " . ref($_) . "\n";
		}

		print "\t" x $depth;
		print "],";
	}
	print "\n";
}

sub ssdump_hash($$) {
	my($struct, $depth) = @_;

	foreach my $key (sort keys %$struct) {
		my $val = $struct->{$key};

		print "\t" x $depth;
		print $key, " => ";

		if(!ref($val)) {
			if($key =~ /ip$/ and $val =~ /^\d+$/) {
				my($q1, $q2, $q3, $q4) = (
					($val >> 24),
					(($val >> 16) & 0xFF),
					(($val >> 8) & 0xFF),
					($val & 0xFF)
				);
				$val = "$q1.$q2.$q3.$q4";
			}

			ssdump_scalar($val, $depth);
		} elsif(ref($val) eq "HASH") {
			print "\n";
			ssdump_hash($val, $depth+1);
		} elsif(ref($val) eq "ARRAY") {
			print "\n";
			ssdump_list($val, $depth);
		} elsif(ref($val) eq "SCALAR") {
			ssdump_scalar($$val, $depth);
		} else {
			die "Unknown reftype: " . ref($val) . "\n";
		}
	}
}

sub got_packet($$$) {
	my($user, $hdr, $pkt) = @_;
	my($inaddr, $outaddr);
	my $tlv;

	$packet++;
	# This removes the datalink-level headers from a packet.
	# You may need to adjust this - this is a very Q&D hack.
	# Only ethernet (DLT_EN10MB) is tested.
	#
	# These are taken from tcpdump.
	#
	if($datalink == DLT_NULL or $datalink == DLT_LOOP) {
		substr($pkt, 0, 4) = "";
	} elsif($datalink == DLT_EN10MB or $datalink == DLT_IEEE802) {
		substr($pkt, 0, 14) = "";
	} elsif($datalink == DLT_SLIP) {
		substr($pkt, 0, 16) = "";
	} elsif($datalink == DLT_PPP) {
		substr($pkt, 0, 4) = "";
	} else {
		die "Unsupported datalink $datalink\n";
	}

	my($iplen) = unpack("C", $pkt);
	$iplen = ($iplen&0xF) * 4;
	my $src = substr($pkt, 12, 4);
	my $dst = substr($pkt, 16, 4);
	substr($pkt, 0, $iplen) = ""; #Get rid of IP headers
	$src = inet_ntoa($src);
	$dst = inet_ntoa($dst);

	my($src_port, $dst_port, $seqno, $ack_seq, $tcplen, $flags) = 
		unpack("nnNNCC", substr($pkt, 0, 14, ""));
	$tcplen = ($tcplen>>4)*4;
	return if $flags & 0x2; # SYN
	return unless $flags & 0x8; # PSH

	my $conn_key = "$src:$src_port -> $dst:$dst_port";
	$buffer{$conn_key} ||= "";
	$bufflen{$conn_key} ||= 0;


	# Ignore retransmissions
	$seqnos{$conn_key} ||= [undef, undef, undef, undef, undef, undef, undef, undef, undef, undef];
	return if grep {defined($_) and $_ eq $seqno} @{$seqnos{$conn_key}};
	shift @{$seqnos{$conn_key}};
	push @{$seqnos{$conn_key}}, $seqno;	


	PACKET: while($pkt) {
		if($buffer{$conn_key}) {
			$pkt = $buffer{$conn_key} . $pkt;
			$buffer{$conn_key} = "";
		}

		if($bufflen{$conn_key}) {
			if(length($pkt) < $bufflen{$conn_key}) {
				$buffer{$conn_key} = $pkt;
				return;
			} else {
				$bufflen{$conn_key} = 0;
			}
		} else {
			if(length($pkt) < $tcplen) {
				$buffer{$conn_key} = $pkt;
				$bufflen{$conn_key} = $tcplen;
				return;
			}
		}


		if($snacbuff{$conn_key}) {
			$pkt = $snacbuff{$conn_key} . $pkt;
			$snacbuff{$conn_key} = "";
		}

		my($firstbyte) = substr($pkt, 0, 1, "");
		if($firstbyte ne "*") {
			next;
			#print "$src => $dst:";
			#print " Got non-SNAC packet\n";
			#next;
		}

		my($chan, $seqno, $len) = unpack("Cnn", substr($pkt, 0, 5, ""));
		if(length($pkt) < $len) {
			$snacbuff{$conn_key} = pack("CCnn", 42, $chan, $seqno, $len);
			$snacbuff{$conn_key} .= $pkt;
			return;
		}

		print "$src:$src_port => $dst:$dst_port";
		printf " ch=%02X", $chan;

		my %snac_data = protoparse($session, "snac")->unpack(substr($pkt, 0, $len, ""));
		printf " fl=%02X/%02X", $snac_data{flags1} || 0, $snac_data{flags2} || 0;
		printf " [%04X/%04X]", $snac_data{family} || 0, $snac_data{subtype} || 0;

		my $protobit = snac_to_protobit(%snac_data);
		if(!$protobit) {
			print " == UNKNOWN";
			print hexdump($snac_data{data}, 1);
			print "\n";
		} else {
			print " == $protobit\n";
			my %data = protoparse($session, $protobit)->unpack($snac_data{data});

			if($protobit =~ /^(incoming|outgoing) IM$/) {
				my $channel_data;

				if($data{channel} == 1) {
					$channel_data = {protoparse($session, "standard IM footer")->unpack($data{message_body})};
				} elsif($data{channel} == 2) {
					$channel_data = {protoparse($session, "rendezvous IM")->unpack($data{message_body})};
				} else {
					$channel_data = $data{message_body};
				}

				$data{message_body} = $channel_data;
			}

			ssdump_hash(\%data, 1);
		}

		print "\n";
	}
}

my $pcap = Net::Pcap::open_offline($file, \$!) or die "Couldn't open $file: $!\n";
$datalink = Net::Pcap::datalink($pcap);
Net::Pcap::dispatch($pcap, 0, \&got_packet, undef);
Net::Pcap::close($pcap);

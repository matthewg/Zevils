#!/usr/bin/perl

use strict;
use warnings;
use SVN::Client;
use SVN::Wc;
use Data::Dumper qw(Dumper);
use File::Spec;
use File::Temp qw(tempfile);
use Cwd qw(abs_path getcwd);
use FindBin qw($Bin);
use lib "$Bin";
use BlameUI::Console;

@ARGV == 1 or @ARGV == 2 or die "Usage: $0 path [lineno]\n";
our $SVN = getSVN();
main(@ARGV);
#test(@ARGV);

sub test {
  open(FILE, shift);
  undef $/;
  my($data) = <FILE>;
  close(FILE);

  findChangeToLine($data, shift);
}

sub main {
  my($path, $lineno) = @_;
  $path = makeRelativePath($path);
  my $rev = getRevision($path);
  my $blame = getBlame($path, $rev);
  if(!$lineno) {
    showBlame($blame);
    # prompt for line
  }

  while(1) {
    my $changeRev = getBlameRev($blame, $lineno);
    my $diff = getDiff($path, $changeRev);
    my $diffData = parseDiff($diff);
    my $targetLine = findChangeToLine($diffData, $lineno);

    my $ui = BlameUI::Console->new
      ($diffData,
       sub {
         my @ret;
         my $lineno = 1;
         my $emitLine = sub {
           my($fmt, @args) = @_;
           push @ret, DiffLine->new($lineno, $lineno, sprintf($fmt, @args));
           $lineno++;
         };
         $SVN->log($path,
                   $changeRev,
                   $changeRev,
                   1,
                   0,
                   sub {
                     my($paths, $crev, $auth, $date, $msg) = @_;

                     $emitLine->("r%s | %s | %s", $crev, $auth, $date);
                     if ($paths) {
                       $emitLine->("Changed paths:");
                       foreach my $path (sort keys %$paths) {
                         my $pathObj = $paths->{$path};
                         my $copyData = "";
                         if ($pathObj->copyfrom_path) {
                           $copyData = sprintf(" (from %s:%s)",
                                               $pathObj->copyfrom_path,
                                               $pathObj->copyfrom_rev);
                         }
                         $emitLine->("   %s %s%s",
                                     $pathObj->action,
                                     $path,
                                     $copyData);
                       }

                       $emitLine->("");
                     }

                     foreach my $line (split(/\n/, $msg)) {
                       $emitLine->($line);
                     }
                   });

         \@ret;
       });
    $ui->showDiff($targetLine);
    last;
  }
}


sub getSVN {
  my @auth = (SVN::Client::get_simple_provider(),
              SVN::Client::get_username_provider());
  return SVN::Client->new(auth => \@auth);
}

sub makeRelativePath {
  my($pathstring) = @_;
  my $cwd = getcwd();
  my $canonpath = abs_path($pathstring);
  $canonpath =~ s!^\Q$cwd\E/?!! or die
    "'$canonpath' is not inside '$cwd'!\n";
  $canonpath;
}

sub getRevision {
  my($path) = @_;
  my $revision;
  $SVN->info($path, undef, 'WORKING', sub {
               my($path, $info) = @_;
               $revision = $info->rev;
             },
             0);
  return $revision;
}

# Takes a line number as input.
# Correlates svn blame and svn diff to find out where that line was changed.
# Displays the revision number, top 10 lines of commit log, and 10
# lines of diff hunk.  Presents options:
#   log: Page through log
#   diff: Page through diff
#   back [n]: Recurse (for line n)
#   branch: ... some procedure for following branches?
#           ... and renames?

sub getBlame {
  my($path, $revision) = @_;
  my @ret;
  $SVN->blame($path,
             0,
             $revision,
             sub {
               my($line_no, $revision, $author, $date, $line) = @_;
               # These line numbers are 0-based, we want 1-based.
               push @ret, [$line_no + 1, $revision, $author, $line];
             });
  \@ret;
}

sub getDiff {
  my($path, $revision, $prevPath, $prevRevision, @diff_opts) = @_;
  $prevPath ||= $path;
  $prevRevision ||= $revision - 1;

  my($outfh, $outfn) = tempfile();
  my($errfh, $errfn) = tempfile();
  $SVN->diff(\@diff_opts,
             $prevPath, $prevRevision,
             $path, $revision,
             0, 1, 0,
             $outfh, $errfh);
  $outfh->close();
  $errfh->close();

  local $/ = undef;
  open(ERRFH, $errfn) or die "Couldn't open errfn '$errfn': $!\n";
  my $errstr = <ERRFH>;
  close(ERRFH);
  if($errstr) {
    die "Couldn't diff $prevPath\@$prevRevision vs. $path\@$revision!\n$errstr\n";
  }

  open(OUTFH, $outfn) or die "Couldn't open outfn '$outfn': $!\n";
  my $outstr = <OUTFH>;
  close(OUTFH);
  unlink($errfn, $outfn);

  $outstr;
};

sub getBlameRev {
  my($blame, $lineno) = @_;
  foreach (@$blame) {
    return $_->[1] if $_->[0] == $lineno;
  }
}

sub parseDiff {
  my($diff) = @_;

  my(@hunks, @old, @new, @mixed, $hunk);
  my($line_old, $line_new, $hunkline_old, $hunkline_new);
  my @lines = split(/\n/, $diff);
  while(@lines) {
    my $line = shift @lines;
    if($line =~ /^\@\@\s+-(\d+),(\d+)\s+\+(\d+),(\d+)\s+\@\@$/) {
      my $diffLine = DiffLine->new(undef, undef, $line);
      push @old, $diffLine;
      push @new, $diffLine;
      push @mixed, $diffLine;

      $hunk = {
               start_old => $1,
               len_old => $2,
               start_new => $3,
               len_new => $4,
               lines_old => [],
               lines_new => [],
              };
      push @hunks, $hunk;
      $line_old = $hunk->{start_old};
      $line_new = $hunk->{start_new};
      $hunkline_old = 0;
      $hunkline_new = 0;

      while($hunkline_old < $hunk->{len_old} and
            $hunkline_new < $hunk->{len_new}) {
        my $hunkline = shift @lines;

        my $linetext = $hunkline;
        $linetext =~ s/^([ +-])// or die
          "Unexpected hunk line: $hunkline\n";

        my $linemode = $1;
        my($line_in_old, $line_in_new) = (0, 0);
        if($linemode eq " ") {
          $line_in_old = 1;
          $line_in_new = 1;
        } elsif($linemode eq "-") {
          $line_in_old = 1;
        } elsif($linemode eq "+") {
          $line_in_new = 1;
        }

        $hunkline_old++ if $line_in_old;
        $hunkline_new++ if $line_in_new;
        my $lineData = DiffLine->new($hunk->{start_old} + $hunkline_old,
                                     $hunk->{start_new} + $hunkline_new,
                                     $hunkline);
        push @mixed, $lineData;
        if($line_in_old) {
          push @old, $lineData;
          push @{$hunk->{lines_old}}, $linetext;
        }
        if($line_in_new) {
          push @new, $lineData;
          push @{$hunk->{lines_new}}, $linetext;
        }
      }
    }
  }

  return {
          old => \@old,
          new => \@new,
          mixed => \@mixed
         };
}

sub findChangeToLine {
  my($diffData, $targetLineNo) = @_;

  foreach my $hunk (@{$diffData->{hunks}}) {
    if($targetLineNo > $hunk->{start_new} and
       $targetLineNo < ($hunk->{start_new} + $hunk->{len_new})) {

      return $hunk->{start_old};
    }
  }

  return;
}

package DiffLine;

use strict;
use warnings;

sub new {
  my($class, $oldFileLine, $newFileLine, $lineText) = @_;
  $class = ref($class) || $class || __PACKAGE__;
  my $self = [$oldFileLine, $newFileLine, $lineText];
  bless $self, $class;
}

sub oldFileLine { shift->[0]; }
sub newFileLine { shift->[1]; }
sub lineText { shift->[2]; }
